

--- ./tsconfig.app.json ---
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/app",
    "types": []
  },
  "files": [
    "src/main.ts"
  ],
  "include": [
    "src/**/*.d.ts"
  ]
}


--- ./README.md ---
# NiVehicleLogisticsWeb

This project was generated using [Angular CLI](https://github.com/angular/angular-cli) version 19.2.1.

## Development server

To start a local development server, run:

```bash
ng serve
```

Once the server is running, open your browser and navigate to `http://localhost:4200/`. The application will automatically reload whenever you modify any of the source files.

## Code scaffolding

Angular CLI includes powerful code scaffolding tools. To generate a new component, run:

```bash
ng generate component component-name
```

For a complete list of available schematics (such as `components`, `directives`, or `pipes`), run:

```bash
ng generate --help
```

## Building

To build the project run:

```bash
ng build
```

This will compile your project and store the build artifacts in the `dist/` directory. By default, the production build optimizes your application for performance and speed.

## Running unit tests

To execute unit tests with the [Karma](https://karma-runner.github.io) test runner, use the following command:

```bash
ng test
```

## Running end-to-end tests

For end-to-end (e2e) testing, run:

```bash
ng e2e
```

Angular CLI does not come with an end-to-end testing framework by default. You can choose one that suits your needs.

## Additional Resources

For more information on using the Angular CLI, including detailed command references, visit the [Angular CLI Overview and Command Reference](https://angular.dev/tools/cli) page.


--- ./angular.json ---
{
  "$schema": "./node_modules/@angular/cli/lib/config/schema.json",
  "version": 1,
  "newProjectRoot": "projects",
  "projects": {
    "logistics-backend": {
      "projectType": "application",
      "schematics": {
        "@schematics/angular:component": {
          "style": "scss",
          "standalone": false
        },
        "@schematics/angular:directive": {
          "standalone": false
        },
        "@schematics/angular:pipe": {
          "standalone": false
        }
      },
      "root": "",
      "sourceRoot": "src",
      "prefix": "app",
      "architect": {
        "build": {
          "builder": "@angular-devkit/build-angular:application",
          "options": {
            "outputPath": "dist/logistics-backend",
            "index": "src/index.html",
            "browser": "src/main.ts",
            "polyfills": ["zone.js"],
            "tsConfig": "tsconfig.app.json",
            "inlineStyleLanguage": "scss",
            "assets": [
              {
                "glob": "**/*",
                "input": "public"
              },
              {
                "glob": "**/*",
                "input": "src/assets",
                "output": "/assets"
              }
            ],
            "styles": ["@angular/material/prebuilt-themes/indigo-pink.css", "src/styles.scss"],
            "scripts": []
          },
          "configurations": {
            "production": {
              "budgets": [
                {
                  "type": "initial",
                  "maximumWarning": "5mb",
                  "maximumError": "10MB"
                },
                {
                  "type": "anyComponentStyle",
                  "maximumWarning": "5mb",
                  "maximumError": "10mb"
                }
              ],
              "outputHashing": "all"
            },
            "development": {
              "optimization": false,
              "extractLicenses": false,
              "sourceMap": true
            }
          },
          "defaultConfiguration": "production"
        },
        "serve": {
          "builder": "@angular-devkit/build-angular:dev-server",
          "configurations": {
            "production": {
              "buildTarget": "logistics-backend:build:production"
            },
            "development": {
              "buildTarget": "logistics-backend:build:development"
            }
          },
          "defaultConfiguration": "development"
        },
        "extract-i18n": {
          "builder": "@angular-devkit/build-angular:extract-i18n"
        },
        "test": {
          "builder": "@angular-devkit/build-angular:karma",
          "options": {
            "polyfills": ["zone.js", "zone.js/testing"],
            "tsConfig": "tsconfig.spec.json",
            "inlineStyleLanguage": "scss",
            "assets": [
              {
                "glob": "**/*",
                "input": "public"
              },
              {
                "glob": "**/*",
                "input": "src/assets",
                "output": "/assets"
              }
            ],
            "styles": ["src/styles.scss"],
            "scripts": []
          }
        }
      }
    }
  },
  "cli": {
    "analytics": false
  }
}


--- ./package.json ---
{
  "name": "ni-vehicle-logistics-web",
  "version": "0.0.0",
  "scripts": {
    "ng": "ng",
    "start": "ng serve",
    "build": "ng build",
    "watch": "ng build --watch --configuration development",
    "test": "ng test",
    "lint": "ng lint"
  },
  "private": true,
  "dependencies": {
    "@angular/animations": "^19.2.9",
    "@angular/cdk": "^19.2.14",
    "@angular/common": "^19.2.0",
    "@angular/compiler": "^19.2.0",
    "@angular/core": "^19.2.0",
    "@angular/fire": "^19.1.0",
    "@angular/forms": "^19.2.0",
    "@angular/material": "^19.2.14",
    "@angular/platform-browser": "^19.2.0",
    "@angular/platform-browser-dynamic": "^19.2.0",
    "@angular/router": "^19.2.0",
    "@swimlane/ngx-charts": "^22.0.0-alpha.1",
    "chart.js": "^4.4.9",
    "d3-shape": "^3.2.0",
    "file-saver": "^2.0.5",
    "firebase": "^11.6.1",
    "jspdf": "^3.0.1",
    "jspdf-autotable": "^5.0.2",
    "ngx-mask": "^19.0.6",
    "rxjs": "~7.8.0",
    "tslib": "^2.3.0",
    "zone.js": "~0.15.0"
  },
  "devDependencies": {
    "@angular-devkit/build-angular": "^19.2.1",
    "@angular/cli": "^19.2.1",
    "@angular/compiler-cli": "^19.2.0",
    "@types/d3-shape": "^3.1.7",
    "@types/file-saver": "^2.0.7",
    "@types/jasmine": "~5.1.0",
    "@types/papaparse": "^5.3.15",
    "jasmine-core": "~5.6.0",
    "karma": "~6.4.0",
    "karma-chrome-launcher": "~3.2.0",
    "karma-coverage": "~2.2.0",
    "karma-jasmine": "~5.1.0",
    "karma-jasmine-html-reporter": "~2.1.0",
    "sass": "^1.87.0",
    "typescript": "~5.7.2"
  }
}


--- ./tsconfig.json ---
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "compileOnSave": false,
  "compilerOptions": {
    "outDir": "./dist/out-tsc",
    "strict": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "skipLibCheck": true,
    "isolatedModules": true,
    "esModuleInterop": true,
    "sourceMap": true,
    "declaration": false,
    "experimentalDecorators": true,
    "moduleResolution": "bundler",
    "importHelpers": true,
    "target": "ES2022",
    "module": "ES2022",
    "lib": [
      "ES2022",
      "dom"
    ]
  },
  "angularCompilerOptions": {
    "enableI18nLegacyMessageIdFormat": false,
    "strictInjectionParameters": true,
    "strictInputAccessModifiers": true,
    "strictTemplates": true
  }
}


--- ./firebase.json ---
{
  "projects": {
    "default": "ni-vehicle-logistics"
  },
  "hosting": {
    "public": "dist/logistics-portal",
    "ignore": ["firebase.json", "**/.*", "**/node_modules/**"],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ],
    "headers": [
      {
        "source": "**/*.@(jpg|jpeg|gif|png|svg|webp|js|css|eot|otf|ttf|ttc|woff|woff2|font.css)",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "max-age=31536000"
          }
        ]
      },
      {
        "source": "**/*.@(html|json)",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "max-age=3600"
          }
        ]
      }
    ]
  },
  "firestore": {
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  },
  "storage": {
    "rules": "storage.rules"
  },
  "functions": {
    "predeploy": ["npm --prefix \"$RESOURCE_DIR\" run lint", "npm --prefix \"$RESOURCE_DIR\" run build"],
    "source": "functions"
  }
}


--- ./eslint.config.js ---
// @ts-check
const eslint = require("@eslint/js");
const tseslint = require("typescript-eslint");
const angular = require("angular-eslint");

module.exports = tseslint.config(
  {
    files: ["**/*.ts"],
    extends: [
      eslint.configs.recommended,
      ...tseslint.configs.recommended,
      ...tseslint.configs.stylistic,
      ...angular.configs.tsRecommended,
    ],
    processor: angular.processInlineTemplates,
    rules: {
      "@angular-eslint/directive-selector": [
        "error",
        {
          type: "attribute",
          prefix: "app",
          style: "camelCase",
        },
      ],
      "@angular-eslint/component-selector": [
        "error",
        {
          type: "element",
          prefix: "app",
          style: "kebab-case",
        },
      ],
    },
  },
  {
    files: ["**/*.html"],
    extends: [
      ...angular.configs.templateRecommended,
      ...angular.configs.templateAccessibility,
    ],
    rules: {},
  }
);


--- ./tsconfig.spec.json ---
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/spec",
    "types": [
      "jasmine"
    ]
  },
  "include": [
    "src/**/*.spec.ts",
    "src/**/*.d.ts"
  ]
}


--- ./firestore.indexes.json ---
{
  "indexes": [
    {
      "collectionGroup": "jobs",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "status",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "updatedAt",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "jobs",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "driverId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "updatedAt",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "jobs",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "vehicleId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "updatedAt",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "jobs",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "customerId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "updatedAt",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "jobs",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "customerName",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "updatedAt",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "jobs",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "driverId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "status",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "updatedAt",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "jobs",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "collectionDate",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "status",
          "order": "ASCENDING"
        }
      ]
    },
    {
      "collectionGroup": "jobs",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "collectionDate",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "updatedAt",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "jobs",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "deliveryDate",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "status",
          "order": "ASCENDING"
        }
      ]
    },
    {
      "collectionGroup": "jobs",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "priority",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "status",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "updatedAt",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "jobs",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "createdAt",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "status",
          "order": "ASCENDING"
        }
      ]
    },
    {
      "collectionGroup": "jobs",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "status",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "collectionDate",
          "order": "ASCENDING"
        }
      ]
    },
    {
      "collectionGroup": "vehicles",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "status",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "updatedAt",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "expenses",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "userId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "createdAt",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "expenses",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "status",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "createdAt",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "notifications",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "userId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "createdAt",
          "order": "DESCENDING"
        }
      ]
    }
  ],
  "fieldOverrides": []
}


--- ./public/index.html ---
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Welcome to Firebase Hosting</title>

    <!-- update the version number as needed -->
    <script defer src="/__/firebase/11.6.1/firebase-app-compat.js"></script>
    <!-- include only the Firebase features as you need -->
    <script defer src="/__/firebase/11.6.1/firebase-auth-compat.js"></script>
    <script defer src="/__/firebase/11.6.1/firebase-database-compat.js"></script>
    <script defer src="/__/firebase/11.6.1/firebase-firestore-compat.js"></script>
    <script defer src="/__/firebase/11.6.1/firebase-functions-compat.js"></script>
    <script defer src="/__/firebase/11.6.1/firebase-messaging-compat.js"></script>
    <script defer src="/__/firebase/11.6.1/firebase-storage-compat.js"></script>
    <script defer src="/__/firebase/11.6.1/firebase-analytics-compat.js"></script>
    <script defer src="/__/firebase/11.6.1/firebase-remote-config-compat.js"></script>
    <script defer src="/__/firebase/11.6.1/firebase-performance-compat.js"></script>
    <!-- 
      initialize the SDK after all desired features are loaded, set useEmulator to false
      to avoid connecting the SDK to running emulators.
    -->
    <script defer src="/__/firebase/init.js?useEmulator=true"></script>

    <style media="screen">
      body { background: #ECEFF1; color: rgba(0,0,0,0.87); font-family: Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 0; }
      #message { background: white; max-width: 360px; margin: 100px auto 16px; padding: 32px 24px; border-radius: 3px; }
      #message h2 { color: #ffa100; font-weight: bold; font-size: 16px; margin: 0 0 8px; }
      #message h1 { font-size: 22px; font-weight: 300; color: rgba(0,0,0,0.6); margin: 0 0 16px;}
      #message p { line-height: 140%; margin: 16px 0 24px; font-size: 14px; }
      #message a { display: block; text-align: center; background: #039be5; text-transform: uppercase; text-decoration: none; color: white; padding: 16px; border-radius: 4px; }
      #message, #message a { box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24); }
      #load { color: rgba(0,0,0,0.4); text-align: center; font-size: 13px; }
      @media (max-width: 600px) {
        body, #message { margin-top: 0; background: white; box-shadow: none; }
        body { border-top: 16px solid #ffa100; }
      }
    </style>
  </head>
  <body>
    <div id="message">
      <h2>Welcome</h2>
      <h1>Firebase Hosting Setup Complete</h1>
      <p>You're seeing this because you've successfully setup Firebase Hosting. Now it's time to go build something extraordinary!</p>
      <a target="_blank" href="https://firebase.google.com/docs/hosting/">Open Hosting Documentation</a>
    </div>
    <p id="load">Firebase SDK Loading&hellip;</p>

    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const loadEl = document.querySelector('#load');
        // // 🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥
        // // The Firebase SDK is initialized and available here!
        //
        // firebase.auth().onAuthStateChanged(user => { });
        // firebase.database().ref('/path/to/ref').on('value', snapshot => { });
        // firebase.firestore().doc('/foo/bar').get().then(() => { });
        // firebase.functions().httpsCallable('yourFunction')().then(() => { });
        // firebase.messaging().requestPermission().then(() => { });
        // firebase.storage().ref('/path/to/ref').getDownloadURL().then(() => { });
        // firebase.analytics(); // call to activate
        // firebase.analytics().logEvent('tutorial_completed');
        // firebase.performance(); // call to activate
        //
        // // 🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥

        try {
          let app = firebase.app();
          let features = [
            'auth', 
            'database', 
            'firestore',
            'functions',
            'messaging', 
            'storage', 
            'analytics', 
            'remoteConfig',
            'performance',
          ].filter(feature => typeof app[feature] === 'function');
          loadEl.textContent = `Firebase SDK loaded with ${features.join(', ')}`;
        } catch (e) {
          console.error(e);
          loadEl.textContent = 'Error loading the Firebase SDK, check the console.';
        }
      });
    </script>
  </body>
</html>


--- ./public/404.html ---
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Page Not Found</title>

    <style media="screen">
      body { background: #ECEFF1; color: rgba(0,0,0,0.87); font-family: Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 0; }
      #message { background: white; max-width: 360px; margin: 100px auto 16px; padding: 32px 24px 16px; border-radius: 3px; }
      #message h3 { color: #888; font-weight: normal; font-size: 16px; margin: 16px 0 12px; }
      #message h2 { color: #ffa100; font-weight: bold; font-size: 16px; margin: 0 0 8px; }
      #message h1 { font-size: 22px; font-weight: 300; color: rgba(0,0,0,0.6); margin: 0 0 16px;}
      #message p { line-height: 140%; margin: 16px 0 24px; font-size: 14px; }
      #message a { display: block; text-align: center; background: #039be5; text-transform: uppercase; text-decoration: none; color: white; padding: 16px; border-radius: 4px; }
      #message, #message a { box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24); }
      #load { color: rgba(0,0,0,0.4); text-align: center; font-size: 13px; }
      @media (max-width: 600px) {
        body, #message { margin-top: 0; background: white; box-shadow: none; }
        body { border-top: 16px solid #ffa100; }
      }
    </style>
  </head>
  <body>
    <div id="message">
      <h2>404</h2>
      <h1>Page Not Found</h1>
      <p>The specified file was not found on this website. Please check the URL for mistakes and try again.</p>
      <h3>Why am I seeing this?</h3>
      <p>This page was generated by the Firebase Command-Line Interface. To modify it, edit the <code>404.html</code> file in your project's configured <code>public</code> directory.</p>
    </div>
  </body>
</html>


--- ./src/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>LogisticsBackend</title>
    <base href="/" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
  </head>
  <body>
    <app-root></app-root>
  </body>
</html>


--- ./src/main.ts ---
import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';

import { AppModule } from './app/app.module';

platformBrowserDynamic().bootstrapModule(AppModule, {
  ngZoneEventCoalescing: true
})
  .catch(err => console.error(err));


--- ./src/styles.scss ---
/* Import Angular Material */
@use '@angular/material' as mat;

/* Include core styles */
@include mat.core();

/* CSS Custom Properties (Variables) */
:root {
  --primary-color: #4b3e21;
  --secondary-color: #9e7520;
  --tertiary-color: #6e4e0a;

  --background-color: #f8f9fa;
  --card-background: #ffffff;
  --text-primary: rgba(0, 0, 0, 0.87);
  --text-secondary: rgba(0, 0, 0, 0.6);
  --border-color: rgba(0, 0, 0, 0.12);
  --hover-color: rgba(0, 0, 0, 0.04);
  --active-color: rgba(75, 62, 33, 0.12);
  --error-color: #f44336;
  --success-color: #4caf50;
  --warning-color: #ff9800;
  --info-color: #2196f3;
}

/* Font Definitions */
@font-face {
  font-family: 'UberMove';
  src: url('./assets/fonts/UberMove-Light.woff2') format('woff2');
  font-weight: 300;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'UberMove';
  src: url('./assets/fonts/UberMove-Regular.woff2') format('woff2');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'UberMove';
  src: url('./assets/fonts/UberMove-Medium.woff2') format('woff2');
  font-weight: 500;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'UberMove';
  src: url('./assets/fonts/UberMove-Bold.woff2') format('woff2');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

/* Base Styles */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html,
body {
  font-family: 'UberMove', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
  font-size: 16px;
  line-height: 1.5;
  color: var(--text-primary);
  background-color: var(--background-color);
}

/* Typography */
h1,
h2,
h3,
h4,
h5,
h6 {
  font-family: 'UberMove', sans-serif;
  font-weight: 500;
  line-height: 1.2;
  color: var(--primary-color);
  margin-bottom: 0.5em;
}

h1 {
  font-size: 24px;
  font-weight: 700;
}

h2 {
  font-size: 20px;
  font-weight: 600;
}

/* Form elements */
input,
select,
textarea,
button {
  font-family: 'UberMove', sans-serif;
  font-size: 14px;
}

/* Links */
a {
  color: var(--secondary-color);
  text-decoration: none;
  transition: color 0.2s ease;
}

a:hover {
  color: var(--tertiary-color);
  text-decoration: underline;
}

/* Font utility classes */
.font-light {
  font-weight: 300;
}
.font-regular {
  font-weight: 400;
}
.font-medium {
  font-weight: 500;
}
.font-semibold {
  font-weight: 600;
}
.font-bold {
  font-weight: 700;
}

/* Text size utility classes */
.text-sm {
  font-size: 14px;
}
.text-base {
  font-size: 16px;
}
.text-lg {
  font-size: 18px;
}
.text-xl {
  font-size: 20px;
}

/* Line height utility classes */
.leading-tight {
  line-height: 1.25;
}
.leading-normal {
  line-height: 1.5;
}
.leading-relaxed {
  line-height: 1.75;
}

/* Letter spacing utility classes */
.tracking-tight {
  letter-spacing: -0.025em;
}
.tracking-normal {
  letter-spacing: 0;
}
.tracking-wide {
  letter-spacing: 0.025em;
}

/* Status chip colors */
.status-chip.status-active,
.status-chip.status-approved,
.status-chip.status-completed,
.status-chip.status-success,
.status-chip.status-green {
  background-color: rgba(76, 175, 80, 0.12);
  color: #4caf50;
}

.status-chip.status-inactive,
.status-chip.status-default,
.status-chip.status-gray {
  background-color: rgba(97, 97, 97, 0.12);
  color: #616161;
}

.status-chip.status-pending,
.status-chip.status-allocated,
.status-chip.status-warning,
.status-chip.status-orange {
  background-color: rgba(255, 152, 0, 0.12);
  color: #ff9800;
}

.status-chip.status-rejected,
.status-chip.status-error,
.status-chip.status-red,
.status-chip.status-cancelled {
  background-color: rgba(244, 67, 54, 0.12);
  color: #f44336;
}

.status-chip.status-delivered,
.status-chip.status-collected,
.status-chip.status-info {
  background-color: rgba(33, 150, 243, 0.12);
  color: #2196f3;
}

/* Material customizations */
.mat-mdc-card {
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1) !important;
  overflow: hidden;
}

/* Snackbar styles */
.success-snackbar {
  background-color: #4caf50;
  color: white;
}

.error-snackbar {
  background-color: #f44336;
  color: white;
}

.info-snackbar {
  background-color: #2196f3;
  color: white;
}

.warning-snackbar {
  background-color: #ff9800;
  color: white;
}

/* Dialog Styles */
.mat-mdc-dialog-container {
  --mdc-dialog-container-color: white;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15) !important;
}

.custom-dialog-container .mat-mdc-dialog-surface {
  border-radius: 8px;
  overflow: hidden;
}

.custom-dialog-container .mat-mdc-dialog-container {
  padding: 0;
}

.mat-mdc-dialog-container .mdc-dialog__surface {
  border-radius: 8px !important;
}

/* Collection dialog */
.collection-dialog .dialog-header {
  background-color: #fff8e1;
}

/* Delivery dialog */
.delivery-dialog .dialog-header {
  background-color: #e8f5e9;
}

/* Warning dialog */
.warning-dialog .dialog-header {
  background-color: #ffebee;
}

/* Allocation dialog */
.allocation-dialog .dialog-header {
  background-color: #e1f5fe;
}

/* Duplication dialog */
.duplication-dialog .dialog-header {
  background-color: #e8eaf6;
}

.duplication-dialog .dialog-header mat-icon {
  color: #3f51b5;
}

/* Duplicate button styling */
.action-btn:has(.material-icons) mat-icon:contains('content_copy') {
  color: #3f51b5;
}

.action-btn:has(.material-icons:contains('content_copy')) {
  border-color: #3f51b5;
  color: #3f51b5;
}

.action-btn:has(.material-icons:contains('content_copy')):hover {
  background-color: #e8eaf6;
}

/* Fallback for browsers that don't support :has() */
.action-btn .material-icons.content_copy {
  color: #3f51b5;
}

/* Fade in animation for dialogs */
.mat-mdc-dialog-container.mdc-dialog__container {
  animation: dialogFadeIn 0.2s ease-out;
}

@keyframes dialogFadeIn {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

/* Driver Selection Dialog */
.driver-selection-dialog {
  min-width: 350px;
}

.driver-selection-dialog .dialog-content {
  padding: 0 !important;
  max-height: 350px;
  overflow-y: auto;
}

.driver-list {
  list-style: none;
  padding: 0;
  margin: 0;
}

.driver-item {
  padding: 12px 24px;
  border-bottom: 1px solid #f0f0f0;
  cursor: pointer;
  transition: background-color 0.2s ease;
  display: flex;
  align-items: center;
  gap: 12px;
}

.driver-item:hover {
  background-color: #f5f9fd;
}

.driver-item:last-child {
  border-bottom: none;
}

.driver-avatar {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background-color: #e1f5fe;
  color: #0288d1;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 500;
  font-size: 16px;
}

.driver-info {
  flex: 1;
}

.driver-name {
  font-weight: 500;
  color: #333;
  margin-bottom: 4px;
}

.driver-details {
  font-size: 13px;
  color: #666;
}

.driver-actions {
  display: flex;
  align-items: center;
}

/* Mobile responsiveness for dialogs */
@media (max-width: 599px) {
  .mat-mdc-dialog-container {
    max-width: 100vw !important;
    width: 100vw !important;
    margin: 0;
    border-radius: 0;
  }

  .custom-dialog-container .mat-mdc-dialog-surface {
    border-radius: 0;
  }

  .mat-mdc-dialog-container .mdc-dialog__surface {
    border-radius: 0 !important;
  }

  .duplication-dialog .mat-dialog-container {
    padding: 16px;
  }

  .duplicate-dialog .dialog-content {
    padding: 0 16px;
    font-size: 14px;
  }

  .duplicate-dialog .dialog-actions {
    padding: 8px 16px 16px;
    flex-direction: column-reverse;
  }

  .duplicate-dialog .dialog-actions button {
    width: 100%;
    margin-left: 0 !important;
    margin-right: 0 !important;
    margin-bottom: 8px;
  }
}

/* Account for sidebar when positioning dialog */
@media (min-width: 600px) {
  .duplication-dialog {
    margin-left: 60px; /* For collapsed sidebar */
  }
}

@media (min-width: 1200px) {
  .duplication-dialog {
    margin-left: 250px; /* For expanded sidebar */
  }
}

/* Mobile optimization */
@media (max-width: 768px) {
  html,
  body {
    font-size: 14px;
  }

  h1 {
    font-size: 22px;
  }

  h2 {
    font-size: 18px;
  }
}

/* Print styles - hide duplication button when printing */
@media print {
  .action-btn:has(.material-icons:contains('content_copy')),
  .action-btn:has(.material-icons.content_copy) {
    display: none;
  }
}


--- ./src/app/app.component.html ---
<!-- App Layout -->
<div class="app-container" [ngClass]="{ 'auth-layout': isAuthPage }">
  <!-- Only show sidebar and topbar when authenticated and not on auth pages -->
  <ng-container *ngIf="hasSidebar">
    <app-nav-sidebar></app-nav-sidebar>
    <app-topbar></app-topbar>
  </ng-container>

  <!-- Main content - always visible but with different styling -->
  <main class="main-content" [ngClass]="{ 'full-width': !hasSidebar }">
    <router-outlet></router-outlet>
  </main>
</div>


--- ./src/app/app-routing.module.ts ---
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { DashboardComponent } from './pages/dashboard/dashboard.component';
import { JobDetailsComponent } from './pages/jobs/job-details/job-details.component';
import { JobListComponent } from './pages/jobs/job-list/job-list.component';
import { DriverListComponent } from './pages/drivers/driver-list/driver-list.component';
import { VehicleModelsComponent } from './pages/vehicles/vehicle-models/vehicle-models.component';
import { JobCreateComponent } from './pages/jobs/job-create/job-create.component';
import { JobEditComponent } from './pages/jobs/job-edit/job-edit.component';
import { DriverCreateComponent } from './pages/drivers/driver-create/driver-create.component';
import { DriverDetailsComponent } from './pages/drivers/driver-details/driver-details.component';
import { VehicleListComponent } from './pages/vehicles/vehicle-list/vehicle-list.component';
import { VehicleDetailsComponent } from './pages/vehicles/vehicle-details/vehicle-details.component';
import { VehicleCreateComponent } from './pages/vehicles/vehicle-create/vehicle-create.component';

// Guards
import { AuthGuard } from './guards/auth.guard';
import { RoleGuard } from './guards/role.guard';
import { CustomerListComponent } from './pages/customers/customers-list/customer-list.component';
import { CustomerCreateComponent } from './pages/customers/customer-create/customer-create.component';
import { CustomerDetailsComponent } from './pages/customers/customer-details/customer-details.component';
import { DriverEditComponent } from './pages/drivers/driver-edit/driver-edit.component';
import { ExpenseListComponent } from './pages/expenses/expense-list/expense-list.component';
import { ExpenseCreateComponent } from './pages/expenses/expense-create/expense-create.component';

const routes: Routes = [
  // Auth routes (lazy loaded)
  {
    path: 'auth',
    loadChildren: () => import('./pages/auth/auth.module').then((m) => m.AuthModule),
  },

  // Protected routes
  {
    path: '',
    redirectTo: '/dashboard',
    pathMatch: 'full',
  },
  {
    path: 'dashboard',
    component: DashboardComponent,
    canActivate: [AuthGuard],
  },
  {
    path: 'jobs',
    canActivate: [AuthGuard],
    children: [
      { path: '', component: JobListComponent },
      {
        path: 'new',
        component: JobCreateComponent,
        canActivate: [RoleGuard],
        data: { permissions: ['canCreateJobs', 'isAdmin'] },
      },
      { path: ':id', component: JobDetailsComponent },
      {
        path: ':id/edit',
        component: JobEditComponent,
        canActivate: [RoleGuard],
        data: { permissions: ['canEditJobs', 'isAdmin'] },
      },
    ],
  },
  {
    path: 'drivers',
    canActivate: [AuthGuard],
    children: [
      { path: '', component: DriverListComponent },
      {
        path: 'new',
        component: DriverCreateComponent,
        canActivate: [RoleGuard],
        data: { permissions: ['canManageUsers', 'isAdmin'] },
      },
      { path: ':id', component: DriverDetailsComponent },
      {
        path: ':id/edit',
        component: DriverEditComponent,
        canActivate: [RoleGuard],
        data: { permissions: ['canManageUsers', 'isAdmin'] },
      },
    ],
  },
  {
    path: 'customers',
    canActivate: [AuthGuard],
    children: [
      { path: '', component: CustomerListComponent },
      {
        path: 'new',
        component: CustomerCreateComponent,
        canActivate: [RoleGuard],
        data: { permissions: ['canManageUsers', 'isAdmin'] },
      },
      { path: ':id', component: CustomerDetailsComponent },
      {
        path: ':id/edit',
        component: CustomerCreateComponent,
        canActivate: [RoleGuard],
        data: { permissions: ['canManageUsers', 'isAdmin'] },
      },
    ],
  },
  {
    path: 'vehicles',
    canActivate: [AuthGuard],
    children: [
      { path: '', component: VehicleListComponent },
      {
        path: 'new',
        component: VehicleCreateComponent,
        canActivate: [RoleGuard],
        data: { permissions: ['canManageUsers', 'isAdmin'] },
      },
      {
        path: 'models',
        component: VehicleModelsComponent,
        canActivate: [RoleGuard],
        data: { permissions: ['canManageUsers', 'isAdmin'] },
      },
      { path: ':id', component: VehicleDetailsComponent },
    ],
  },
  {
    path: 'expenses',
    canActivate: [AuthGuard],
    children: [
      { path: '', component: ExpenseListComponent },
      {
        path: 'new',
        component: ExpenseCreateComponent,
      },
      {
        path: 'new/:jobId',
        component: ExpenseCreateComponent,
      },
    ],
  },

  {
    path: 'settings',
    loadChildren: () => import('./pages/settings/settings.module').then((m) => m.SettingsModule),
    canActivate: [RoleGuard],
    data: { permissions: ['isAdmin'] },
  },

  // Fallback route
  { path: '**', redirectTo: '/dashboard' },
];

@NgModule({
  imports: [
    RouterModule.forRoot(routes, {
      scrollPositionRestoration: 'enabled',
    }),
  ],
  exports: [RouterModule],
})
export class AppRoutingModule {}


--- ./src/app/material.module.ts ---
import { NgModule } from '@angular/core';

// Material Components
import { MatToolbarModule } from '@angular/material/toolbar';
import { MatSidenavModule } from '@angular/material/sidenav';
import { MatListModule } from '@angular/material/list';
import { MatIconModule } from '@angular/material/icon';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import { MatTableModule } from '@angular/material/table';
import { MatPaginatorModule } from '@angular/material/paginator';
import { MatSortModule } from '@angular/material/sort';
import { MatInputModule } from '@angular/material/input';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatSelectModule } from '@angular/material/select';
import { MatDatepickerModule } from '@angular/material/datepicker';
import { MatNativeDateModule } from '@angular/material/core';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatRadioModule } from '@angular/material/radio';
import { MatSlideToggleModule } from '@angular/material/slide-toggle';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatProgressBarModule } from '@angular/material/progress-bar';
import { MatDialogModule } from '@angular/material/dialog';
import { MatSnackBarModule } from '@angular/material/snack-bar';
import { MatTooltipModule } from '@angular/material/tooltip';
import { MatMenuModule } from '@angular/material/menu';
import { MatTabsModule } from '@angular/material/tabs';
import { MatStepperModule } from '@angular/material/stepper';
import { MatExpansionModule } from '@angular/material/expansion';
import { MatChipsModule } from '@angular/material/chips';
import { MatAutocompleteModule } from '@angular/material/autocomplete';
import { MatSliderModule } from '@angular/material/slider';
import { MatGridListModule } from '@angular/material/grid-list';
import { MatBadgeModule } from '@angular/material/badge';
import { MatRippleModule } from '@angular/material/core';
import { MatBottomSheetModule } from '@angular/material/bottom-sheet';
import { MatButtonToggleModule } from '@angular/material/button-toggle';
import { MatDividerModule } from '@angular/material/divider';
import { MatTreeModule } from '@angular/material/tree';

const MaterialComponents = [
  MatToolbarModule,
  MatSidenavModule,
  MatListModule,
  MatIconModule,
  MatButtonModule,
  MatCardModule,
  MatTableModule,
  MatPaginatorModule,
  MatSortModule,
  MatInputModule,
  MatFormFieldModule,
  MatSelectModule,
  MatDatepickerModule,
  MatNativeDateModule,
  MatCheckboxModule,
  MatRadioModule,
  MatSlideToggleModule,
  MatProgressSpinnerModule,
  MatProgressBarModule,
  MatDialogModule,
  MatSnackBarModule,
  MatTooltipModule,
  MatMenuModule,
  MatTabsModule,
  MatStepperModule,
  MatExpansionModule,
  MatChipsModule,
  MatAutocompleteModule,
  MatSliderModule,
  MatGridListModule,
  MatBadgeModule,
  MatRippleModule,
  MatBottomSheetModule,
  MatButtonToggleModule,
  MatDividerModule,
  MatTreeModule,
];

@NgModule({
  imports: MaterialComponents,
  exports: MaterialComponents,
})
export class MaterialModule {}


--- ./src/app/app.component.scss ---
 

--- ./src/app/app.module.ts ---
// src/app/app.module.ts
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { HttpClientModule } from '@angular/common/http';

// Firebase imports - Updated for proper injection context
import { initializeApp, provideFirebaseApp } from '@angular/fire/app';
import { getFirestore, provideFirestore, connectFirestoreEmulator } from '@angular/fire/firestore';
import { getAuth, provideAuth, connectAuthEmulator } from '@angular/fire/auth';
import { getStorage, provideStorage, connectStorageEmulator } from '@angular/fire/storage';
import { getFunctions, provideFunctions, connectFunctionsEmulator } from '@angular/fire/functions';

// Angular Material
import { MaterialModule } from './material.module';

// Charts
import { NgxChartsModule } from '@swimlane/ngx-charts';

// Routing
import { AppRoutingModule } from './app-routing.module';

// Environment
import { environment } from '../environments/environment';

// Components
import { AppComponent } from './app.component';
import { DashboardComponent } from './pages/dashboard/dashboard.component';
import { NavSidebarComponent } from './layout/nav-sidebar/nav-sidebar.component';
import { TopbarComponent } from './layout/topbar/topbar.component';

// Job Components
import { JobListComponent } from './pages/jobs/job-list/job-list.component';
import { JobDetailsComponent } from './pages/jobs/job-details/job-details.component';
import { JobCreateComponent } from './pages/jobs/job-create/job-create.component';
import { JobEditComponent } from './pages/jobs/job-edit/job-edit.component';

// Driver Components
import { DriverListComponent } from './pages/drivers/driver-list/driver-list.component';
import { DriverCreateComponent } from './pages/drivers/driver-create/driver-create.component';
import { DriverDetailsComponent } from './pages/drivers/driver-details/driver-details.component';
import { DriverEditComponent } from './pages/drivers/driver-edit/driver-edit.component';

// Vehicle Components
import { VehicleListComponent } from './pages/vehicles/vehicle-list/vehicle-list.component';
import { VehicleDetailsComponent } from './pages/vehicles/vehicle-details/vehicle-details.component';
import { VehicleCreateComponent } from './pages/vehicles/vehicle-create/vehicle-create.component';
import { VehicleModelsComponent } from './pages/vehicles/vehicle-models/vehicle-models.component';

// Customer Components
import { CustomerListComponent } from './pages/customers/customers-list/customer-list.component';
import { CustomerCreateComponent } from './pages/customers/customer-create/customer-create.component';
import { CustomerDetailsComponent } from './pages/customers/customer-details/customer-details.component';

// Expense Components
import { ExpenseCreateComponent } from './pages/expenses/expense-create/expense-create.component';
import { ExpenseListComponent } from './pages/expenses/expense-list/expense-list.component';

// Dialog Components
import { ConfirmationDialogComponent } from './dialogs/confirmation-dialog.component';
import { DriverSelectionDialogComponent } from './dialogs/driver-selection-dialog.component';
import { JobDuplicateDialogComponent } from './dialogs/job-duplicate-dialog.component';

// Services
import { JobService } from './services/job.service';
import { AuthService } from './services/auth.service';
import { VehicleService } from './services/vehicle.service';
import { CustomerService } from './services/customer.service';
import { ExpenseService } from './services/expense.service';
import { NotificationService } from './services/notification.service';
import { FirebaseService } from './services/firebase.service';

// Guards
import { AuthGuard } from './guards/auth.guard';
import { RoleGuard } from './guards/role.guard';

// Pipes
import { TimeAgoPipe } from './shared/pipes/time-ago.pipe';

@NgModule({
  declarations: [
    // App Component
    AppComponent,

    // Layout Components
    NavSidebarComponent,
    TopbarComponent,

    // Dashboard
    DashboardComponent,

    // Job Components
    JobListComponent,
    JobDetailsComponent,
    JobCreateComponent,
    JobEditComponent,

    // Driver Components
    DriverListComponent,
    DriverCreateComponent,
    DriverDetailsComponent,
    DriverEditComponent,

    // Vehicle Components
    VehicleListComponent,
    VehicleDetailsComponent,
    VehicleCreateComponent,
    VehicleModelsComponent,

    // Customer Components
    CustomerListComponent,
    CustomerCreateComponent,
    CustomerDetailsComponent,

    // Expense Components
    ExpenseCreateComponent,
    ExpenseListComponent,

    // Dialog Components - Only declare dialogs that are not in feature modules
    ConfirmationDialogComponent,
    DriverSelectionDialogComponent,
    JobDuplicateDialogComponent,

    // Pipes
    TimeAgoPipe,
  ],
  imports: [BrowserModule, BrowserAnimationsModule, FormsModule, ReactiveFormsModule, HttpClientModule, MaterialModule, NgxChartsModule, AppRoutingModule],
  providers: [
    // Firebase providers
    provideFirebaseApp(() => initializeApp(environment.firebase)),
    provideFirestore(() => {
      const firestore = getFirestore();
      // if (!environment.production) {
      //   connectFirestoreEmulator(firestore, 'localhost', 8080);
      // }
      return firestore;
    }),
    provideAuth(() => {
      const auth = getAuth();
      // if (!environment.production) {
      //   connectAuthEmulator(auth, 'http://localhost:9099');
      // }
      return auth;
    }),
    provideStorage(() => {
      const storage = getStorage();
      // if (!environment.production) {
      //   connectStorageEmulator(storage, 'localhost', 9199);
      // }
      return storage;
    }),
    provideFunctions(() => {
      const functions = getFunctions();
      // if (!environment.production) {
      //   connectFunctionsEmulator(functions, 'localhost', 5001);
      // }
      return functions;
    }),

    // Services
    JobService,
    AuthService,
    VehicleService,
    CustomerService,
    ExpenseService,
    NotificationService,
    FirebaseService,

    // Guards
    AuthGuard,
    RoleGuard,
  ],
  bootstrap: [AppComponent],
})
export class AppModule {}


--- ./src/app/app.component.ts ---
import { Component, OnInit, OnDestroy } from '@angular/core';
import { Subscription, combineLatest } from 'rxjs';
import { AuthService } from './services/auth.service';
import { AppStateService } from './services/app-state.service';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrl: './app.component.scss',
  standalone: false,
})
export class AppComponent implements OnInit, OnDestroy {
  title = 'logistics-backend';
  isAuthenticated = false;
  isAuthPage = false;
  hasSidebar = false;
  private stateSubscription: Subscription | null = null;

  constructor(
    private authService: AuthService,
    private appStateService: AppStateService
  ) {}

  ngOnInit(): void {
    // Subscribe to combined state changes
    this.stateSubscription = combineLatest([
      this.authService.isAuthenticated(),
      this.appStateService.isAuthPage(),
    ]).subscribe(([isAuthenticated, isAuthPage]) => {
      this.isAuthenticated = isAuthenticated;
      this.isAuthPage = isAuthPage;
      this.hasSidebar = isAuthenticated && !isAuthPage;
    });
  }

  ngOnDestroy(): void {
    // Clean up subscriptions
    if (this.stateSubscription) {
      this.stateSubscription.unsubscribe();
    }
  }
}


--- ./src/app/types/common.types.ts ---
export interface ApiResponse<T = any> {
  data: T;
  success: boolean;
  message?: string;
  error?: string;
}

export interface ErrorResponse {
  message: string;
  code?: string;
  details?: any;
}

// Type guards for better type safety
export function isJob(obj: any): obj is Job {
  return obj && typeof obj === 'object' && typeof obj.id === 'string';
}

export function isJobArray(obj: any): obj is Job[] {
  return Array.isArray(obj) && obj.every(isJob);
}

// Utility types for component props
export interface ComponentError {
  message: string;
  code?: string;
  timestamp: Date;
}

export interface LoadingState {
  isLoading: boolean;
  message?: string;
}

// Update the Job interface to be more strict
export interface Job {
  id: string;
  vehicleId: string;
  driverId: string | null;
  status: JobStatus;
  stage?: string;

  // Customer Information
  customerName?: string;
  customerEmail?: string;
  customerPhone?: string;
  customerId?: string;

  // Vehicle Information
  regNumber?: string;
  make?: string;
  model?: string;
  year?: number | null;
  color?: string;

  // Collection Information
  collectionAddress?: string;
  collectionTown?: string;
  collectionPostcode?: string;
  collectionDate?: Date;
  collectionStartTime?: Date;
  collectionCompleteTime?: Date;

  // Delivery Information
  deliveryAddress?: string;
  deliveryTown?: string;
  deliveryPostcode?: string;
  deliveryDate?: Date;
  deliveryStartTime?: Date;
  deliveryCompleteTime?: Date;

  // Additional Information
  notes?: string;
  specialInstructions?: string;
  priority?: JobPriority;
  estimatedDuration?: number | null;
  actualDuration?: number | null;

  // Timestamps
  createdAt: Date;
  updatedAt: Date;
  allocatedAt?: Date;
  statusUpdatedAt?: Date;

  // Tracking
  createdBy?: string;
  updatedBy?: string;

  // Optional extended fields
  [key: string]: any;
}

export type JobStatus = 'unallocated' | 'allocated' | 'collected' | 'in-transit' | 'delivered' | 'completed' | 'cancelled';

export type JobPriority = 'low' | 'normal' | 'high' | 'urgent';

// Component-specific interfaces with proper typing

// For customer-details component
export interface CustomerJobsResponse {
  jobs: Job[];
  total: number;
  hasMore: boolean;
}

// For expense-create component
export interface DriverJobsResponse {
  jobs: Job[];
  completedJobs: Job[];
}

// For job-details component
export interface JobActionResponse {
  success: boolean;
  message: string;
  jobId?: string;
}

// For job-list component
export interface JobListResponse {
  jobs: Job[];
  total: number;
  page: number;
  hasMore: boolean;
}

// Service method return types
export interface JobDuplicationResult {
  newJobId: string;
  originalJobId: string;
  success: boolean;
}

export interface JobAllocationResult {
  jobId: string;
  driverId: string;
  success: boolean;
  message: string;
}

// Component callback types
export type JobSuccessCallback = (jobs: Job[]) => void;
export type JobErrorCallback = (error: ErrorResponse) => void;
export type JobActionCallback = (result: JobActionResponse) => void;

// Service observer types
export interface JobServiceObserver<T = any> {
  next: (value: T) => void;
  error: (error: ErrorResponse) => void;
  complete?: () => void;
}

// Import this in components to avoid 'any' types
export interface TypedJobObserver {
  next: (jobs: Job[]) => void;
  error: (error: ErrorResponse) => void;
  complete?: () => void;
}

export interface TypedJobActionObserver {
  next: (result: JobActionResponse) => void;
  error: (error: ErrorResponse) => void;
  complete?: () => void;
}


--- ./src/app/layout/topbar/topbar.component.ts ---
import {
  Component,
  OnInit,
  ViewChild,
  ElementRef,
  Output,
  EventEmitter,
  OnDestroy,
} from '@angular/core';
import { Router, NavigationEnd } from '@angular/router';
import { filter } from 'rxjs/operators';
import { Subscription } from 'rxjs';
import {
  NotificationService,
  Notification,
} from '../../services/notification.service';
import { AuthService } from '../../services/auth.service';
import { MatSnackBar } from '@angular/material/snack-bar';

interface SearchResult {
  id: string;
  icon: string;
  title: string;
  subtitle: string;
  link: string;
}

@Component({
  selector: 'app-topbar',
  templateUrl: './topbar.component.html',
  styleUrls: ['./topbar.component.scss'],
  standalone: false,
})
export class TopbarComponent implements OnInit, OnDestroy {
  @Output() menuToggled = new EventEmitter<void>();
  @ViewChild('searchInput') searchInput!: ElementRef;

  // User Information
  userName = 'John Doe';
  userEmail = 'john.doe@example.com';
  userRole = 'Administrator';
  userAvatar = 'assets/images/avatar-placeholder.png';
  isUserOnline = true;

  // Search State
  isSearchOpen = false;
  searchQuery = '';
  searchResults: SearchResult[] = [];

  // Theme State
  isDarkTheme = false;

  // Navigation State
  currentSection = '';
  currentPage = '';

  // Notifications
  notifications: Notification[] = [];
  unreadCount = 0;
  private notificationsSubscription: Subscription;
  private unreadCountSubscription: Subscription;
  private userProfileSubscription: Subscription;

  constructor(
    private router: Router,
    private notificationService: NotificationService,
    private authService: AuthService,
    private snackBar: MatSnackBar
  ) {
    this.setupRouteListener();

    // Subscribe to notifications
    this.notificationsSubscription =
      this.notificationService.notifications$.subscribe((notifications) => {
        this.notifications = notifications;
      });

    // Subscribe to unread count
    this.unreadCountSubscription =
      this.notificationService.unreadCount$.subscribe((count) => {
        this.unreadCount = count;
      });

    // Subscribe to user profile
    this.userProfileSubscription = this.authService
      .getUserProfile()
      .subscribe((profile) => {
        if (profile) {
          this.userName =
            profile.name || `${profile.firstName} ${profile.lastName}`.trim();
          this.userEmail = profile.email;
          this.userRole = profile.role || 'User';
          this.isUserOnline = true;
        }
      });
  }

  ngOnInit(): void {
    this.updateBreadcrumb();
    this.loadUserPreferences();
  }

  ngOnDestroy(): void {
    // Clean up subscriptions
    if (this.notificationsSubscription) {
      this.notificationsSubscription.unsubscribe();
    }
    if (this.unreadCountSubscription) {
      this.unreadCountSubscription.unsubscribe();
    }
    if (this.userProfileSubscription) {
      this.userProfileSubscription.unsubscribe();
    }
  }

  // Navigation Methods
  private setupRouteListener(): void {
    this.router.events
      .pipe(filter((event) => event instanceof NavigationEnd))
      .subscribe(() => {
        this.updateBreadcrumb();
      });
  }

  private updateBreadcrumb(): void {
    const path = this.router.url.split('/').filter((segment) => segment);
    this.currentSection = this.formatBreadcrumb(path[0] || 'Dashboard');
    this.currentPage = path[1] ? this.formatBreadcrumb(path[1]) : '';
  }

  private formatBreadcrumb(segment: string): string {
    return segment
      .split('-')
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join(' ');
  }

  getCurrentSection(): string {
    return this.currentSection;
  }

  getCurrentPage(): string {
    return this.currentPage;
  }

  // Search Methods
  openSearch(): void {
    this.isSearchOpen = true;
    // Allow DOM to update before focusing
    setTimeout(() => {
      if (this.searchInput) {
        this.searchInput.nativeElement.focus();
      }
    });
  }

  closeSearch(event: MouseEvent): void {
    // Prevent closing when clicking inside the search card
    if ((event.target as HTMLElement).closest('.search-card')) {
      return;
    }
    this.isSearchOpen = false;
    this.searchQuery = '';
    this.searchResults = [];
  }

  onSearch(event: KeyboardEvent): void {
    // Handle escape key
    if (event.key === 'Escape') {
      this.closeSearch(event as unknown as MouseEvent);
      return;
    }

    // Perform search
    if (this.searchQuery.length >= 2) {
      // Example search results - replace with actual search logic
      this.searchResults = [
        {
          id: '1',
          icon: 'dashboard',
          title: 'Dashboard',
          subtitle: 'Overview and analytics',
          link: '/dashboard',
        },
        {
          id: '2',
          icon: 'work',
          title: 'Jobs',
          subtitle: 'Manage and track jobs',
          link: '/jobs',
        },
        {
          id: '3',
          icon: 'business',
          title: 'Companies',
          subtitle: 'View all companies',
          link: '/companies',
        },
        {
          id: '4',
          icon: 'people',
          title: 'Drivers',
          subtitle: 'Driver management',
          link: '/drivers',
        },
        {
          id: '5',
          icon: 'receipt_long',
          title: 'Expenses',
          subtitle: 'Manage expenses',
          link: '/expenses',
        },
      ].filter(
        (result) =>
          result.title.toLowerCase().includes(this.searchQuery.toLowerCase()) ||
          result.subtitle.toLowerCase().includes(this.searchQuery.toLowerCase())
      );
    } else {
      this.searchResults = [];
    }
  }

  // Notification Methods
  get hasUnreadNotifications(): boolean {
    return this.unreadCount > 0;
  }

  getUnreadCount(): number {
    return this.unreadCount;
  }

  markAllAsRead(): void {
    this.notificationService.markAllAsRead();
  }

  markAsRead(notification: Notification): void {
    this.notificationService.markAsRead(notification.id);

    // Navigate to action URL if present
    if (notification.actionUrl) {
      this.router.navigateByUrl(notification.actionUrl);
    }
  }

  deleteNotification(notification: Notification): void {
    this.notificationService.removeNotification(notification.id);
  }

  viewAllNotifications(): void {
    this.router.navigate(['/notifications']);
  }

  // Theme Methods
  toggleTheme(): void {
    this.isDarkTheme = !this.isDarkTheme;
    document.body.classList.toggle('dark-theme');
    this.saveUserPreferences();
  }

  // User Preference Methods
  private loadUserPreferences(): void {
    const preferences = localStorage.getItem('userPreferences');
    if (preferences) {
      const { isDarkTheme } = JSON.parse(preferences);
      this.isDarkTheme = isDarkTheme;
      if (isDarkTheme) {
        document.body.classList.add('dark-theme');
      }
    }
  }

  private saveUserPreferences(): void {
    localStorage.setItem(
      'userPreferences',
      JSON.stringify({
        isDarkTheme: this.isDarkTheme,
      })
    );
  }

  // Navigation Methods
  viewProfile(): void {
    this.router.navigate(['/profile']);
  }

  openPreferences(): void {
    this.router.navigate(['/preferences']);
  }

  openAppSettings(): void {
    this.router.navigate(['/settings']);
  }

  openHelp(): void {
    window.open('/help', '_blank');
  }

  // Sidebar Toggle
  toggleSidebar(): void {
    this.menuToggled.emit();
  }

  // Logout Method
  logout(): void {
    this.authService.signOut().subscribe({
      next: () => {
        this.notificationService.addNotification({
          type: 'info',
          title: 'Signed Out',
          message: 'You have been successfully signed out',
        });
        this.router.navigate(['/auth/sign-in']);
      },
      error: (error) => {
        console.error('Logout error:', error);
        this.snackBar.open('Failed to sign out. Please try again.', 'Dismiss', {
          duration: 5000,
          panelClass: ['error-snackbar'],
        });
      },
    });
  }

  // Get notification icon based on type
  getNotificationIcon(type: string): string {
    switch (type) {
      case 'info':
        return 'info';
      case 'success':
        return 'check_circle';
      case 'warning':
        return 'warning';
      case 'error':
        return 'error';
      default:
        return 'notifications';
    }
  }

  // Format time for notifications
  getTimeAgo(date: Date): string {
    const now = new Date();
    const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);

    if (diffInSeconds < 60) {
      return 'Just now';
    }

    const diffInMinutes = Math.floor(diffInSeconds / 60);
    if (diffInMinutes < 60) {
      return `${diffInMinutes} minute${diffInMinutes !== 1 ? 's' : ''} ago`;
    }

    const diffInHours = Math.floor(diffInMinutes / 60);
    if (diffInHours < 24) {
      return `${diffInHours} hour${diffInHours !== 1 ? 's' : ''} ago`;
    }

    const diffInDays = Math.floor(diffInHours / 24);
    if (diffInDays < 30) {
      return `${diffInDays} day${diffInDays !== 1 ? 's' : ''} ago`;
    }

    const diffInMonths = Math.floor(diffInDays / 30);
    return `${diffInMonths} month${diffInMonths !== 1 ? 's' : ''} ago`;
  }
}


--- ./src/app/layout/topbar/topbar.component.html ---
<!-- top-nav.component.html -->
<nav class="top-nav">
  <!-- Left Section -->
  <div class="left-section">
    <!-- Mobile Menu Toggle -->
    <button mat-icon-button class="menu-button" (click)="toggleSidebar()">
      <mat-icon>menu</mat-icon>
    </button>

    <!-- Breadcrumb Navigation -->
    <div class="breadcrumb">
      <span>{{ getCurrentSection() }}</span>
      <mat-icon>chevron_right</mat-icon>
      <span>{{ getCurrentPage() }}</span>
    </div>
  </div>

  <!-- Right Section -->
  <div class="right-section">
    <!-- Search -->
    <button
      mat-icon-button
      class="action-button"
      matTooltip="Search"
      (click)="openSearch()"
    >
      <mat-icon>search</mat-icon>
    </button>

    <!-- Notifications -->
    <button
      mat-icon-button
      class="action-button"
      matTooltip="Notifications"
      [matMenuTriggerFor]="notificationsMenu"
    >
      <mat-icon>notifications</mat-icon>
      <span class="notification-badge" *ngIf="hasUnreadNotifications"></span>
    </button>

    <!-- Settings -->
    <button
      mat-icon-button
      class="action-button"
      matTooltip="Settings"
      [matMenuTriggerFor]="settingsMenu"
    >
      <mat-icon>settings</mat-icon>
    </button>

    <!-- User Profile -->
    <div class="user-profile" [matMenuTriggerFor]="userMenu">
      <div class="avatar-container">
        <div class="avatar">
          <mat-icon>account_circle</mat-icon>
        </div>
        <span class="status-indicator" [class.online]="isUserOnline"></span>
      </div>
      <div class="user-info">
        <span class="user-name">{{ userName }}</span>
        <span class="user-role">{{ userRole }}</span>
      </div>
      <mat-icon class="dropdown-icon">arrow_drop_down</mat-icon>
    </div>
  </div>
</nav>

<!-- Search Overlay -->
<div class="search-overlay" *ngIf="isSearchOpen" (click)="closeSearch($event)">
  <div class="search-card" (click)="$event.stopPropagation()">
    <div class="search-header">
      <mat-icon>search</mat-icon>
      <input
        #searchInput
        type="text"
        placeholder="Search..."
        [(ngModel)]="searchQuery"
        (keyup)="onSearch($event)"
        class="search-input"
        autofocus
      />
      <button mat-icon-button (click)="closeSearch($event)">
        <mat-icon>close</mat-icon>
      </button>
    </div>

    <div class="search-results" *ngIf="searchResults.length > 0">
      <div class="results-header">Results</div>
      <mat-nav-list>
        <a
          mat-list-item
          *ngFor="let result of searchResults"
          [routerLink]="result.link"
          (click)="closeSearch($event)"
        >
          <mat-icon matListItemIcon>{{ result.icon }}</mat-icon>
          <span matListItemTitle>{{ result.title }}</span>
          <span matListItemLine>{{ result.subtitle }}</span>
        </a>
      </mat-nav-list>
    </div>

    <div class="no-results" *ngIf="searchQuery && !searchResults.length">
      <mat-icon>search_off</mat-icon>
      <p>No results found for "{{ searchQuery }}"</p>
    </div>
  </div>
</div>

<!-- Notifications Menu -->
<mat-menu
  #notificationsMenu="matMenu"
  class="notifications-menu"
  xPosition="before"
>
  <div class="notifications-container">
    <!-- Header -->
    <div class="notification-header">
      <div class="header-title">
        <h3>Notifications</h3>
        <span class="notification-count" *ngIf="hasUnreadNotifications">
          {{ getUnreadCount() }} new
        </span>
      </div>
      <button
        mat-button
        class="mark-read-button"
        (click)="markAllAsRead()"
        [disabled]="!hasUnreadNotifications"
      >
        Mark all as read
      </button>
    </div>

    <!-- Content -->
    <div class="notification-content">
      <div class="notification-list" *ngIf="notifications.length > 0">
        <div
          class="notification-item"
          *ngFor="let notification of notifications"
          [class.unread]="!notification.read"
          (click)="markAsRead(notification)"
        >
          <div class="notification-icon" [ngClass]="notification.type">
            <mat-icon>{{ getNotificationIcon(notification.type) }}</mat-icon>
          </div>
          <div class="notification-details">
            <div class="notification-title">{{ notification.title }}</div>
            <div class="notification-message" *ngIf="notification.message">
              {{ notification.message }}
            </div>
            <div class="notification-time">
              {{ getTimeAgo(notification.timestamp) }}
            </div>
          </div>
          <button
            mat-icon-button
            class="delete-button"
            (click)="deleteNotification(notification); $event.stopPropagation()"
          >
            <mat-icon>close</mat-icon>
          </button>
        </div>
      </div>

      <!-- Empty State -->
      <div class="empty-notifications" *ngIf="notifications.length === 0">
        <mat-icon>notifications_none</mat-icon>
        <p>No notifications</p>
      </div>
    </div>

    <!-- Footer -->
    <div class="notification-footer">
      <button
        mat-button
        class="view-all-button"
        (click)="viewAllNotifications()"
      >
        View All Notifications
      </button>
    </div>
  </div>
</mat-menu>

<!-- Settings Menu -->
<mat-menu #settingsMenu="matMenu" class="settings-menu" xPosition="before">
  <div class="settings-container">
    <button mat-menu-item (click)="openAppSettings()">
      <mat-icon>tune</mat-icon>
      <span>App Settings</span>
    </button>
    <button mat-menu-item (click)="toggleTheme()">
      <mat-icon>{{ isDarkTheme ? "light_mode" : "dark_mode" }}</mat-icon>
      <span>{{ isDarkTheme ? "Light Theme" : "Dark Theme" }}</span>
    </button>
    <mat-divider></mat-divider>
    <button mat-menu-item (click)="openHelp()">
      <mat-icon>help_outline</mat-icon>
      <span>Help & Support</span>
    </button>
  </div>
</mat-menu>

<!-- User Menu -->
<mat-menu #userMenu="matMenu" class="user-menu" xPosition="before">
  <div class="user-menu-container">
    <div class="user-menu-header">
      <div class="menu-avatar">
        <mat-icon>account_circle</mat-icon>
      </div>
      <div class="menu-user-info">
        <span class="menu-user-name">{{ userName }}</span>
        <span class="menu-user-email">{{ userEmail }}</span>
      </div>
    </div>

    <mat-divider></mat-divider>

    <!-- User Actions -->
    <button mat-menu-item (click)="viewProfile()">
      <mat-icon>person_outline</mat-icon>
      <span>My Profile</span>
    </button>
    <button mat-menu-item (click)="openPreferences()">
      <mat-icon>settings</mat-icon>
      <span>Preferences</span>
    </button>

    <mat-divider></mat-divider>

    <!-- Logout -->
    <button mat-menu-item (click)="logout()" class="logout-button">
      <mat-icon>exit_to_app</mat-icon>
      <span>Sign Out</span>
    </button>
  </div>
</mat-menu>


--- ./src/app/layout/topbar/topbar.component.scss ---
/* topbar.component.scss - simplified version */

.top-nav {
  height: 64px;
  background-color: white;
  border-bottom: 1px solid rgba(0, 0, 0, 0.08);
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 24px;
  position: fixed;
  top: 0;
  right: 0;
  left: 250px;
  z-index: 999;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

/* Left Section */
.left-section {
  display: flex;
  align-items: center;
  gap: 16px;
}

.menu-button {
  display: none;
  color: var(--primary-color);
}

.menu-button:hover {
  background-color: var(--hover-color);
}

.menu-button mat-icon {
  font-size: 24px;
}

.breadcrumb {
  display: flex;
  align-items: center;
  gap: 8px;
  color: var(--text-secondary);
  font-size: 14px;
  font-weight: 500;
}

.breadcrumb mat-icon {
  color: var(--text-secondary);
  font-size: 18px;
}

.breadcrumb span:first-child {
  color: var(--text-primary);
}

.breadcrumb span:last-child {
  color: var(--secondary-color);
}

/* Right Section */
.right-section {
  display: flex;
  align-items: center;
  gap: 8px;
}

.action-button {
  color: var(--text-secondary);
  border-radius: 50%;
  width: 40px;
  height: 40px;
}

.action-button:hover {
  background-color: var(--hover-color);
  color: var(--primary-color);
}

.action-button mat-icon {
  font-size: 22px;
}

.notification-badge {
  position: absolute;
  top: 8px;
  right: 8px;
  height: 8px;
  width: 8px;
  border-radius: 50%;
  background-color: var(--error-color);
  border: 2px solid white;
}

/* User Profile */
.user-profile {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 4px 8px 4px 4px;
  margin-left: 8px;
  border-radius: 24px;
  cursor: pointer;
}

.user-profile:hover {
  background-color: var(--hover-color);
}

.avatar-container {
  position: relative;
}

.avatar {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  background-color: #f3e7d0;
  display: flex;
  align-items: center;
  justify-content: center;
}

.avatar mat-icon {
  color: var(--primary-color);
  font-size: 20px;
  width: 20px;
  height: 20px;
}

.status-indicator {
  position: absolute;
  bottom: 0;
  right: 0;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  border: 2px solid white;
  background-color: #95a5a6;
}

.status-indicator.online {
  background-color: var(--success-color);
}

.user-info {
  display: flex;
  flex-direction: column;
  line-height: 1.2;
}

.user-name {
  font-size: 14px;
  color: var(--text-primary);
  font-weight: 500;
}

.user-role {
  font-size: 12px;
  color: var(--text-secondary);
}

.dropdown-icon {
  color: var(--text-secondary);
}

.user-profile:hover .dropdown-icon {
  transform: rotate(180deg);
  transition: transform 0.2s ease;
}

/* Search Overlay */
.search-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: flex-start;
  padding-top: 100px;
  z-index: 2000;
}

.search-card {
  width: 600px;
  background: white;
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
}

.search-header {
  display: flex;
  align-items: center;
  padding: 16px;
  gap: 12px;
  border-bottom: 1px solid rgba(0, 0, 0, 0.1);
}

.search-header mat-icon {
  color: var(--text-secondary);
}

.search-input {
  flex: 1;
  border: none;
  outline: none;
  font-size: 16px;
  color: var(--text-primary);
  background: transparent;
  padding: 8px 0;
  font-family: "UberMove", sans-serif;
}

.search-input::placeholder {
  color: var(--text-secondary);
}

.search-header button {
  color: var(--text-secondary);
  margin-right: -8px;
}

.search-header button:hover {
  color: var(--text-primary);
  background-color: var(--hover-color);
}

.search-results {
  max-height: 400px;
  overflow-y: auto;
}

.search-results::-webkit-scrollbar {
  width: 6px;
}

.search-results::-webkit-scrollbar-track {
  background: transparent;
}

.search-results::-webkit-scrollbar-thumb {
  background-color: rgba(0, 0, 0, 0.2);
  border-radius: 3px;
}

.search-results::-webkit-scrollbar-thumb:hover {
  background-color: rgba(0, 0, 0, 0.3);
}

.results-header {
  padding: 12px 16px 8px;
  font-size: 13px;
  font-weight: 500;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.no-results {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 32px 16px;
  color: var(--text-secondary);
}

.no-results mat-icon {
  font-size: 48px;
  width: 48px;
  height: 48px;
  margin-bottom: 16px;
}

.no-results p {
  margin: 0;
  font-size: 14px;
}

/* Responsive Styles */
@media (max-width: 1200px) {
  .user-profile .user-info {
    display: none;
  }
}

@media (max-width: 768px) {
  .top-nav {
    left: 60px;
    padding: 0 16px;
  }

  .left-section .menu-button {
    display: block;
  }

  .left-section .breadcrumb {
    display: none;
  }

  .right-section .action-button:not(:last-child) {
    display: none;
  }

  .search-overlay {
    padding: 60px 16px 0;
  }

  .search-card {
    width: 100%;
    max-width: 600px;
  }
}

@media (max-width: 480px) {
  .top-nav {
    padding: 0 12px;
  }

  .search-overlay {
    padding: 0;
  }

  .search-card {
    border-radius: 0;
    height: 100%;
  }

  .search-results {
    height: calc(100vh - 64px);
    max-height: none;
  }
}


--- ./src/app/layout/nav-sidebar/nav-sidebar.component.html ---
<!-- nav-sidebar.component.html -->
<nav class="sidebar">
  <div class="logo-container">
    <img src="assets/logo/logo.png" alt="Company Logo" class="logo" />
  </div>

  <ul class="nav-list">
    <li *ngFor="let item of visibleNavItems" [routerLink]="item.route" routerLinkActive="active" [routerLinkActiveOptions]="{ exact: true }" class="nav-item">
      <span class="material-icons nav-icon">{{ item.icon }}</span>
      <span class="nav-label">{{ item.label }}</span>
    </li>
  </ul>
</nav>


--- ./src/app/layout/nav-sidebar/nav-sidebar.component.scss ---
/* nav-sidebar.component.scss - simplified version */

.sidebar {
  width: 250px;
  height: 100vh;
  background-color: var(--primary-color);
  color: white;
  position: fixed;
  left: 0;
  top: 0;
  display: flex;
  flex-direction: column;
  box-shadow: 2px 0 5px rgba(0, 0, 0, 0.15);
  z-index: 1000;
}

.logo-container {
  padding: 24px 20px;
  text-align: center;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.logo {
  max-width: 120px;
  height: auto;
}

.nav-list {
  list-style: none;
  padding: 0;
  margin: 16px 0;
  flex: 1;
  overflow-y: auto;
}

.nav-list::-webkit-scrollbar {
  width: 4px;
}

.nav-list::-webkit-scrollbar-track {
  background: transparent;
}

.nav-list::-webkit-scrollbar-thumb {
  background-color: rgba(255, 255, 255, 0.3);
  border-radius: 2px;
}

.nav-item {
  display: flex;
  align-items: center;
  padding: 12px 20px;
  cursor: pointer;
  border-left: 4px solid transparent;
  color: rgba(255, 255, 255, 0.85);
}

.nav-item:hover {
  background-color: rgba(255, 255, 255, 0.1);
  color: white;
}

.nav-item.active {
  background-color: rgba(255, 255, 255, 0.15);
  border-left: 4px solid var(--secondary-color);
  color: white;
}

.nav-icon {
  margin-right: 16px;
  font-size: 20px;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.nav-label {
  font-size: 14px;
  font-weight: 500;
  letter-spacing: 0.1px;
}

/* Responsive Design */
@media (max-width: 768px) {
  .sidebar {
    width: 60px;
    overflow: hidden;
  }

  .logo-container {
    padding: 16px 10px;
  }

  .logo {
    max-width: 40px;
  }

  .nav-label {
    display: none;
  }

  .nav-item {
    padding: 16px 0;
    justify-content: center;
  }

  .nav-item.active {
    border-left: none;
    border-right: 4px solid var(--secondary-color);
  }

  .nav-icon {
    margin-right: 0;
  }
}


--- ./src/app/layout/nav-sidebar/nav-sidebar.component.ts ---
// nav-sidebar.component.ts
import { Component, OnInit } from '@angular/core';
import { AuthService } from '../../services/auth.service';

interface NavItem {
  label: string;
  icon: string;
  route: string;
  active: boolean;
  requiresAdmin?: boolean;
}

@Component({
  selector: 'app-nav-sidebar',
  templateUrl: './nav-sidebar.component.html',
  styleUrls: ['./nav-sidebar.component.scss'],
  standalone: false,
})
export class NavSidebarComponent implements OnInit {
  navItems: NavItem[] = [
    { label: 'Dashboard', icon: 'dashboard', route: '/', active: true },
    { label: 'Jobs', icon: 'work', route: '/jobs', active: false },
    { label: 'Drivers', icon: 'people', route: '/drivers', active: false },
    {
      label: 'Customers',
      icon: 'business',
      route: '/customers',
      active: false,
    },
    {
      label: 'Vehicles',
      icon: 'directions_car',
      route: '/vehicles',
      active: false,
    },
    {
      label: 'Invoices',
      icon: 'receipt_long',
      route: '/expenses',
      active: false,
    },
    {
      label: 'Settings',
      icon: 'settings',
      route: '/settings',
      active: false,
      requiresAdmin: true,
    },
  ];

  isAdmin = false;
  visibleNavItems: NavItem[] = [];

  constructor(private authService: AuthService) {}

  ngOnInit(): void {
    this.authService.isAdmin().subscribe((isAdmin) => {
      this.isAdmin = isAdmin;
      this.updateVisibleNavItems();
    });
  }

  private updateVisibleNavItems(): void {
    this.visibleNavItems = this.navItems.filter((item) => !item.requiresAdmin || (item.requiresAdmin && this.isAdmin));
  }
}


--- ./src/app/shared/models/vehicle-type.enum.ts ---
export enum VehicleType {
  CAR = 'Car',
  VAN = 'Van',
  BUS = 'Bus',
  LORRY = 'Lorry',
  MOTORBIKE = 'Motorbike',
  TRAILER = 'Trailer',
}


--- ./src/app/shared/models/expense.model.ts ---
export enum ExpenseStatus {
  PENDING = 'Pending',
  APPROVED = 'Approved',
  REJECTED = 'Rejected',
}

export interface Expense {
  id: string;
  jobId?: string;
  driverId: string;
  driverName: string;
  description: string;
  amount: number;
  date: Date;
  receiptUrl?: string;
  status: ExpenseStatus;
  approvedBy?: string;
  approvedDate?: Date;
  isChargeable: boolean;
  notes?: string;
}


--- ./src/app/shared/models/job-status.enum.ts ---
export enum JobStatus {
  LOADED = 'Loaded',
  ALLOCATED = 'Allocated',
  COLLECTED = 'Collected',
  DELIVERED = 'Delivered',
  ABORTED = 'Aborted',
  CANCELLED = 'Cancelled',
}


--- ./src/app/shared/pipes/time-ago.pipe.ts ---
// time-ago.pipe.ts
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'timeAgo',
  pure: false, // Make the pipe impure so it updates automatically
  standalone: false,
})
export class TimeAgoPipe implements PipeTransform {
  transform(value: Date | string): string {
    if (!value) return '';

    const date = value instanceof Date ? value : new Date(value);
    const now = new Date();
    const seconds = Math.floor((now.getTime() - date.getTime()) / 1000);

    // Time intervals in seconds
    const intervals = {
      year: 31536000,
      month: 2592000,
      week: 604800,
      day: 86400,
      hour: 3600,
      minute: 60,
      second: 1,
    };

    let counter: number;
    for (const [unit, secondsInUnit] of Object.entries(intervals)) {
      counter = Math.floor(seconds / secondsInUnit);

      if (counter > 0) {
        if (counter === 1) {
          return `1 ${unit} ago`; // Singular
        } else {
          return `${counter} ${unit}s ago`; // Plural
        }
      }
    }

    return 'Just now';
  }
}


--- ./src/app/dialogs/job-duplicate-dialog.component.ts ---
// src/app/dialogs/job-duplicate-dialog.component.ts
import { Component, Inject } from '@angular/core';
import { MAT_DIALOG_DATA, MatDialogRef } from '@angular/material/dialog';

export interface JobDuplicateDialogData {
  jobId: string;
  jobTitle?: string;
}

@Component({
  selector: 'app-job-duplicate-dialog',
  template: `
    <div class="job-duplicate-dialog">
      <div class="dialog-header duplicate">
        <mat-icon>content_copy</mat-icon>
        <h2 mat-dialog-title>Duplicate Job</h2>
      </div>

      <mat-dialog-content class="dialog-content">
        <p>Are you sure you want to duplicate this job?</p>
        <p class="job-info" *ngIf="data.jobTitle"><strong>Job:</strong> {{ data.jobTitle }}</p>
        <p class="warning-text">
          <mat-icon>info</mat-icon>
          This will create a new job with the same details but with 'unallocated' status.
        </p>
      </mat-dialog-content>

      <mat-dialog-actions align="end" class="dialog-actions">
        <button mat-button class="cancel-button" (click)="onCancel()">Cancel</button>
        <button mat-flat-button color="primary" class="confirm-button" (click)="onConfirm()">
          <mat-icon>content_copy</mat-icon>
          Duplicate Job
        </button>
      </mat-dialog-actions>
    </div>
  `,
  styles: [
    `
      .job-duplicate-dialog {
        .dialog-header {
          display: flex;
          align-items: center;
          gap: 12px;
          padding: 16px 24px 0;
          margin-bottom: 8px;

          &.duplicate {
            color: #1976d2;
          }

          mat-icon {
            font-size: 28px;
            height: 28px;
            width: 28px;
          }

          h2 {
            margin: 0;
            font-size: 20px;
            font-weight: 500;
          }
        }

        .dialog-content {
          padding: 0 24px;
          margin: 0;
          min-width: 350px;

          p {
            margin: 12px 0;
            color: rgba(0, 0, 0, 0.87);
          }

          .job-info {
            background-color: #f5f5f5;
            padding: 12px;
            border-radius: 4px;
            border-left: 4px solid #1976d2;
          }

          .warning-text {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            color: rgba(0, 0, 0, 0.6);
            font-size: 14px;

            mat-icon {
              font-size: 18px;
              height: 18px;
              width: 18px;
              color: #ff9800;
            }
          }
        }

        .dialog-actions {
          padding: 16px 24px 24px;
          margin: 0;
          gap: 8px;

          .cancel-button {
            color: rgba(0, 0, 0, 0.6);
          }

          .confirm-button {
            mat-icon {
              font-size: 18px;
              height: 18px;
              width: 18px;
              margin-right: 8px;
            }
          }
        }
      }
    `,
  ],
  standalone: false,
})
export class JobDuplicateDialogComponent {
  constructor(public dialogRef: MatDialogRef<JobDuplicateDialogComponent>, @Inject(MAT_DIALOG_DATA) public data: JobDuplicateDialogData) {}

  onCancel(): void {
    this.dialogRef.close(false);
  }

  onConfirm(): void {
    this.dialogRef.close(true);
  }
}


--- ./src/app/dialogs/driver-selection-dialog.component.ts ---
import { Component, Inject, OnInit } from '@angular/core';
import { MAT_DIALOG_DATA, MatDialogRef } from '@angular/material/dialog';
import { UserProfile } from '../interfaces/user-profile.interface';
import { AuthService } from '../services/auth.service';

export interface DriverSelectionDialogData {
  jobId: string;
  jobTitle?: string;
}

@Component({
  selector: 'app-driver-selection-dialog',
  template: `
    <div class="driver-selection-dialog">
      <div class="dialog-header allocation">
        <mat-icon>assignment_ind</mat-icon>
        <h2 mat-dialog-title>Select Driver</h2>
      </div>

      <mat-dialog-content class="dialog-content">
        <div *ngIf="loading" class="loading-container">
          <mat-spinner diameter="40"></mat-spinner>
          <span>Loading drivers...</span>
        </div>

        <div *ngIf="!loading && drivers.length === 0" class="empty-state">
          <mat-icon>person_off</mat-icon>
          <p>No drivers available</p>
        </div>

        <ul class="driver-list" *ngIf="!loading && drivers.length > 0">
          <li
            *ngFor="let driver of drivers"
            class="driver-item"
            (click)="selectDriver(driver)"
          >
            <div class="driver-avatar">
              {{ getInitials(driver) }}
            </div>
            <div class="driver-info">
              <div class="driver-name">{{ driver.name }}</div>
              <div class="driver-details">{{ driver.role || 'Driver' }}</div>
            </div>
            <div class="driver-actions">
              <mat-icon>chevron_right</mat-icon>
            </div>
          </li>
        </ul>
      </mat-dialog-content>

      <mat-dialog-actions align="end" class="dialog-actions">
        <button mat-button class="cancel-button" (click)="onCancel()">
          Cancel
        </button>
      </mat-dialog-actions>
    </div>
  `,
  styles: [
    `
      .dialog-header {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 16px 24px 0;
        margin-bottom: 8px;
      }

      .dialog-header.allocation {
        color: #0288d1;
      }

      .dialog-header mat-icon {
        font-size: 28px;
        height: 28px;
        width: 28px;
      }

      .dialog-header h2 {
        margin: 0;
        font-size: 20px;
        font-weight: 500;
      }

      .dialog-content {
        padding: 0 24px;
        margin: 0;
        max-height: 350px;
        overflow-y: auto;
      }

      .dialog-actions {
        padding: 16px 24px 24px;
        margin: 0;
      }

      .loading-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 32px 0;
        gap: 16px;
      }

      .loading-container span {
        color: rgba(0, 0, 0, 0.6);
        font-size: 14px;
      }

      .empty-state {
        text-align: center;
        padding: 32px 0;
      }

      .empty-state mat-icon {
        font-size: 48px;
        width: 48px;
        height: 48px;
        margin-bottom: 16px;
        color: #9e9e9e;
      }

      .empty-state p {
        color: #757575;
        margin: 0;
      }
    `,
  ],
  standalone: false,
})
export class DriverSelectionDialogComponent implements OnInit {
  drivers: UserProfile[] = [];
  loading = true;

  constructor(
    public dialogRef: MatDialogRef<DriverSelectionDialogComponent>,
    @Inject(MAT_DIALOG_DATA) public data: DriverSelectionDialogData,
    private authService: AuthService
  ) {}

  ngOnInit(): void {
    this.loadDrivers();
  }

  private loadDrivers(): void {
    this.loading = true;
    this.authService.getUsersByRole('driver').subscribe({
      next: (drivers) => {
        this.drivers = drivers.filter((driver) => driver.isActive);
        this.loading = false;
      },
      error: (error) => {
        console.error('Error loading drivers:', error);
        this.loading = false;
      },
    });
  }

  getInitials(driver: UserProfile): string {
    if (!driver.name) return '?';

    const nameParts = driver.name.split(' ');
    if (nameParts.length === 1) {
      return nameParts[0].charAt(0).toUpperCase();
    }

    return (
      nameParts[0].charAt(0) + nameParts[nameParts.length - 1].charAt(0)
    ).toUpperCase();
  }

  selectDriver(driver: UserProfile): void {
    this.dialogRef.close(driver);
  }

  onCancel(): void {
    this.dialogRef.close(null);
  }
}


--- ./src/app/dialogs/confirmation-dialog.component.ts ---
import { Component, Inject } from '@angular/core';
import { MAT_DIALOG_DATA, MatDialogRef } from '@angular/material/dialog';

export interface ConfirmationDialogData {
  title: string;
  message: string;
  confirmText: string;
  cancelText: string;
  icon?: string; // Optional icon name for the dialog
  confirmColor?: 'primary' | 'accent' | 'warn' | ''; // Optional color for the confirm button
}

@Component({
  selector: 'app-confirmation-dialog',
  template: `
    <div class="confirmation-dialog">
      <div class="dialog-header" [ngClass]="getHeaderClass()">
        <mat-icon *ngIf="data.icon">{{ data.icon }}</mat-icon>
        <h2 mat-dialog-title>{{ data.title }}</h2>
      </div>

      <mat-dialog-content class="dialog-content">
        {{ data.message }}
      </mat-dialog-content>

      <mat-dialog-actions align="end" class="dialog-actions">
        <button mat-button class="cancel-button" (click)="onCancel()">
          {{ data.cancelText || 'Cancel' }}
        </button>
        <button
          mat-flat-button
          [color]="data.confirmColor || 'primary'"
          class="confirm-button"
          (click)="onConfirm()"
        >
          {{ data.confirmText || 'Confirm' }}
        </button>
      </mat-dialog-actions>
    </div>
  `,
  styles: [
    `
      .confirmation-dialog {
        min-width: 320px;
      }

      .dialog-header {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 16px 24px 0;
        margin-bottom: 8px;
      }

      .dialog-header.collection {
        color: #ff9800;
      }

      .dialog-header.delivery {
        color: #4caf50;
      }

      .dialog-header.warning {
        color: #f44336;
      }

      .dialog-header mat-icon {
        font-size: 28px;
        height: 28px;
        width: 28px;
      }

      .dialog-header h2 {
        margin: 0;
        font-size: 20px;
        font-weight: 500;
      }

      .dialog-content {
        padding: 0 24px;
        margin: 0;
        color: rgba(0, 0, 0, 0.7);
        font-size: 16px;
        line-height: 1.5;
        max-width: 500px;
      }

      .dialog-actions {
        padding: 16px 24px 24px;
        margin: 0;
        gap: 8px;
      }

      .cancel-button {
        font-weight: 400;
      }

      .confirm-button {
        font-weight: 500;
      }

      @media (max-width: 599px) {
        .dialog-actions {
          flex-direction: column-reverse;
        }

        .dialog-actions button {
          width: 100%;
        }
      }
    `,
  ],
  standalone: false,
})
export class ConfirmationDialogComponent {
  constructor(
    public dialogRef: MatDialogRef<ConfirmationDialogComponent>,
    @Inject(MAT_DIALOG_DATA) public data: ConfirmationDialogData
  ) {}

  getHeaderClass(): string {
    if (this.data.title.toLowerCase().includes('collection')) {
      return 'collection';
    } else if (this.data.title.toLowerCase().includes('delivery')) {
      return 'delivery';
    } else if (this.data.confirmColor === 'warn') {
      return 'warning';
    }
    return '';
  }

  onConfirm(): void {
    this.dialogRef.close(true);
  }

  onCancel(): void {
    this.dialogRef.close(false);
  }
}


--- ./src/app/pages/customers/customer-create/customer-create.component.html ---
<!-- customer-create.component.html -->
<mat-card class="mat-elevation-z3">
  <!-- Loading Spinner -->
  <div class="loading-overlay" *ngIf="isLoading">
    <mat-spinner diameter="40"></mat-spinner>
    <span>Loading...</span>
  </div>

  <!-- Header -->
  <div class="header-wrapper">
    <div class="header-title">
      <button mat-icon-button (click)="goBack()" matTooltip="Go back">
        <mat-icon>arrow_back</mat-icon>
      </button>
      <h1>{{ isEditMode ? 'Edit Customer' : 'New Customer' }}</h1>
    </div>
  </div>

  <!-- Form -->
  <form [formGroup]="customerForm" (ngSubmit)="onSubmit()" class="form-container">
    <div class="form-section">
      <h2 class="section-title">Customer Information</h2>

      <!-- Customer Name -->
      <mat-form-field appearance="outline" class="full-width">
        <mat-label>Customer Name</mat-label>
        <input matInput formControlName="name" placeholder="Enter customer name" />
        <mat-error *ngIf="customerForm.get('name')?.hasError('required')"> Customer name is required </mat-error>
      </mat-form-field>

      <div class="form-row">
        <!-- Industry -->
        <mat-form-field appearance="outline">
          <mat-label>Industry</mat-label>
          <mat-select formControlName="industry">
            <mat-option *ngFor="let industry of industries" [value]="industry">
              {{ industry }}
            </mat-option>
          </mat-select>
          <mat-error *ngIf="customerForm.get('industry')?.hasError('required')"> Industry is required </mat-error>
        </mat-form-field>

        <!-- Customer Size -->
        <mat-form-field appearance="outline">
          <mat-label>Customer Size</mat-label>
          <mat-select formControlName="size">
            <mat-option *ngFor="let size of customerSizes" [value]="size">
              {{ size }}
            </mat-option>
          </mat-select>
          <mat-error *ngIf="customerForm.get('size')?.hasError('required')"> Customer size is required </mat-error>
        </mat-form-field>

        <!-- Status -->
        <mat-form-field appearance="outline">
          <mat-label>Status</mat-label>
          <mat-select formControlName="status">
            <mat-option *ngFor="let status of customerStatuses" [value]="status">
              {{ status }}
            </mat-option>
          </mat-select>
          <mat-error *ngIf="customerForm.get('status')?.hasError('required')"> Status is required </mat-error>
        </mat-form-field>
      </div>

      <!-- Website -->
      <mat-form-field appearance="outline" class="full-width">
        <mat-label>Website</mat-label>
        <input matInput formControlName="website" placeholder="e.g. https://www.example.com" />
        <mat-icon matSuffix>language</mat-icon>
      </mat-form-field>

      <!-- Description -->
      <mat-form-field appearance="outline" class="full-width">
        <mat-label>Description</mat-label>
        <textarea matInput formControlName="description" placeholder="Brief description of the customer" rows="3"></textarea>
      </mat-form-field>
    </div>

    <div class="form-section">
      <h2 class="section-title">Address Information</h2>

      <!-- Address -->
      <mat-form-field appearance="outline" class="full-width">
        <mat-label>Address</mat-label>
        <textarea matInput formControlName="address" placeholder="Enter customer address" rows="3"></textarea>
        <mat-error *ngIf="customerForm.get('address')?.hasError('required')"> Address is required </mat-error>
      </mat-form-field>

      <div class="form-row">
        <!-- City -->
        <mat-form-field appearance="outline">
          <mat-label>City</mat-label>
          <input matInput formControlName="city" placeholder="Enter city" />
        </mat-form-field>

        <!-- Postcode -->
        <mat-form-field appearance="outline">
          <mat-label>Postcode</mat-label>
          <input matInput formControlName="postcode" placeholder="Enter postcode" />
        </mat-form-field>

        <!-- Country -->
        <mat-form-field appearance="outline">
          <mat-label>Country</mat-label>
          <input matInput formControlName="country" placeholder="Enter country" />
        </mat-form-field>
      </div>
    </div>

    <div class="form-section">
      <div class="section-header">
        <h2 class="section-title">Contact Information</h2>
        <button type="button" mat-stroked-button color="primary" (click)="addContact()" class="add-contact-btn">
          <mat-icon>add</mat-icon>
          Add Contact
        </button>
      </div>

      <div class="contacts-container" formArrayName="contacts">
        <div *ngFor="let contact of contactsFormArray.controls; let i = index" class="contact-item" [formGroupName]="i">
          <div class="contact-header">
            <h3>Contact #{{ i + 1 }}</h3>
            <div class="contact-actions">
              <mat-checkbox
                class="primary-checkbox"
                formControlName="isPrimary"
                [checked]="contact.get('isPrimary')?.value"
                (change)="setPrimaryContact(i)"
                [disabled]="contact.get('isPrimary')?.value">
                Primary
              </mat-checkbox>
              <button type="button" mat-icon-button color="warn" (click)="removeContact(i)" [disabled]="contactsFormArray.length === 1" class="remove-btn">
                <mat-icon>delete</mat-icon>
              </button>
            </div>
          </div>

          <div class="form-row">
            <!-- Contact Name -->
            <mat-form-field appearance="outline">
              <mat-label>Name</mat-label>
              <input matInput formControlName="name" placeholder="Full name" />
              <mat-error *ngIf="contact.get('name')?.hasError('required')"> Name is required </mat-error>
            </mat-form-field>

            <!-- Position -->
            <mat-form-field appearance="outline">
              <mat-label>Position</mat-label>
              <input matInput formControlName="position" placeholder="e.g. Manager" />
            </mat-form-field>
          </div>

          <div class="form-row">
            <!-- Email -->
            <mat-form-field appearance="outline">
              <mat-label>Email</mat-label>
              <input matInput formControlName="email" placeholder="Email address" type="email" />
              <mat-error *ngIf="contact.get('email')?.hasError('required')"> Email is required </mat-error>
              <mat-error *ngIf="contact.get('email')?.hasError('email')"> Please enter a valid email address </mat-error>
            </mat-form-field>

            <!-- Phone -->
            <mat-form-field appearance="outline">
              <mat-label>Phone</mat-label>
              <input matInput formControlName="phone" placeholder="Phone number" type="tel" />
            </mat-form-field>
          </div>
        </div>
      </div>
    </div>

    <div class="form-section">
      <h2 class="section-title">Additional Information</h2>

      <!-- Notes -->
      <mat-form-field appearance="outline" class="full-width">
        <mat-label>Notes</mat-label>
        <textarea matInput formControlName="notes" placeholder="Additional notes about the customer" rows="4"></textarea>
      </mat-form-field>
    </div>

    <!-- Form Actions -->
    <div class="form-actions">
      <button mat-stroked-button type="button" (click)="goBack()">Cancel</button>
      <button mat-flat-button color="primary" type="submit" [disabled]="customerForm.invalid || isSubmitting">
        {{ isSubmitting ? 'Saving...' : isEditMode ? 'Update Customer' : 'Create Customer' }}
      </button>
    </div>
  </form>
</mat-card>


--- ./src/app/pages/customers/customer-create/customer-create.component.scss ---
/* customer-create.component.scss */

:host {
  display: block;
  padding: 24px;
  background-color: var(--background-color);
  min-height: 100vh;
  margin-left: 250px; /* Account for sidebar width */
  padding-top: 88px; /* Account for topbar height (64px) + some padding */
}

/* Card styles */
.mat-mdc-card {
  margin-bottom: 24px;
  background-color: white;
  border-radius: 8px;
}

/* Loading Overlay */
.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.9);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  gap: 16px;
}

.loading-overlay span {
  color: var(--text-secondary);
  font-size: 14px;
}

/* Header */
.header-wrapper {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 24px;
  border-bottom: 1px solid var(--border-color);
}

.header-title {
  display: flex;
  align-items: center;
  gap: 16px;
}

.header-title h1 {
  margin: 0;
  font-size: 24px;
  font-weight: 500;
  color: var(--primary-color);
}

/* Form Container */
.form-container {
  padding: 24px;
}

/* Form Sections */
.form-section {
  margin-bottom: 32px;
  padding-bottom: 16px;
  border-bottom: 1px solid var(--border-color);
}

.form-section:last-child {
  border-bottom: none;
  margin-bottom: 0;
}

.section-title {
  margin: 0 0 24px 0;
  font-size: 18px;
  font-weight: 500;
  color: var(--primary-color);
}

.section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
}

.add-contact-btn {
  height: 36px;
}

.add-contact-btn .mat-icon {
  font-size: 18px;
  margin-right: 8px;
}

/* Form Fields */
.form-row {
  display: flex;
  gap: 16px;
  flex-wrap: wrap;
}

.form-row mat-form-field {
  flex: 1;
  min-width: 200px;
}

.full-width {
  width: 100%;
}

/* Contacts Container */
.contacts-container {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

.contact-item {
  padding: 16px;
  border: 1px solid var(--border-color);
  border-radius: 8px;
  background-color: #fafafa;
  position: relative;
}

.contact-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}

.contact-header h3 {
  margin: 0;
  font-size: 16px;
  font-weight: 500;
  color: var(--primary-color);
}

.contact-actions {
  display: flex;
  align-items: center;
  gap: 8px;
}

.primary-checkbox {
  margin-right: 8px;
}

.primary-checkbox ::ng-deep .mdc-form-field {
  font-size: 14px;
}

.remove-btn {
  color: var(--error-color);
}

/* Form Actions */
.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: 16px;
  margin-top: 24px;
}

.form-actions button {
  min-width: 120px;
}

/* Responsive Design */
@media screen and (max-width: 1200px) {
  .form-row {
    gap: 12px;
  }
}

@media screen and (max-width: 960px) {
  :host {
    padding: 16px;
  }

  .header-wrapper {
    padding: 16px;
  }

  .form-container {
    padding: 16px;
  }
}

@media screen and (max-width: 768px) {
  :host {
    margin-left: 60px; /* Collapsed sidebar width */
    padding-top: 80px; /* Reduced topbar padding for smaller screens */
  }

  .header-title h1 {
    font-size: 20px;
  }

  .section-title {
    font-size: 16px;
  }

  .form-row {
    flex-direction: column;
    gap: 0;
  }

  .form-actions {
    flex-direction: column-reverse;
    gap: 8px;
  }

  .form-actions button {
    width: 100%;
  }
}

@media screen and (max-width: 600px) {
  :host {
    padding: 8px;
  }

  .header-wrapper {
    flex-direction: column;
    align-items: flex-start;
    gap: 16px;
  }

  .section-header {
    flex-direction: column;
    align-items: flex-start;
    gap: 12px;
  }

  .add-contact-btn {
    width: 100%;
  }
}

/* Print Styles */
@media print {
  :host {
    padding: 0;
    background: white;
    margin-left: 0; /* No sidebar in print */
    padding-top: 0; /* No topbar in print */
  }

  .mat-mdc-card {
    box-shadow: none !important;
  }

  .form-actions {
    display: none;
  }

  .contact-actions {
    display: none;
  }
}


--- ./src/app/pages/customers/customer-create/customer-create.component.ts ---
import { Component, OnInit, OnDestroy } from '@angular/core';
import { FormBuilder, FormGroup, FormArray, Validators } from '@angular/forms';
import { ActivatedRoute, Router } from '@angular/router';
import { Subscription } from 'rxjs';
import { CustomerService } from '../../../services/customer.service';
import { NotificationService } from '../../../services/notification.service';
import { Location } from '@angular/common';
import { MatSnackBar } from '@angular/material/snack-bar';
import { MatDialog } from '@angular/material/dialog';
import { ConfirmationDialogComponent } from '../../../dialogs/confirmation-dialog.component';
import { Customer, CustomerSize, CustomerStatus, CustomerContact } from '../../../interfaces/customer.interface';

@Component({
  selector: 'app-customer-create',
  templateUrl: './customer-create.component.html',
  styleUrls: ['./customer-create.component.scss'],
  standalone: false,
})
export class CustomerCreateComponent implements OnInit, OnDestroy {
  customerForm!: FormGroup;
  customerId: string | null = null;
  isEditMode = false;
  isSubmitting = false;
  isLoading = false;
  hasChanges = false;

  // Reference data
  industries = [
    'Technology',
    'Manufacturing',
    'Healthcare',
    'Finance',
    'Retail',
    'Education',
    'Construction',
    'Transportation',
    'Energy',
    'Telecommunications',
    'Agriculture',
    'Entertainment',
    'Hospitality',
    'Media',
    'Professional Services',
    'Real Estate',
    'Other',
  ];

  customerSizes = [CustomerSize.SMALL, CustomerSize.MEDIUM, CustomerSize.LARGE, CustomerSize.ENTERPRISE];

  customerStatuses = [CustomerStatus.ACTIVE, CustomerStatus.INACTIVE, CustomerStatus.PENDING];

  private subscriptions: Subscription[] = [];

  constructor(
    private fb: FormBuilder,
    private customerService: CustomerService,
    private notificationService: NotificationService,
    private route: ActivatedRoute,
    private router: Router,
    private location: Location,
    private snackBar: MatSnackBar,
    private dialog: MatDialog
  ) {
    this.createForm();
  }

  ngOnInit(): void {
    this.customerId = this.route.snapshot.paramMap.get('id');
    this.isEditMode = !!this.customerId;

    if (this.isEditMode && this.customerId) {
      this.loadCustomerData(this.customerId);
    }

    // Track form changes
    const formChangeSub = this.customerForm.valueChanges.subscribe(() => {
      this.hasChanges = true;
    });
    this.subscriptions.push(formChangeSub);
  }

  ngOnDestroy(): void {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }

  /**
   * Create reactive form
   */
  private createForm(): void {
    this.customerForm = this.fb.group({
      name: ['', [Validators.required]],
      industry: ['', [Validators.required]],
      size: [CustomerSize.SMALL, [Validators.required]],
      status: [CustomerStatus.ACTIVE, [Validators.required]],
      address: ['', [Validators.required]],
      city: [''],
      postcode: [''],
      country: [''],
      website: [''],
      description: [''],
      contacts: this.fb.array([this.createContactFormGroup(true)]),
      notes: [''],
    });
  }

  /**
   * Create contact form group
   */
  private createContactFormGroup(isPrimary: boolean = false): FormGroup {
    return this.fb.group({
      id: [''],
      name: ['', [Validators.required]],
      position: [''],
      email: ['', [Validators.required, Validators.email]],
      phone: [''],
      isPrimary: [isPrimary],
    });
  }

  /**
   * Load customer data when in edit mode
   */
  private loadCustomerData(customerId: string): void {
    this.isLoading = true;

    // Retrieve customer from Firestore using the service
    const customerSub = this.customerService.getCustomerById(customerId).subscribe({
      next: (customer) => {
        if (customer) {
          this.populateForm(customer);
        } else {
          this.notificationService.addNotification({
            type: 'error',
            title: 'Error',
            message: 'Customer not found',
          });
          this.router.navigate(['/customers']);
        }
        this.isLoading = false;
      },
      error: (error) => {
        console.error('Error loading customer:', error);
        this.notificationService.addNotification({
          type: 'error',
          title: 'Error',
          message: 'Failed to load customer data',
        });
        this.isLoading = false;
        this.router.navigate(['/customers']);
      },
    });

    this.subscriptions.push(customerSub);

    // Also subscribe to the loading state from the service
    const loadingSub = this.customerService.loading$.subscribe((isLoading) => {
      this.isLoading = isLoading;
    });

    this.subscriptions.push(loadingSub);
  }

  /**
   * Populate form with customer data
   */
  private populateForm(customer: Customer): void {
    // Clear existing contacts form array
    while (this.contactsFormArray.length) {
      this.contactsFormArray.removeAt(0);
    }

    // Add customer contacts
    if (customer.contacts && customer.contacts.length > 0) {
      customer.contacts.forEach((contact) => {
        this.contactsFormArray.push(
          this.fb.group({
            id: [contact.id],
            name: [contact.name, [Validators.required]],
            position: [contact.position || ''],
            email: [contact.email, [Validators.required, Validators.email]],
            phone: [contact.phone || ''],
            isPrimary: [contact.isPrimary],
          })
        );
      });
    } else {
      // Add at least one contact form
      this.contactsFormArray.push(this.createContactFormGroup(true));
    }

    // Update form values
    this.customerForm.patchValue({
      name: customer.name,
      industry: customer.industry,
      size: customer.size,
      status: customer.status,
      address: customer.address,
      city: customer.city || '',
      postcode: customer.postcode || '',
      country: customer.country || '',
      website: customer.website || '',
      description: customer.description || '',
      notes: customer.notes || '',
    });

    // Reset changes tracking
    this.hasChanges = false;
  }

  /**
   * Get contacts form array
   */
  get contactsFormArray(): FormArray {
    return this.customerForm.get('contacts') as FormArray;
  }

  /**
   * Add a new contact form group
   */
  addContact(): void {
    this.contactsFormArray.push(this.createContactFormGroup());
  }

  /**
   * Remove a contact at specified index
   */
  removeContact(index: number): void {
    // Check if there's more than one contact
    if (this.contactsFormArray.length > 1) {
      // Check if the contact to be removed is primary
      const removedContact = this.contactsFormArray.at(index);
      const wasPrimary = removedContact.get('isPrimary')?.value;

      // Remove the contact
      this.contactsFormArray.removeAt(index);

      // If the removed contact was primary, make the first contact primary
      if (wasPrimary && this.contactsFormArray.length > 0) {
        this.contactsFormArray.at(0).get('isPrimary')?.setValue(true);
      }
    } else {
      this.snackBar.open('At least one contact is required.', 'Close', {
        duration: 3000,
      });
    }
  }

  /**
   * Set a contact as primary and update others
   */
  setPrimaryContact(index: number): void {
    // Update all contacts to non-primary
    for (let i = 0; i < this.contactsFormArray.length; i++) {
      this.contactsFormArray.at(i).get('isPrimary')?.setValue(false);
    }

    // Set selected contact as primary
    this.contactsFormArray.at(index).get('isPrimary')?.setValue(true);
  }

  /**
   * Get error message for form controls
   */
  getErrorMessage(controlName: string, formGroup?: FormGroup): string {
    const form = formGroup || this.customerForm;
    const control = form.get(controlName);

    if (!control || !control.errors || !control.touched) {
      return '';
    }

    if (control.errors['required']) {
      return 'This field is required';
    }

    if (control.errors['email']) {
      return 'Please enter a valid email address';
    }

    return 'Invalid value';
  }

  /**
   * Submit form
   */
  onSubmit(): void {
    if (this.customerForm.invalid) {
      this.markFormGroupTouched(this.customerForm);
      this.snackBar.open('Please correct the errors in the form.', 'Close', {
        duration: 3000,
        panelClass: ['error-snackbar'],
      });
      return;
    }

    // Check if at least one contact is marked as primary
    const hasPrimary = this.contactsFormArray.controls.some((contact) => contact.get('isPrimary')?.value);

    if (!hasPrimary && this.contactsFormArray.length > 0) {
      // If no primary contact, set the first one as primary
      this.contactsFormArray.at(0).get('isPrimary')?.setValue(true);
    }

    this.isSubmitting = true;

    const formData = this.prepareFormData();

    if (this.isEditMode && this.customerId) {
      // Update existing customer
      const updateSub = this.customerService.updateCustomer(this.customerId, formData).subscribe({
        next: () => {
          this.notificationService.addNotification({
            type: 'success',
            title: 'Customer Updated',
            message: `${formData.name} has been updated successfully`,
            actionUrl: `/customers/${this.customerId}`,
          });
          this.hasChanges = false;
          this.isSubmitting = false;
          this.router.navigate(['/customers', this.customerId]);
        },
        error: (error) => {
          console.error('Error updating customer:', error);
          this.notificationService.addNotification({
            type: 'error',
            title: 'Error',
            message: `Failed to update customer: ${error.message}`,
          });
          this.isSubmitting = false;
        },
      });

      this.subscriptions.push(updateSub);
    } else {
      // Create new customer
      const createSub = this.customerService.createCustomer(formData).subscribe({
        next: (id) => {
          this.notificationService.addNotification({
            type: 'success',
            title: 'Customer Created',
            message: `${formData.name} has been created successfully`,
            actionUrl: `/customers/${id}`,
          });
          this.hasChanges = false;
          this.isSubmitting = false;
          this.router.navigate(['/customers', id]);
        },
        error: (error) => {
          console.error('Error creating customer:', error);
          this.notificationService.addNotification({
            type: 'error',
            title: 'Error',
            message: `Failed to create customer: ${error.message}`,
          });
          this.isSubmitting = false;
        },
      });

      this.subscriptions.push(createSub);
    }
  }

  /**
   * Prepare form data for submission
   */
  private prepareFormData(): Partial<Customer> {
    const formValue = this.customerForm.getRawValue();

    // Process contacts to ensure they're valid
    const contacts: CustomerContact[] = formValue.contacts.map((contact: any) => ({
      id: contact.id || Date.now().toString(36) + Math.random().toString(36).substr(2),
      name: contact.name,
      position: contact.position || undefined,
      email: contact.email,
      phone: contact.phone || undefined,
      isPrimary: contact.isPrimary,
    }));

    return {
      name: formValue.name,
      industry: formValue.industry,
      size: formValue.size,
      status: formValue.status,
      address: formValue.address,
      city: formValue.city || undefined,
      postcode: formValue.postcode || undefined,
      country: formValue.country || undefined,
      website: formValue.website || undefined,
      description: formValue.description || undefined,
      contacts: contacts,
      notes: formValue.notes || undefined,
    };
  }

  /**
   * Navigate back
   */
  goBack(): void {
    if (this.hasChanges) {
      this.showUnsavedChangesDialog();
    } else {
      this.location.back();
    }
  }

  /**
   * Show dialog for unsaved changes
   */
  private showUnsavedChangesDialog(): void {
    const dialogRef = this.dialog.open(ConfirmationDialogComponent, {
      data: {
        title: 'Unsaved Changes',
        message: 'You have unsaved changes. Are you sure you want to leave?',
        confirmText: 'Leave',
        cancelText: 'Stay',
        confirmColor: 'warn',
      },
      width: '400px',
    });

    dialogRef.afterClosed().subscribe((result) => {
      if (result) {
        this.location.back();
      }
    });
  }

  /**
   * Mark all form controls as touched to trigger validation
   */
  private markFormGroupTouched(formGroup: FormGroup): void {
    Object.values(formGroup.controls).forEach((control) => {
      control.markAsTouched();

      if (control instanceof FormGroup) {
        this.markFormGroupTouched(control);
      } else if (control instanceof FormArray) {
        control.controls.forEach((arrayControl) => {
          if (arrayControl instanceof FormGroup) {
            this.markFormGroupTouched(arrayControl);
          } else {
            arrayControl.markAsTouched();
          }
        });
      }
    });
  }
}


--- ./src/app/pages/customers/customers-list/customer-list.component.scss ---
/* customers-list.component.scss */

:host {
  display: block;
  padding: 24px;
  background-color: var(--background-color);
  min-height: 100vh;
  margin-left: 250px; /* Account for sidebar width */
  padding-top: 88px; /* Account for topbar height (64px) + some padding */
}

/* Card styles */
.mat-mdc-card {
  margin-bottom: 24px;
  background-color: white;
  border-radius: 8px;
}

/* Header Section */
.header-wrapper {
  padding: 24px 24px 0;
}

.header-title h1 {
  margin: 0;
  font-size: 24px;
  font-weight: 500;
  color: var(--primary-color);
}

.header-title .subtitle {
  margin: 4px 0 0;
  color: var(--text-secondary);
  font-size: 14px;
}

/* Filters and Actions Section */
.filters-actions-wrapper {
  padding: 24px;
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 24px;
  border-bottom: 1px solid var(--border-color);
}

.filters-section {
  display: flex;
  flex: 1;
  gap: 16px;
  align-items: flex-start;
}

.search-field {
  width: 300px;
}

.search-field ::ng-deep .mat-mdc-text-field-wrapper {
  background-color: #f8f9fa;
}

.search-field input {
  height: 20px;
}

.filters-group {
  display: flex;
  flex-wrap: wrap;
  gap: 16px;
  flex: 1;
}

.filters-group mat-form-field {
  width: 180px;
}

.actions-group {
  display: flex;
  gap: 12px;
  margin-left: auto;
}

.export-button {
  height: 40px;
}

.create-button {
  height: 40px;
  padding: 0 20px;
  background-color: var(--primary-color);
  transition: background-color 0.2s ease;
}

.create-button:hover {
  background-color: var(--tertiary-color);
}

.actions-group .mat-icon {
  margin-right: 8px;
}

/* Table Container */
.table-container {
  position: relative;
  min-height: 400px;
  overflow: auto;
}

/* Scrollbar styling */
.table-container::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

.table-container::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 4px;
}

.table-container::-webkit-scrollbar-thumb {
  background: #ddd;
  border-radius: 4px;
}

.table-container::-webkit-scrollbar-thumb:hover {
  background: #ccc;
}

/* Loading Overlay */
.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.9);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  gap: 16px;
}

.loading-overlay span {
  color: var(--text-secondary);
  font-size: 14px;
}

/* Table Styles */
table {
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
}

table.loading {
  opacity: 0.6;
}

/* Header Styles */
.mat-mdc-header-row {
  background-color: #f8f9fa;
  min-height: 48px;
  border-bottom: 1px solid var(--border-color);
}

.mat-mdc-header-cell {
  color: var(--text-secondary);
  font-size: 12px;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  padding: 0 16px;
  white-space: nowrap;
  border-bottom: 1px solid var(--border-color);
}

.mat-mdc-header-cell:first-of-type {
  padding-left: 24px;
}

.mat-mdc-header-cell:last-of-type {
  padding-right: 24px;
}

/* Sort header styling */
.mat-sort-header-container {
  justify-content: flex-start;
}

.mat-sort-header-arrow {
  color: rgba(0, 0, 0, 0.38);
}

/* Cell Styles */
.mat-mdc-cell {
  font-size: 14px;
  color: var(--text-primary);
  padding: 0 16px;
  border-bottom: 1px solid rgba(0, 0, 0, 0.08);
  height: 52px;
}

.mat-mdc-cell:first-of-type {
  padding-left: 24px;
}

.mat-mdc-cell:last-of-type {
  padding-right: 24px;
}

/* Row Styles */
.customer-row {
  min-height: 52px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.customer-row:hover {
  background-color: #fafafa;
}

.customer-row:hover .job-id {
  color: var(--primary-color);
}

.customer-row:active {
  background-color: var(--active-color);
}

.customer-row.selected {
  background-color: var(--active-color);
}

/* Column Styles */
.mat-column-id {
  width: 100px;
  white-space: nowrap;
}

.mat-column-size,
.mat-column-status {
  width: 140px;
}

.mat-column-lastContact {
  width: 120px;
}

.mat-column-actions {
  width: 60px;
  text-align: right;
}

.mat-column-select {
  width: 50px;
  overflow: visible;
}

.contacts-cell {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.primary-contact {
  color: var(--text-primary);
}

.contacts-count {
  font-size: 12px;
  color: var(--text-secondary);
}

/* Size Chips */
.size-chip {
  display: inline-flex;
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: 500;
}

.size-chip.size-small {
  background-color: #e8f5e9;
  color: #2e7d32;
}

.size-chip.size-medium {
  background-color: #e3f2fd;
  color: #1565c0;
}

.size-chip.size-large {
  background-color: #fff8e1;
  color: #f57f17;
}

.size-chip.size-enterprise {
  background-color: #fbe9e7;
  color: #d84315;
}

/* Status Chips */
.status-chip {
  display: inline-flex;
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: 500;
}

.status-chip.status-active {
  background-color: #e8f5e9;
  color: #2e7d32;
}

.status-chip.status-inactive {
  background-color: #f5f5f5;
  color: #757575;
}

.status-chip.status-pending {
  background-color: #fff8e1;
  color: #f57f17;
}

/* Empty State */
.empty-state {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  width: 100%;
  padding: 0 24px;
  box-sizing: border-box;
}

.empty-state .empty-icon {
  font-size: 48px;
  width: 48px;
  height: 48px;
  color: rgba(0, 0, 0, 0.38);
  margin-bottom: 16px;
}

.empty-state h3 {
  margin: 0 0 8px;
  font-size: 16px;
  color: var(--text-primary);
}

.empty-state p {
  margin: 0 0 24px;
  color: var(--text-secondary);
  font-size: 14px;
}

.empty-state button {
  min-width: 160px;
}

.empty-state .mat-icon {
  margin-right: 8px;
}

/* Delete Action */
.delete-action {
  color: #f44336;
}

/* Responsive Design */
@media screen and (max-width: 1200px) {
  .filters-section {
    flex-direction: column;
  }

  .search-field {
    width: 100%;
  }

  .filters-group {
    width: 100%;
  }

  .filters-group mat-form-field {
    flex: 1;
    min-width: 150px;
  }
}

@media screen and (max-width: 960px) {
  :host {
    padding: 16px;
    padding-top: 80px; /* Slightly reduced top padding */
  }

  .filters-actions-wrapper {
    flex-direction: column;
  }

  .actions-group {
    width: 100%;
    justify-content: space-between;
  }

  .actions-group button {
    flex: 1;
  }

  .mat-column-category,
  .mat-column-lastContact {
    display: none;
  }
}

@media screen and (max-width: 768px) {
  :host {
    margin-left: 60px; /* Collapsed sidebar width */
    padding-top: 80px; /* Reduced topbar padding for smaller screens */
  }

  .mat-column-size {
    display: none;
  }
}

@media screen and (max-width: 600px) {
  :host {
    padding: 8px;
    padding-top: 72px; /* Further reduced for mobile */
  }

  .header-wrapper {
    padding: 16px 16px 0;
  }

  .filters-actions-wrapper {
    padding: 16px;
  }

  .filters-group {
    flex-direction: column;
  }

  .filters-group mat-form-field {
    width: 100% !important;
  }

  .actions-group {
    flex-direction: column;
    gap: 8px;
  }

  .mat-column-id {
    display: none;
  }
}

/* Print Styles */
@media print {
  :host {
    padding: 0;
    background: white;
    margin-left: 0; /* No sidebar in print */
    padding-top: 0; /* No topbar in print */
  }

  .mat-mdc-card {
    box-shadow: none !important;
  }

  .filters-actions-wrapper,
  .mat-mdc-paginator,
  .mat-column-select,
  .mat-column-actions {
    display: none !important;
  }

  .table-container {
    overflow: visible;
  }

  .customer-row {
    break-inside: avoid;
  }

  /* Ensure good contrast for printing */
  .status-chip,
  .size-chip {
    border: 1px solid rgba(0, 0, 0, 0.2);
  }
}


--- ./src/app/pages/customers/customers-list/customer-list.component.html ---
<!-- customer-list.component.html -->
<mat-card class="mat-elevation-z3">
  <!-- Header -->
  <div class="header-wrapper">
    <div class="header-title">
      <h1>Customers</h1>
      <p class="subtitle">
        {{ dataSource.filteredData.length }} total customers
        <ng-container *ngIf="selection.hasValue()"> ({{ selection.selected.length }} selected) </ng-container>
      </p>
    </div>
  </div>

  <!-- Filters and Actions Bar -->
  <div class="filters-actions-wrapper">
    <div class="filters-section">
      <mat-form-field appearance="outline" class="search-field">
        <mat-label>Search customers</mat-label>
        <input matInput (keyup)="applyFilter($event)" placeholder="Search by name, category, location, or contacts" />
        <mat-icon matSuffix>search</mat-icon>
      </mat-form-field>

      <div class="filters-group">
        <mat-form-field appearance="outline">
          <mat-label>Category</mat-label>
          <mat-select [(value)]="categoryFilter" (selectionChange)="onFilterChange()">
            <mat-option *ngFor="let category of categories" [value]="category">
              {{ category }}
            </mat-option>
          </mat-select>
        </mat-form-field>

        <mat-form-field appearance="outline">
          <mat-label>Size</mat-label>
          <mat-select [(value)]="sizeFilter" (selectionChange)="onFilterChange()">
            <mat-option *ngFor="let size of sizeOptions" [value]="size">
              {{ size }}
            </mat-option>
          </mat-select>
        </mat-form-field>

        <mat-form-field appearance="outline">
          <mat-label>Status</mat-label>
          <mat-select [(value)]="statusFilter" (selectionChange)="onFilterChange()">
            <mat-option *ngFor="let status of statusOptions" [value]="status">
              {{ status }}
            </mat-option>
          </mat-select>
        </mat-form-field>
      </div>
    </div>

    <div class="actions-group">
      <button mat-stroked-button [matMenuTriggerFor]="exportMenu" class="export-button" matTooltip="Export customers data">
        <mat-icon>download</mat-icon>
        Export
      </button>
      <button mat-flat-button color="primary" (click)="createNewCustomer()" class="create-button" [disabled]="!hasEditPermission" matTooltip="Add a new customer">
        <mat-icon>add</mat-icon>
        New Customer
      </button>
    </div>
  </div>

  <!-- Table Container -->
  <div class="table-container">
    <!-- Loading Overlay -->
    <div class="loading-overlay" *ngIf="isLoading">
      <mat-spinner diameter="40"></mat-spinner>
      <span>Loading customers...</span>
    </div>

    <!-- Table -->
    <table mat-table [dataSource]="dataSource" matSort [class.loading]="isLoading">
      <!-- Checkbox Column -->
      <ng-container matColumnDef="select">
        <th mat-header-cell *matHeaderCellDef>
          <mat-checkbox
            (change)="$event ? toggleAllRows() : null"
            [checked]="selection.hasValue() && isAllSelected()"
            [indeterminate]="selection.hasValue() && !isAllSelected()"
            [aria-label]="checkboxLabel()">
          </mat-checkbox>
        </th>
        <td mat-cell *matCellDef="let row">
          <mat-checkbox
            (click)="$event.stopPropagation()"
            (change)="$event ? selection.toggle(row) : null"
            [checked]="selection.isSelected(row)"
            [aria-label]="checkboxLabel(row)">
          </mat-checkbox>
        </td>
      </ng-container>

      <!-- ID Column -->
      <ng-container matColumnDef="id">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>ID</th>
        <td mat-cell *matCellDef="let customer">{{ customer.id }}</td>
      </ng-container>

      <!-- Name Column -->
      <ng-container matColumnDef="name">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Name</th>
        <td mat-cell *matCellDef="let customer">{{ customer.name }}</td>
      </ng-container>

      <!-- Category Column -->
      <ng-container matColumnDef="category">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Category</th>
        <td mat-cell *matCellDef="let customer">{{ customer.category || 'N/A' }}</td>
      </ng-container>

      <!-- Size Column -->
      <ng-container matColumnDef="size">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Size</th>
        <td mat-cell *matCellDef="let customer">
          <span class="size-chip" *ngIf="customer.size" [ngClass]="getSizeClass(customer.size)">
            {{ customer.size }}
          </span>
          <span *ngIf="!customer.size">N/A</span>
        </td>
      </ng-container>

      <!-- Location Column -->
      <ng-container matColumnDef="location">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Location</th>
        <td mat-cell *matCellDef="let customer">
          {{ customer.city ? customer.city + ', ' : '' }}
          {{ customer.country || 'N/A' }}
        </td>
      </ng-container>

      <!-- Primary Contact Column -->
      <ng-container matColumnDef="primaryContact">
        <th mat-header-cell *matHeaderCellDef>Primary Contact</th>
        <td mat-cell *matCellDef="let customer" class="contacts-cell">
          <div class="primary-contact">
            {{ getPrimaryContact(customer) }}
          </div>
          <div class="contacts-count" *ngIf="getContactsCount(customer) > 1">+{{ getContactsCount(customer) - 1 }} more</div>
        </td>
      </ng-container>

      <!-- Status Column -->
      <ng-container matColumnDef="status">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Status</th>
        <td mat-cell *matCellDef="let customer">
          <span class="status-chip" [ngClass]="getStatusClass(customer.status)">
            {{ customer.status }}
          </span>
        </td>
      </ng-container>

      <!-- Last Contact Column -->
      <ng-container matColumnDef="lastContact">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Last Contact</th>
        <td mat-cell *matCellDef="let customer">
          {{ customer.lastContact | date }}
        </td>
      </ng-container>

      <!-- Actions Column -->
      <ng-container matColumnDef="actions">
        <th mat-header-cell *matHeaderCellDef></th>
        <td mat-cell *matCellDef="let customer">
          <button mat-icon-button [matMenuTriggerFor]="menu" (click)="$event.stopPropagation()">
            <mat-icon>more_vert</mat-icon>
          </button>
          <mat-menu #menu="matMenu" xPosition="before">
            <button mat-menu-item (click)="viewCustomerDetails(customer)">
              <mat-icon>visibility</mat-icon>
              <span>View Details</span>
            </button>
            <button mat-menu-item (click)="editCustomer(customer, $event)" [disabled]="!hasEditPermission">
              <mat-icon>edit</mat-icon>
              <span>Edit</span>
            </button>
            <button mat-menu-item (click)="deleteCustomer(customer, $event)" class="delete-action" [disabled]="!hasEditPermission">
              <mat-icon>delete</mat-icon>
              <span>Delete</span>
            </button>
          </mat-menu>
        </td>
      </ng-container>

      <!-- Header and Data Rows -->
      <tr mat-header-row *matHeaderRowDef="displayedColumns; sticky: true"></tr>
      <tr
        mat-row
        *matRowDef="let row; columns: displayedColumns"
        (click)="viewCustomerDetails(row)"
        [class.selected]="selection.isSelected(row)"
        class="customer-row"></tr>
    </table>

    <!-- Empty State -->
    <div class="empty-state" *ngIf="!isLoading && dataSource.filteredData.length === 0">
      <mat-icon class="empty-icon">business</mat-icon>
      <h3>No customers found</h3>
      <p>Try adjusting your filters or add a new customer</p>
      <button mat-flat-button color="primary" (click)="createNewCustomer()" [disabled]="!hasEditPermission">
        <mat-icon>add</mat-icon>
        New Customer
      </button>
    </div>
  </div>

  <!-- Paginator -->
  <mat-paginator [length]="dataSource.filteredData.length" [pageSize]="25" [pageSizeOptions]="[10, 25, 50, 100]" showFirstLastButtons> </mat-paginator>
</mat-card>

<!-- Export Menu -->
<mat-menu #exportMenu="matMenu">
  <button mat-menu-item (click)="exportAllCustomers()">
    <mat-icon>file_download</mat-icon>
    <span>Export All</span>
  </button>
  <button mat-menu-item [disabled]="selection.selected.length === 0" (click)="exportSelectedCustomers()">
    <mat-icon>checklist</mat-icon>
    <span>Export Selected ({{ selection.selected.length }})</span>
  </button>
</mat-menu>


--- ./src/app/pages/customers/customers-list/customer-list.component.ts ---
import { Component, OnInit, ViewChild, OnDestroy, AfterViewInit } from '@angular/core';
import { Router } from '@angular/router';
import { MatTableDataSource } from '@angular/material/table';
import { MatSort } from '@angular/material/sort';
import { MatPaginator } from '@angular/material/paginator';
import { MatDialog } from '@angular/material/dialog';
import { SelectionModel } from '@angular/cdk/collections';
import { Subscription } from 'rxjs';
import { Customer, CustomerStatus, CustomerSize } from '../../../interfaces/customer.interface';
import { CustomerService } from '../../../services/customer.service';
import { NotificationService } from '../../../services/notification.service';
import { ConfirmationDialogComponent } from '../../../dialogs/confirmation-dialog.component';
import { AuthService } from '../../../services/auth.service';
import { saveAs } from 'file-saver';

@Component({
  selector: 'app-customer-list',
  templateUrl: './customer-list.component.html',
  styleUrls: ['./customer-list.component.scss'],
  standalone: false,
})
export class CustomerListComponent implements OnInit, AfterViewInit, OnDestroy {
  displayedColumns: string[] = ['select', 'id', 'name', 'category', 'size', 'location', 'primaryContact', 'status', 'lastContact', 'actions'];

  isLoading = false;
  dataSource = new MatTableDataSource<Customer>([]);
  selection = new SelectionModel<Customer>(true, []);
  hasEditPermission = false;

  @ViewChild(MatSort) sort!: MatSort;
  @ViewChild(MatPaginator) paginator!: MatPaginator;

  categoryFilter = 'All';
  sizeFilter = 'All';
  statusFilter = 'All';

  categories: string[] = [];
  sizeOptions = ['All', 'Small (1-50)', 'Medium (51-250)', 'Large (251-1000)', 'Enterprise (1000+)'];
  statusOptions = ['All', 'Active', 'Inactive', 'Pending'];

  private subscriptions: Subscription[] = [];

  constructor(
    private router: Router,
    private customerService: CustomerService,
    private notificationService: NotificationService,
    private authService: AuthService,
    private dialog: MatDialog
  ) {}

  ngOnInit(): void {
    this.isLoading = true;
    this.loadCustomers();
    this.loadCategories();
    this.checkPermissions();
  }

  ngAfterViewInit(): void {
    this.dataSource.sort = this.sort;
    this.dataSource.paginator = this.paginator;
    this.setupCustomFilter();
  }

  ngOnDestroy(): void {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }

  private checkPermissions(): void {
    const permissionSub = this.authService.hasPermission('canManageUsers').subscribe((hasPermission) => {
      this.hasEditPermission = hasPermission;
    });
    this.subscriptions.push(permissionSub);
  }

  private setupCustomFilter(): void {
    this.dataSource.filterPredicate = (data: Customer, filter: string) => {
      const searchText = filter.toLowerCase();
      const shouldInclude = (value: string | undefined) => (value ? value.toLowerCase().includes(searchText) : false);

      // Apply category filter
      if (this.categoryFilter !== 'All' && data.category !== this.categoryFilter) {
        return false;
      }

      // Apply size filter
      if (this.sizeFilter !== 'All' && data.size !== this.sizeFilter) {
        return false;
      }

      // Apply status filter
      if (this.statusFilter !== 'All' && data.status !== this.statusFilter) {
        return false;
      }

      // Apply text search
      return shouldInclude(data.name) || shouldInclude(data.category) || shouldInclude(data.city) || this.searchInContacts(data, searchText);
    };
  }

  private searchInContacts(customer: Customer, searchText: string): boolean {
    if (!customer.contacts || customer.contacts.length === 0) return false;

    return customer.contacts.some(
      (contact) =>
        (contact.name && contact.name.toLowerCase().includes(searchText)) ||
        (contact.email && contact.email.toLowerCase().includes(searchText)) ||
        (contact.phone && contact.phone.toLowerCase().includes(searchText))
    );
  }

  applyFilter(event: Event): void {
    const filterValue = (event.target as HTMLInputElement).value;
    this.dataSource.filter = filterValue.trim().toLowerCase();

    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage();
    }
  }

  onFilterChange(): void {
    this.dataSource.filter = this.dataSource.filter || ' ';
  }

  loadCustomers(): void {
    // Reset loading state
    this.isLoading = true;

    const customersSub = this.customerService.getCustomers().subscribe({
      next: (customers) => {
        this.dataSource.data = customers;
        this.isLoading = false;
      },
      error: (error) => {
        console.error('Error loading customers:', error);
        this.notificationService.addNotification({
          type: 'error',
          title: 'Error',
          message: 'Failed to load customers',
        });
        this.isLoading = false;
      },
    });

    this.subscriptions.push(customersSub);
  }

  loadCategories(): void {
    const categoriesSub = this.customerService.getCategories().subscribe({
      next: (categories) => {
        this.categories = ['All', ...categories];
      },
      error: (error) => {
        console.error('Error loading categories:', error);
      },
    });

    this.subscriptions.push(categoriesSub);
  }

  getPrimaryContact(customer: Customer): string {
    const primaryContact = customer.contacts?.find((contact) => contact.isPrimary);
    if (primaryContact) {
      return primaryContact.email;
    }

    // Return first contact email if no primary
    return customer.contacts?.length > 0 ? customer.contacts[0].email : 'N/A';
  }

  getContactsCount(customer: Customer): number {
    return customer.contacts?.length || 0;
  }

  getSizeClass(size: CustomerSize | undefined): string {
    if (!size) return 'size-default';

    const sizeMap: Record<string, string> = {
      [CustomerSize.SMALL]: 'size-small',
      [CustomerSize.MEDIUM]: 'size-medium',
      [CustomerSize.LARGE]: 'size-large',
      [CustomerSize.ENTERPRISE]: 'size-enterprise',
    };
    return sizeMap[size] || 'size-default';
  }

  getStatusClass(status: CustomerStatus): string {
    const statusMap: Record<string, string> = {
      [CustomerStatus.ACTIVE]: 'status-active',
      [CustomerStatus.INACTIVE]: 'status-inactive',
      [CustomerStatus.PENDING]: 'status-pending',
    };
    return statusMap[status] || 'status-default';
  }

  isAllSelected(): boolean {
    const numSelected = this.selection.selected.length;
    const numRows = this.dataSource.data.length;
    return numSelected === numRows;
  }

  toggleAllRows(): void {
    if (this.isAllSelected()) {
      this.selection.clear();
      return;
    }
    this.selection.select(...this.dataSource.data);
  }

  checkboxLabel(row?: Customer): string {
    if (!row) {
      return `${this.isAllSelected() ? 'deselect' : 'select'} all`;
    }
    return `${this.selection.isSelected(row) ? 'deselect' : 'select'} row ${row.id}`;
  }

  createNewCustomer(): void {
    this.router.navigate(['/customers/new']);
  }

  editCustomer(customer: Customer, event?: Event): void {
    if (event) {
      event.stopPropagation(); // Prevent row click event
    }
    this.router.navigate(['/customers', customer.id, 'edit']);
  }

  viewCustomerDetails(customer: Customer): void {
    this.router.navigate(['/customers', customer.id]);
  }

  deleteCustomer(customer: Customer, event?: Event): void {
    if (event) {
      event.stopPropagation(); // Prevent row click event
    }

    const dialogRef = this.dialog.open(ConfirmationDialogComponent, {
      data: {
        title: 'Delete Customer',
        message: `Are you sure you want to delete ${customer.name}? This action cannot be undone.`,
        confirmText: 'Delete',
        cancelText: 'Cancel',
        confirmColor: 'warn',
      },
      width: '400px',
    });

    dialogRef.afterClosed().subscribe((result) => {
      if (result) {
        this.isLoading = true;

        const deleteSub = this.customerService.deleteCustomer(customer.id).subscribe({
          next: () => {
            this.notificationService.addNotification({
              type: 'success',
              title: 'Customer Deleted',
              message: `${customer.name} has been deleted successfully`,
            });
            this.selection.deselect(customer);
            this.loadCustomers();
          },
          error: (error) => {
            console.error('Error deleting customer:', error);
            this.notificationService.addNotification({
              type: 'error',
              title: 'Error',
              message: `Failed to delete customer: ${error.message}`,
            });
            this.isLoading = false;
          },
        });

        this.subscriptions.push(deleteSub);
      }
    });
  }

  exportAllCustomers(): void {
    const allCustomers = this.dataSource.filteredData;
    this.downloadCustomersCsv(allCustomers);
  }

  exportSelectedCustomers(): void {
    const selectedCustomers = this.selection.selected;
    if (selectedCustomers.length === 0) {
      this.notificationService.addNotification({
        type: 'warning',
        title: 'No Customers Selected',
        message: 'Please select at least one customer to export',
      });
      return;
    }
    this.downloadCustomersCsv(selectedCustomers);
  }

  private downloadCustomersCsv(customers: Customer[]): void {
    // Define headers
    const headers = [
      'ID',
      'Name',
      'Category',
      'Size',
      'Status',
      'Address',
      'City',
      'Postcode',
      'Country',
      'Primary Contact Name',
      'Primary Contact Email',
      'Primary Contact Phone',
      'Website',
      'Created Date',
      'Last Contact',
    ];

    // Create rows
    const rows = customers.map((customer) => {
      const primaryContact = customer.contacts?.find((contact) => contact.isPrimary) || customer.contacts?.[0] || {};

      return [
        customer.id,
        customer.name,
        customer.category || '',
        customer.size || '',
        customer.status,
        customer.address || '',
        customer.city || '',
        customer.postcode || '',
        customer.country || '',
        primaryContact.name || '',
        primaryContact.email || '',
        primaryContact.phone || '',
        customer.website || '',
        customer.createdAt ? new Date(customer.createdAt).toLocaleDateString() : '',
        customer.lastContact ? new Date(customer.lastContact).toLocaleDateString() : '',
      ];
    });

    // Create CSV content
    const csvContent = [
      headers.join(','),
      ...rows.map((row) =>
        row
          .map((cell) =>
            // Handle cells that might contain commas by wrapping in quotes
            typeof cell === 'string' && (cell.includes(',') || cell.includes('"')) ? `"${cell.replace(/"/g, '""')}"` : cell
          )
          .join(',')
      ),
    ].join('\n');

    // Create and download blob
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const filename = `customers_export_${new Date().toISOString().slice(0, 10)}.csv`;
    saveAs(blob, filename);

    this.notificationService.addNotification({
      type: 'success',
      title: 'Export Complete',
      message: `${customers.length} customers exported to CSV`,
    });
  }

  refreshData(): void {
    this.loadCustomers();
  }
}


--- ./src/app/pages/customers/customer-details/customer-details.component.ts ---
import { Component, OnInit, OnDestroy } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { Location } from '@angular/common';
import { MatDialog } from '@angular/material/dialog';
import { MatSnackBar } from '@angular/material/snack-bar';
import { MatTableDataSource } from '@angular/material/table';
import { Subscription } from 'rxjs';
import { CustomerService } from '../../../services/customer.service';
import { JobService } from '../../../services/job.service';
import { NotificationService } from '../../../services/notification.service';
import { AuthService } from '../../../services/auth.service';
import { ConfirmationDialogComponent } from '../../../dialogs/confirmation-dialog.component';
import { Customer, CustomerStatus, CustomerContact } from '../../../interfaces/customer.interface';
import { Job } from '../../../interfaces/job.interface';

@Component({
  selector: 'app-customer-details',
  templateUrl: './customer-details.component.html',
  styleUrls: ['./customer-details.component.scss'],
  standalone: false,
})
export class CustomerDetailsComponent implements OnInit, OnDestroy {
  customerId: string = '';
  customer: Customer | null = null;
  isLoading = true;
  hasEditPermission = false;
  activeTab: 'details' | 'jobs' | 'notes' = 'details';

  // Jobs table
  jobsDataSource = new MatTableDataSource<Job>([]);
  displayedColumns: string[] = ['id', 'status', 'vehicleType', 'registration', 'collection', 'delivery', 'actions'];
  isJobsLoading = false;

  private subscriptions: Subscription[] = [];

  constructor(
    private route: ActivatedRoute,
    private router: Router,
    private location: Location,
    private customerService: CustomerService,
    private jobService: JobService,
    private notificationService: NotificationService,
    private authService: AuthService,
    private dialog: MatDialog,
    private snackBar: MatSnackBar
  ) {}

  ngOnInit(): void {
    // Get customer ID from route
    const routeSub = this.route.paramMap.subscribe((params) => {
      const id = params.get('id');
      if (id) {
        this.customerId = id;
        this.loadCustomerDetails();
      } else {
        this.router.navigate(['/customers']);
      }
    });
    this.subscriptions.push(routeSub);

    // Check permissions
    const permissionSub = this.authService.hasPermission('canManageUsers').subscribe((hasPermission) => {
      this.hasEditPermission = hasPermission;
    });
    this.subscriptions.push(permissionSub);
  }

  ngOnDestroy(): void {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }

  /**
   * Load customer details
   */
  loadCustomerDetails(): void {
    this.isLoading = true;

    const customerSub = this.customerService.getCustomerById(this.customerId).subscribe({
      next: (customer) => {
        this.customer = customer;
        this.isLoading = false;

        // Load customer jobs
        if (customer) {
          this.loadCustomerJobs();
        }
      },
      error: (error) => {
        console.error('Error loading customer details:', error);
        this.notificationService.addNotification({
          type: 'error',
          title: 'Error',
          message: 'Failed to load customer details',
        });
        this.isLoading = false;
        this.router.navigate(['/customers']);
      },
    });

    this.subscriptions.push(customerSub);
  }

  /**
   * Load jobs associated with this customer
   */
  loadCustomerJobs(): void {
    this.isJobsLoading = true;

    const jobsSub = this.jobService.getCustomerJobs(this.customerId).subscribe({
      next: (jobs) => {
        this.jobsDataSource.data = jobs;
        this.isJobsLoading = false;
      },
      error: (error) => {
        console.error(`Error fetching jobs for customer ${this.customerId}:`, error);
        this.isJobsLoading = false;
        this.jobsDataSource.data = [];
      },
    });

    this.subscriptions.push(jobsSub);
  }

  /**
   * Get status class for CSS styling
   * This accepts a string status value and returns the appropriate CSS class name
   */
  getStatusClass(status: string | undefined): string {
    if (!status) return 'status-gray';

    switch (status.toLowerCase()) {
      case 'active':
        return 'status-active';
      case 'pending':
        return 'status-pending';
      case 'inactive':
      default:
        return 'status-inactive';
    }
  }

  /**
   * Format currency for display
   */
  formatCurrency(value: number): string {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
    }).format(value);
  }

  /**
   * Get primary contact from contacts array
   */
  getPrimaryContact(): CustomerContact | null {
    if (!this.customer?.contacts || this.customer.contacts.length === 0) {
      return null;
    }

    const primaryContact = this.customer.contacts.find((contact) => contact.isPrimary);
    return primaryContact || this.customer.contacts[0];
  }

  /**
   * Set active tab
   */
  setActiveTab(tab: 'details' | 'jobs' | 'notes'): void {
    this.activeTab = tab;
  }

  /**
   * Navigate to job details
   */
  viewJobDetails(jobId: string): void {
    this.router.navigate(['/jobs', jobId]);
  }

  /**
   * Navigate to edit customer page
   */
  editCustomer(): void {
    this.router.navigate(['/customers', this.customerId, 'edit']);
  }

  /**
   * Delete customer with confirmation
   */
  deleteCustomer(): void {
    if (!this.customer) return;

    const dialogRef = this.dialog.open(ConfirmationDialogComponent, {
      data: {
        title: 'Delete Customer',
        message: `Are you sure you want to delete ${this.customer.name}? This action cannot be undone.`,
        confirmText: 'Delete',
        cancelText: 'Cancel',
        confirmColor: 'warn',
      },
      width: '400px',
    });

    dialogRef.afterClosed().subscribe((result) => {
      if (result && this.customer) {
        this.isLoading = true;

        const deleteSub = this.customerService.deleteCustomer(this.customerId).subscribe({
          next: () => {
            this.notificationService.addNotification({
              type: 'success',
              title: 'Customer Deleted',
              message: `${this.customer?.name} has been deleted successfully`,
            });
            this.router.navigate(['/customers']);
          },
          error: (error) => {
            console.error('Error deleting customer:', error);
            this.notificationService.addNotification({
              type: 'error',
              title: 'Error',
              message: `Failed to delete customer: ${error.message}`,
            });
            this.isLoading = false;
          },
        });

        this.subscriptions.push(deleteSub);
      }
    });
  }

  /**
   * Navigate back
   */
  goBack(): void {
    this.location.back();
  }

  /**
   * Get industry icon
   */
  getIndustryIcon(industry: string): string {
    const iconMap: Record<string, string> = {
      Technology: 'computer',
      Manufacturing: 'precision_manufacturing',
      Healthcare: 'medical_services',
      Finance: 'account_balance',
      Retail: 'shopping_cart',
      Education: 'school',
      Construction: 'construction',
      Transportation: 'directions_bus',
      Energy: 'bolt',
      Telecommunications: 'phone_in_talk',
      Agriculture: 'grass',
      Entertainment: 'movie',
      Hospitality: 'hotel',
      Media: 'ondemand_video',
      'Professional Services': 'business_center',
      'Real Estate': 'apartment',
    };

    return iconMap[industry] || 'business';
  }
}


--- ./src/app/pages/customers/customer-details/customer-details.component.scss ---
/* customer-details.component.scss */

:host {
  display: block;
  padding: 24px;
  background-color: var(--background-color);
  min-height: 100vh;
  margin-left: 250px; /* Account for sidebar width */
  padding-top: 88px; /* Account for topbar height (64px) + some padding */
}

/* Card styles */
.mat-mdc-card {
  margin-bottom: 24px;
  background-color: white;
  border-radius: 8px;
}

/* Loading Overlay */
.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.9);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  gap: 16px;
}

.loading-overlay span {
  color: var(--text-secondary);
  font-size: 14px;
}

/* Header Section */
.header-wrapper {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 24px;
  border-bottom: 1px solid var(--border-color);
}

.header-title {
  display: flex;
  align-items: center;
  gap: 16px;
}

.title-content {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.header-title h1 {
  margin: 0;
  font-size: 24px;
  font-weight: 600;
  color: var(--primary-color);
}

.customer-status {
  display: flex;
  align-items: center;
  gap: 8px;
}

.header-actions {
  display: flex;
  gap: 12px;
}

.header-actions button {
  display: flex;
  align-items: center;
  gap: 8px;
}

/* Tab Navigation */
.tab-navigation {
  padding: 0 24px;
  display: flex;
  gap: 32px;
  border-bottom: 1px solid var(--border-color);
}

.tab-navigation button {
  padding: 16px 8px;
  background: none;
  border: none;
  color: var(--text-secondary);
  font-weight: 500;
  cursor: pointer;
  position: relative;
  transition: color 0.2s ease;
}

.tab-navigation button:hover {
  color: var(--text-primary);
}

.tab-navigation button.active {
  color: var(--primary-color);
}

.tab-navigation button.active::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 2px;
  background-color: var(--primary-color);
}

/* Content Wrapper */
.content-wrapper {
  padding: 24px;
}

/* Details Tab */
.details-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 24px;
  margin-bottom: 24px;
}

.details-section,
.contacts-section,
.jobs-section,
.notes-section {
  padding: 24px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
  background-color: white;
}

.details-section h2,
.contacts-section h2,
.jobs-section h2,
.notes-section h2 {
  margin-top: 0;
  margin-bottom: 24px;
  font-size: 18px;
  color: var(--primary-color);
  font-weight: 600;
}

/* Information Grid */
.info-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 16px;
}

.info-item {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.info-item.full-width {
  grid-column: 1 / -1;
}

.info-item label {
  font-size: 14px;
  color: var(--text-secondary);
  font-weight: 500;
}

.info-item span {
  font-size: 16px;
  color: var(--text-primary);
}

.info-item p {
  margin: 0;
  font-size: 16px;
  color: var(--text-primary);
  line-height: 1.5;
}

.value-with-icon {
  display: flex;
  align-items: center;
  gap: 8px;
}

.value-with-icon mat-icon {
  font-size: 20px;
  width: 20px;
  height: 20px;
  color: var(--primary-color);
}

.address {
  white-space: pre-line;
}

/* Status Chips */
.status-chip {
  display: inline-flex;
  padding: 6px 12px;
  border-radius: 16px;
  font-size: 14px;
  font-weight: 500;
}

.status-chip.small {
  padding: 4px 8px;
  font-size: 12px;
}

.status-chip.status-active {
  background-color: #e8f5e9;
  color: #2e7d32;
}

.status-chip.status-inactive {
  background-color: #f5f5f5;
  color: #757575;
}

.status-chip.status-pending {
  background-color: #fff8e1;
  color: #f57f17;
}

.status-chip.status-success {
  background-color: #e8f5e9;
  color: #2e7d32;
}

.status-chip.status-warning {
  background-color: #fff8e1;
  color: #f57f17;
}

.status-chip.status-info {
  background-color: #e3f2fd;
  color: #1976d2;
}

.status-chip.status-error {
  background-color: #ffebee;
  color: #c62828;
}

/* Contacts Grid */
.contacts-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 16px;
}

.contact-card {
  padding: 16px;
  border-radius: 8px;
  background-color: #f8f9fa;
  border: 1px solid #eee;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.contact-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.contact-name {
  font-size: 16px;
  font-weight: 600;
  color: var(--primary-color);
}

.contact-badge {
  font-size: 12px;
  padding: 2px 8px;
  background-color: var(--primary-color);
  color: white;
  border-radius: 10px;
}

.contact-position {
  font-size: 14px;
  color: var(--text-secondary);
}

.contact-details {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-top: 4px;
}

.contact-item {
  display: flex;
  align-items: center;
  gap: 8px;
}

.contact-item mat-icon {
  font-size: 16px;
  width: 16px;
  height: 16px;
  color: var(--text-secondary);
}

.contact-item a {
  color: var(--primary-color);
  text-decoration: none;
}

.contact-item a:hover {
  text-decoration: underline;
}

/* Jobs Section */
.section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
}

.table-container {
  position: relative;
  min-height: 200px;
}

.jobs-table {
  width: 100%;
}

.mat-mdc-header-row {
  background-color: #f8f9fa;
}

.mat-mdc-header-cell {
  color: var(--text-secondary);
  font-size: 12px;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  padding: 0 16px;
}

.mat-mdc-cell {
  padding: 0 16px;
}

.job-row {
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.job-row:hover {
  background-color: #f5f5f5;
}

/* Notes Section */
.notes-content {
  background-color: #f8f9fa;
  border-radius: 8px;
  padding: 16px;
}

.note {
  white-space: pre-line;
  line-height: 1.6;
}

/* Empty States */
.empty-state,
.empty-notes {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 48px 0;
  text-align: center;
}

.empty-state mat-icon,
.empty-notes mat-icon {
  font-size: 48px;
  width: 48px;
  height: 48px;
  color: #d0d0d0;
  margin-bottom: 16px;
}

.empty-state h3,
.empty-notes h3 {
  margin: 0 0 8px;
  font-size: 18px;
  color: var(--text-primary);
}

.empty-state p,
.empty-notes p {
  margin: 0 0 24px;
  color: var(--text-secondary);
}

/* Responsive Design */
@media screen and (max-width: 1200px) {
  .details-grid {
    gap: 16px;
  }

  .info-grid {
    gap: 12px;
  }

  .contacts-grid {
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  }
}

@media screen and (max-width: 992px) {
  .details-grid {
    grid-template-columns: 1fr;
  }

  .info-grid {
    grid-template-columns: 1fr 1fr;
  }
}

@media screen and (max-width: 768px) {
  :host {
    margin-left: 60px; /* Collapsed sidebar width */
    padding: 16px;
    padding-top: 80px; /* Reduced topbar padding for smaller screens */
  }

  .header-wrapper {
    flex-direction: column;
    align-items: flex-start;
    gap: 16px;
  }

  .header-actions {
    width: 100%;
    justify-content: flex-end;
  }

  .tab-navigation {
    padding: 0 16px;
    gap: 16px;
    overflow-x: auto;
  }

  .content-wrapper {
    padding: 16px;
  }

  .info-grid {
    grid-template-columns: 1fr;
  }

  .contacts-grid {
    grid-template-columns: 1fr;
  }

  .mat-column-collection,
  .mat-column-delivery {
    display: none;
  }
}

@media screen and (max-width: 480px) {
  :host {
    padding: 8px;
  }

  .header-wrapper {
    padding: 16px;
  }

  .header-title {
    gap: 8px;
  }

  .header-title h1 {
    font-size: 20px;
  }

  .header-actions {
    flex-direction: column;
    align-items: stretch;
    gap: 8px;
  }

  .content-wrapper {
    padding: 12px;
  }

  .details-section h2,
  .contacts-section h2,
  .jobs-section h2,
  .notes-section h2 {
    font-size: 16px;
    margin-bottom: 16px;
  }

  .section-header {
    flex-direction: column;
    align-items: flex-start;
    gap: 12px;
  }

  .section-header button {
    width: 100%;
  }
}

/* Print Styles */
@media print {
  :host {
    padding: 0;
    background: white;
    margin-left: 0; /* No sidebar in print */
    padding-top: 0; /* No topbar in print */
  }

  .mat-mdc-card {
    box-shadow: none !important;
    margin-bottom: 0;
  }

  .header-actions,
  .tab-navigation {
    display: none !important;
  }

  .content-wrapper {
    padding: 16px;
  }

  .details-grid {
    display: block;
    margin-bottom: 16px;
  }

  .details-section,
  .contacts-section {
    page-break-inside: avoid;
    margin-bottom: 16px;
    box-shadow: none !important;
    border: 1px solid #ddd;
  }

  .jobs-section,
  .notes-section {
    page-break-inside: avoid;
    margin-top: 16px;
    box-shadow: none !important;
    border: 1px solid #ddd;
  }
}


--- ./src/app/pages/customers/customer-details/customer-details.component.html ---
<!-- customer-details.component.html -->
<mat-card class="mat-elevation-z3">
  <!-- Loading Spinner -->
  <div class="loading-overlay" *ngIf="isLoading">
    <mat-spinner diameter="40"></mat-spinner>
    <span>Loading customer details...</span>
  </div>

  <!-- Header -->
  <div class="header-wrapper">
    <div class="header-title">
      <button mat-icon-button (click)="goBack()">
        <mat-icon>arrow_back</mat-icon>
      </button>
      <div class="title-content">
        <h1>{{ customer?.name }}</h1>
        <div class="customer-status" *ngIf="customer">
          <span class="status-chip small" [ngClass]="getStatusClass(customer.status)">
            {{ customer.status || 'Unknown' }}
          </span>
        </div>
      </div>
    </div>
    <div class="header-actions">
      <button mat-stroked-button (click)="deleteCustomer()" *ngIf="hasEditPermission">
        <mat-icon>delete</mat-icon>
        Delete Customer
      </button>
      <button mat-flat-button color="primary" (click)="editCustomer()" *ngIf="hasEditPermission">
        <mat-icon>edit</mat-icon>
        Edit Customer
      </button>
    </div>
  </div>

  <!-- Tab Navigation -->
  <div class="tab-navigation">
    <button [class.active]="activeTab === 'details'" (click)="setActiveTab('details')">Details</button>
    <button [class.active]="activeTab === 'jobs'" (click)="setActiveTab('jobs')">Jobs</button>
    <button [class.active]="activeTab === 'notes'" (click)="setActiveTab('notes')">Notes</button>
  </div>

  <!-- Customer Details -->
  <mat-card-content class="content-wrapper" *ngIf="customer">
    <div [ngSwitch]="activeTab">
      <!-- Details Tab -->
      <div *ngSwitchCase="'details'" class="details-tab">
        <div class="details-grid">
          <!-- Customer Information -->
          <mat-card class="details-section">
            <h2>Customer Information</h2>
            <div class="info-grid">
              <div class="info-item">
                <label>Industry</label>
                <div class="value-with-icon">
                  <mat-icon>{{ getIndustryIcon(customer.industry || '') }}</mat-icon>
                  <span>{{ customer.industry || 'Not specified' }}</span>
                </div>
              </div>
              <div class="info-item">
                <label>Size</label>
                <span>{{ customer.size }}</span>
              </div>
              <div class="info-item">
                <label>Status</label>
                <span class="status-chip small" [ngClass]="getStatusClass(customer.status)">
                  {{ customer.status }}
                </span>
              </div>
              <div class="info-item">
                <label>Website</label>
                <a *ngIf="customer.website" [href]="customer.website" target="_blank" rel="noopener noreferrer">
                  {{ customer.website }}
                </a>
                <span *ngIf="!customer.website">Not provided</span>
              </div>
              <div class="info-item full-width">
                <label>Description</label>
                <p>{{ customer.description || 'No description provided' }}</p>
              </div>
              <div class="info-item">
                <label>Created</label>
                <span>{{ customer.createdAt | date }}</span>
              </div>
              <div class="info-item">
                <label>Last Updated</label>
                <span>{{ customer.updatedAt | date }}</span>
              </div>
              <div class="info-item" *ngIf="customer.lastContact">
                <label>Last Contact</label>
                <span>{{ customer.lastContact | date }}</span>
              </div>
            </div>
          </mat-card>

          <!-- Address Section -->
          <mat-card class="details-section">
            <h2>Address</h2>
            <div class="info-grid">
              <div class="info-item full-width">
                <label>Street Address</label>
                <p class="address">{{ customer.address }}</p>
              </div>
              <div class="info-item">
                <label>City</label>
                <span>{{ customer.city || 'Not provided' }}</span>
              </div>
              <div class="info-item">
                <label>Postcode</label>
                <span>{{ customer.postcode || 'Not provided' }}</span>
              </div>
              <div class="info-item">
                <label>Country</label>
                <span>{{ customer.country || 'Not provided' }}</span>
              </div>
            </div>
          </mat-card>
        </div>

        <!-- Contacts Section -->
        <mat-card class="contacts-section">
          <h2>Contacts</h2>
          <div class="contacts-grid">
            <div *ngFor="let contact of customer.contacts" class="contact-card">
              <div class="contact-header">
                <div class="contact-name">{{ contact.name }}</div>
                <div class="contact-badge" *ngIf="contact.isPrimary">Primary</div>
              </div>
              <div class="contact-position" *ngIf="contact.position">{{ contact.position }}</div>
              <div class="contact-details">
                <div class="contact-item">
                  <mat-icon>email</mat-icon>
                  <a [href]="'mailto:' + contact.email">{{ contact.email }}</a>
                </div>
                <div class="contact-item" *ngIf="contact.phone">
                  <mat-icon>phone</mat-icon>
                  <a [href]="'tel:' + contact.phone">{{ contact.phone }}</a>
                </div>
              </div>
            </div>
          </div>
        </mat-card>
      </div>

      <!-- Jobs Tab -->
      <div *ngSwitchCase="'jobs'" class="jobs-tab">
        <mat-card class="jobs-section">
          <div class="section-header">
            <h2>Job History</h2>
            <button mat-stroked-button color="primary" [routerLink]="['/jobs/new']" [queryParams]="{ customerId: customer.id }">
              <mat-icon>add</mat-icon>
              New Job
            </button>
          </div>

          <!-- Loading Jobs Spinner -->
          <div class="loading-overlay" *ngIf="isJobsLoading">
            <mat-spinner diameter="30"></mat-spinner>
            <span>Loading jobs...</span>
          </div>

          <div class="table-container">
            <table mat-table [dataSource]="jobsDataSource" class="jobs-table">
              <!-- ID Column -->
              <ng-container matColumnDef="id">
                <th mat-header-cell *matHeaderCellDef>Job ID</th>
                <td mat-cell *matCellDef="let job">{{ job.id }}</td>
              </ng-container>

              <!-- Status Column -->
              <ng-container matColumnDef="status">
                <th mat-header-cell *matHeaderCellDef>Status</th>
                <td mat-cell *matCellDef="let job">
                  <span class="status-chip small" [ngClass]="getStatusClass(job.status)">
                    {{ job.status || 'Unknown' }}
                  </span>
                </td>
              </ng-container>

              <!-- Vehicle Type Column -->
              <ng-container matColumnDef="vehicleType">
                <th mat-header-cell *matHeaderCellDef>Vehicle Type</th>
                <td mat-cell *matCellDef="let job">{{ job.vehicleType || 'N/A' }}</td>
              </ng-container>

              <!-- Registration Column -->
              <ng-container matColumnDef="registration">
                <th mat-header-cell *matHeaderCellDef>Registration</th>
                <td mat-cell *matCellDef="let job">{{ job.registration || 'N/A' }}</td>
              </ng-container>

              <!-- Collection Column -->
              <ng-container matColumnDef="collection">
                <th mat-header-cell *matHeaderCellDef>Collection</th>
                <td mat-cell *matCellDef="let job">
                  {{ job.collectionAddress ? (job.collectionAddress | slice : 0 : 30) + (job.collectionAddress.length > 30 ? '...' : '') : 'N/A' }}
                </td>
              </ng-container>

              <!-- Delivery Column -->
              <ng-container matColumnDef="delivery">
                <th mat-header-cell *matHeaderCellDef>Delivery</th>
                <td mat-cell *matCellDef="let job">
                  {{ job.deliveryAddress ? (job.deliveryAddress | slice : 0 : 30) + (job.deliveryAddress.length > 30 ? '...' : '') : 'N/A' }}
                </td>
              </ng-container>

              <!-- Actions Column -->
              <ng-container matColumnDef="actions">
                <th mat-header-cell *matHeaderCellDef></th>
                <td mat-cell *matCellDef="let job">
                  <button mat-icon-button [matMenuTriggerFor]="menu">
                    <mat-icon>more_vert</mat-icon>
                  </button>
                  <mat-menu #menu="matMenu" xPosition="before">
                    <button mat-menu-item (click)="viewJobDetails(job.id)">
                      <mat-icon>visibility</mat-icon>
                      <span>View Details</span>
                    </button>
                  </mat-menu>
                </td>
              </ng-container>

              <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
              <tr mat-row *matRowDef="let row; columns: displayedColumns" (click)="viewJobDetails(row.id)" class="job-row"></tr>
            </table>

            <!-- Empty state for jobs -->
            <div class="empty-state" *ngIf="!isJobsLoading && jobsDataSource.data.length === 0">
              <mat-icon>work_off</mat-icon>
              <h3>No Jobs Found</h3>
              <p>This customer doesn't have any jobs yet.</p>
              <button mat-flat-button color="primary" [routerLink]="['/jobs/new']" [queryParams]="{ customerId: customer.id }">
                <mat-icon>add</mat-icon>
                Create First Job
              </button>
            </div>
          </div>
        </mat-card>
      </div>

      <!-- Notes Tab -->
      <div *ngSwitchCase="'notes'" class="notes-tab">
        <mat-card class="notes-section">
          <h2>Customer Notes</h2>
          <div class="notes-content">
            <div class="note" *ngIf="customer.notes">
              <p>{{ customer.notes }}</p>
            </div>
            <div class="empty-notes" *ngIf="!customer.notes">
              <mat-icon>note</mat-icon>
              <p>No notes available for this customer</p>
              <button mat-stroked-button color="primary" (click)="editCustomer()" *ngIf="hasEditPermission">
                <mat-icon>edit</mat-icon>
                Add Notes
              </button>
            </div>
          </div>
        </mat-card>
      </div>
    </div>
  </mat-card-content>
</mat-card>


--- ./src/app/pages/settings/settings-routing.module.ts ---
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { SettingsComponent } from './settings.component';
import { VehicleMakesComponent } from './vehicle-makes/vehicle-makes.component';
import { VehicleModelsComponent } from './vehicle-models/vehicle-models.component';
import { UserRolesComponent } from './user-roles/user-roles.component';
import { SystemPreferencesComponent } from './system-preferences/system-preferences.component';
import { RoleGuard } from '../../guards/role.guard';

const routes: Routes = [
  {
    path: '',
    component: SettingsComponent,
    canActivate: [RoleGuard],
    data: { permissions: ['isAdmin'] },
    children: [
      {
        path: '',
        redirectTo: 'vehicle-makes',
        pathMatch: 'full',
      },
      {
        path: 'vehicle-makes',
        component: VehicleMakesComponent,
      },
      {
        path: 'vehicle-models',
        component: VehicleModelsComponent,
      },
      {
        path: 'user-roles',
        component: UserRolesComponent,
      },
      {
        path: 'system-preferences',
        component: SystemPreferencesComponent,
      },
    ],
  },
];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule],
})
export class SettingsRoutingModule {}


--- ./src/app/pages/settings/settings.component.ts ---
import { Component, OnInit } from '@angular/core';
import { Router } from '@angular/router';
import { AuthService } from '../../services/auth.service';

interface SettingsNavItem {
  label: string;
  route: string;
  icon: string;
  description: string;
}

@Component({
  selector: 'app-settings',
  templateUrl: './settings.component.html',
  styleUrls: ['./settings.component.scss'],
  standalone: false,
})
export class SettingsComponent implements OnInit {
  navItems: SettingsNavItem[] = [
    {
      label: 'Vehicle Makes',
      route: '/settings/vehicle-makes',
      icon: 'directions_car',
      description: 'Manage vehicle manufacturers and brands',
    },
    {
      label: 'Vehicle Models',
      route: '/settings/vehicle-models',
      icon: 'model_training',
      description: 'Manage vehicle models associated with makes',
    },
    {
      label: 'User Roles',
      route: '/settings/user-roles',
      icon: 'admin_panel_settings',
      description: 'Configure user roles and permissions',
    },
    {
      label: 'System Preferences',
      route: '/settings/system-preferences',
      icon: 'settings',
      description: 'Global application settings and preferences',
    },
  ];

  isAdmin = false;
  currentYear = new Date().getFullYear();
  appVersion = '1.0.0';

  constructor(private router: Router, private authService: AuthService) {}

  ngOnInit(): void {
    this.authService.isAdmin().subscribe((isAdmin) => {
      this.isAdmin = isAdmin;

      // If not admin, redirect to home
      if (!isAdmin) {
        this.router.navigate(['/']);
      }
    });
  }

  isActive(route: string): boolean {
    return this.router.isActive(route, true);
  }
}


--- ./src/app/pages/settings/settings.module.ts ---
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule } from '@angular/forms';

import { SettingsRoutingModule } from './settings-routing.module';
import { MaterialModule } from '../../material.module';

import { SettingsComponent } from './settings.component';
import { VehicleMakesComponent } from './vehicle-makes/vehicle-makes.component';
import { VehicleModelsComponent } from './vehicle-models/vehicle-models.component';
import { UserRolesComponent } from './user-roles/user-roles.component';
import { SystemPreferencesComponent } from './system-preferences/system-preferences.component';
import { VehicleMakeDialogComponent } from './vehicle-makes/vehicle-make-dialog/vehicle-make-dialog.component';
import { VehicleModelDialogComponent } from './vehicle-models/vehicle-model-dialog/vehicle-model-dialog.component';
import { UserRoleDialogComponent } from './user-roles/user-role-dialog/user-role-dialog.component';

@NgModule({
  declarations: [
    SettingsComponent,
    VehicleMakesComponent,
    VehicleModelsComponent,
    UserRolesComponent,
    SystemPreferencesComponent,
    VehicleMakeDialogComponent,
    VehicleModelDialogComponent,
    UserRoleDialogComponent,
  ],
  imports: [CommonModule, SettingsRoutingModule, MaterialModule, ReactiveFormsModule],
})
export class SettingsModule {}


--- ./src/app/pages/settings/settings.component.scss ---
:host {
  display: block;
  padding: 24px;
  background-color: #f5f5f5;
  min-height: 100vh;
  margin-left: 250px; /* Account for sidebar width */
  padding-top: 88px; /* Account for topbar height (64px) + some padding */
}

.settings-container {
  display: flex;
  max-width: 1400px;
  margin: 0 auto;
  height: calc(100vh - 112px); /* Full height minus padding and topbar */
  gap: 24px;
}

.settings-sidebar {
  width: 280px;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  display: flex;
  flex-direction: column;
  flex-shrink: 0;
  overflow: hidden;
}

.sidebar-header {
  padding: 24px;
  border-bottom: 1px solid rgba(0, 0, 0, 0.08);

  h2 {
    margin: 0;
    font-size: 18px;
    font-weight: 600;
    color: var(--primary-color);
  }

  .sidebar-subtitle {
    margin: 4px 0 0;
    font-size: 14px;
    color: rgba(0, 0, 0, 0.6);
  }
}

.navigation-list {
  padding: 16px 0;
  flex: 1;
  overflow-y: auto;

  .nav-item {
    position: relative;
    cursor: pointer;
    transition: background-color 0.2s ease;

    &:hover {
      background-color: rgba(0, 0, 0, 0.04);
    }

    &.active {
      background-color: rgba(var(--primary-color-rgb), 0.08);

      &::before {
        content: '';
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 4px;
        background-color: var(--primary-color);
      }

      .nav-label {
        color: var(--primary-color);
        font-weight: 500;
      }

      .nav-icon {
        color: var(--primary-color);
      }
    }

    .nav-item-content {
      display: flex;
      align-items: center;
      padding: 16px 24px;
      gap: 16px;
    }

    .nav-icon {
      color: rgba(0, 0, 0, 0.54);
    }

    .nav-text {
      display: flex;
      flex-direction: column;
    }

    .nav-label {
      font-size: 14px;
      font-weight: 400;
      color: rgba(0, 0, 0, 0.87);
    }

    .nav-description {
      font-size: 12px;
      color: rgba(0, 0, 0, 0.6);
      margin-top: 2px;
    }
  }
}

.sidebar-footer {
  padding: 16px 24px;
  border-top: 1px solid rgba(0, 0, 0, 0.08);
  text-align: center;

  .version-info,
  .copyright {
    margin: 0;
    font-size: 12px;
    color: rgba(0, 0, 0, 0.6);
    line-height: 1.5;
  }
}

.settings-content {
  flex: 1;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

/* Responsive styles */
@media screen and (max-width: 1024px) {
  .settings-container {
    flex-direction: column;
    height: auto;
  }

  .settings-sidebar {
    width: 100%;
  }

  .navigation-list {
    display: flex;
    flex-wrap: wrap;
    padding: 8px;

    .nav-item {
      width: calc(50% - 8px);

      &.active::before {
        width: 0;
        height: 4px;
        left: 0;
        right: 0;
        top: 0;
        bottom: auto;
      }
    }
  }
}

@media screen and (max-width: 768px) {
  :host {
    margin-left: 60px; /* Account for collapsed sidebar */
    padding: 16px;
    padding-top: 80px;
  }

  .settings-container {
    gap: 16px;
  }

  .navigation-list .nav-item {
    width: 100%;
  }
}

@media screen and (max-width: 480px) {
  :host {
    padding: 12px;
    padding-top: 76px;
  }

  .sidebar-header,
  .nav-item-content {
    padding: 12px 16px;
  }
}


--- ./src/app/pages/settings/settings.component.html ---
<div class="settings-container">
  <div class="settings-sidebar">
    <div class="sidebar-header">
      <h2>Settings</h2>
      <p class="sidebar-subtitle">System configuration</p>
    </div>

    <div class="navigation-list">
      <div *ngFor="let item of navItems" class="nav-item" [routerLink]="item.route" routerLinkActive="active" [routerLinkActiveOptions]="{ exact: true }">
        <div class="nav-item-content">
          <mat-icon class="nav-icon">{{ item.icon }}</mat-icon>
          <div class="nav-text">
            <span class="nav-label">{{ item.label }}</span>
            <span class="nav-description">{{ item.description }}</span>
          </div>
        </div>
      </div>
    </div>

    <div class="sidebar-footer">
      <p class="version-info">v{{ appVersion }}</p>
      <p class="copyright">&copy; {{ currentYear }} Logistics System</p>
    </div>
  </div>

  <div class="settings-content">
    <router-outlet></router-outlet>
  </div>
</div>


--- ./src/app/pages/settings/user-roles/user-roles.component.ts ---
import { Component, OnInit, ViewChild } from '@angular/core';
import { MatDialog } from '@angular/material/dialog';
import { MatPaginator } from '@angular/material/paginator';
import { MatSort } from '@angular/material/sort';
import { MatTableDataSource } from '@angular/material/table';
import { finalize } from 'rxjs/operators';
import { ConfirmationDialogComponent } from '../../../dialogs/confirmation-dialog.component';
import { UserRoleDialogComponent } from './user-role-dialog/user-role-dialog.component';
import { NotificationService } from '../../../services/notification.service';
import { Firestore, collection, doc, addDoc, updateDoc, deleteDoc, DocumentReference, query, getDocs, where, orderBy } from '@angular/fire/firestore';
import { Observable, from } from 'rxjs';

interface UserRole {
  id: string;
  name: string;
  description: string;
  permissions: Record<string, boolean>;
  isSystem: boolean; // Whether this is a system-defined role
  createdAt: Date;
  updatedAt: Date;
  userCount: number;
}

@Component({
  selector: 'app-user-roles',
  templateUrl: './user-roles.component.html',
  styleUrls: ['./user-roles.component.scss'],
  standalone: false,
})
export class UserRolesComponent implements OnInit {
  displayedColumns: string[] = ['name', 'description', 'permissions', 'userCount', 'actions'];
  dataSource = new MatTableDataSource<UserRole>([]);
  isLoading = false;
  totalRoles = 0;
  systemRoles = 0;
  customRoles = 0;

  // Reference list of all possible permissions
  allPermissions: { key: string; name: string; description: string }[] = [
    { key: 'canAllocateJobs', name: 'Allocate Jobs', description: 'Assign jobs to drivers' },
    { key: 'canApproveExpenses', name: 'Approve Expenses', description: 'Review and approve expense claims' },
    { key: 'canCreateJobs', name: 'Create Jobs', description: 'Create new jobs in the system' },
    { key: 'canEditJobs', name: 'Edit Jobs', description: 'Modify existing job details' },
    { key: 'canManageUsers', name: 'Manage Users', description: 'Create, edit, and delete users' },
    { key: 'canViewReports', name: 'View Reports', description: 'Access system reports and analytics' },
    { key: 'canViewUnallocated', name: 'View Unallocated Jobs', description: 'See jobs not assigned to a driver' },
    { key: 'isAdmin', name: 'Administrator', description: 'Full system access' },
  ];

  @ViewChild(MatPaginator) paginator!: MatPaginator;
  @ViewChild(MatSort) sort!: MatSort;

  constructor(private dialog: MatDialog, private notificationService: NotificationService, private firestore: Firestore) {}

  ngOnInit(): void {
    this.loadUserRoles();
  }

  ngAfterViewInit() {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
  }

  loadUserRoles(): void {
    this.isLoading = true;

    // Get roles from Firestore
    const rolesRef = collection(this.firestore, 'userRoles');
    const q = query(rolesRef, orderBy('name'));

    from(getDocs(q))
      .pipe(finalize(() => (this.isLoading = false)))
      .subscribe({
        next: (snapshot) => {
          const roles = snapshot.docs.map((doc) => {
            const data = doc.data();
            return {
              id: doc.id,
              name: data['name'] || '',
              description: data['description'] || '',
              permissions: data['permissions'] || {},
              isSystem: data['isSystem'] || false,
              createdAt: this.convertTimestamp(data['createdAt']),
              updatedAt: this.convertTimestamp(data['updatedAt']),
              userCount: data['userCount'] || 0,
            } as UserRole;
          });

          this.dataSource.data = roles;
          this.calculateStats(roles);
        },
        error: (error) => {
          console.error('Error loading user roles:', error);
          this.notificationService.addNotification({
            type: 'error',
            title: 'Error',
            message: 'Failed to load user roles',
          });
        },
      });
  }

  calculateStats(roles: UserRole[]): void {
    this.totalRoles = roles.length;
    this.systemRoles = roles.filter((role) => role.isSystem).length;
    this.customRoles = roles.filter((role) => !role.isSystem).length;
  }

  applyFilter(event: Event): void {
    const filterValue = (event.target as HTMLInputElement).value;
    this.dataSource.filter = filterValue.trim().toLowerCase();

    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage();
    }
  }

  addUserRole(): void {
    const dialogRef = this.dialog.open(UserRoleDialogComponent, {
      width: '700px',
      data: {
        isEdit: false,
        allPermissions: this.allPermissions,
      },
    });

    dialogRef.afterClosed().subscribe((result) => {
      if (result) {
        this.isLoading = true;
        this.createUserRole(result)
          .pipe(finalize(() => (this.isLoading = false)))
          .subscribe({
            next: () => {
              this.notificationService.addNotification({
                type: 'success',
                title: 'Success',
                message: `Role "${result.name}" created successfully`,
              });
              this.loadUserRoles();
            },
            error: (error) => {
              console.error('Error creating user role:', error);
              this.notificationService.addNotification({
                type: 'error',
                title: 'Error',
                message: 'Failed to create user role',
              });
            },
          });
      }
    });
  }

  editUserRole(role: UserRole): void {
    const dialogRef = this.dialog.open(UserRoleDialogComponent, {
      width: '700px',
      data: {
        isEdit: true,
        role: role,
        allPermissions: this.allPermissions,
      },
    });

    dialogRef.afterClosed().subscribe((result) => {
      if (result) {
        this.isLoading = true;
        this.updateUserRole(role.id, result)
          .pipe(finalize(() => (this.isLoading = false)))
          .subscribe({
            next: () => {
              this.notificationService.addNotification({
                type: 'success',
                title: 'Success',
                message: `Role "${result.name}" updated successfully`,
              });
              this.loadUserRoles();
            },
            error: (error) => {
              console.error('Error updating user role:', error);
              this.notificationService.addNotification({
                type: 'error',
                title: 'Error',
                message: 'Failed to update user role',
              });
            },
          });
      }
    });
  }

  deleteUserRole(role: UserRole): void {
    // Don't allow deletion of system roles
    if (role.isSystem) {
      this.notificationService.addNotification({
        type: 'warning',
        title: 'Cannot Delete',
        message: 'System-defined roles cannot be deleted',
      });
      return;
    }

    // Also check if there are users assigned to this role
    if (role.userCount > 0) {
      this.notificationService.addNotification({
        type: 'warning',
        title: 'Cannot Delete',
        message: `Role "${role.name}" has ${role.userCount} users assigned to it`,
      });
      return;
    }

    const dialogRef = this.dialog.open(ConfirmationDialogComponent, {
      width: '400px',
      data: {
        title: 'Delete Role',
        message: `Are you sure you want to delete the role "${role.name}"? This action cannot be undone.`,
        confirmText: 'Delete',
        cancelText: 'Cancel',
        confirmColor: 'warn',
      },
    });

    dialogRef.afterClosed().subscribe((confirmed) => {
      if (confirmed) {
        this.isLoading = true;
        this.deleteRole(role.id)
          .pipe(finalize(() => (this.isLoading = false)))
          .subscribe({
            next: () => {
              this.notificationService.addNotification({
                type: 'success',
                title: 'Success',
                message: `Role "${role.name}" deleted successfully`,
              });
              this.loadUserRoles();
            },
            error: (error) => {
              console.error('Error deleting role:', error);
              this.notificationService.addNotification({
                type: 'error',
                title: 'Error',
                message: 'Failed to delete role',
              });
            },
          });
      }
    });
  }

  // Get list of active permission names for a role
  getPermissionsList(permissions: Record<string, boolean>): string {
    if (!permissions) return 'None';

    const activePermissions = Object.entries(permissions)
      .filter(([_, value]) => value)
      .map(([key, _]) => {
        const foundPermission = this.allPermissions.find((p) => p.key === key);
        return foundPermission ? foundPermission.name : key;
      });

    return activePermissions.length > 0 ? activePermissions.join(', ') : 'None';
  }

  // Firestore Operations
  private createUserRole(roleData: any): Observable<DocumentReference> {
    const rolesRef = collection(this.firestore, 'userRoles');
    const now = new Date();

    const newRole = {
      ...roleData,
      isSystem: false,
      createdAt: now,
      updatedAt: now,
      userCount: 0,
    };

    return from(addDoc(rolesRef, newRole));
  }

  private updateUserRole(roleId: string, roleData: any): Observable<void> {
    const roleRef = doc(this.firestore, `userRoles/${roleId}`);

    const updateData = {
      ...roleData,
      updatedAt: new Date(),
    };

    return from(updateDoc(roleRef, updateData));
  }

  private deleteRole(roleId: string): Observable<void> {
    const roleRef = doc(this.firestore, `userRoles/${roleId}`);
    return from(deleteDoc(roleRef));
  }

  // Helper function to convert Firestore timestamp to Date
  private convertTimestamp(timestamp: any): Date {
    if (!timestamp) return new Date();

    if (timestamp && typeof timestamp === 'object' && 'toDate' in timestamp) {
      return timestamp.toDate();
    }

    return new Date(timestamp);
  }
}


--- ./src/app/pages/settings/user-roles/user-roles.component.html ---
<div class="settings-page">
  <div class="settings-header">
    <div class="header-title">
      <h1>User Roles</h1>
      <p class="subtitle">Manage roles and permissions in the system</p>
    </div>
    <div class="header-actions">
      <button mat-flat-button color="primary" (click)="addUserRole()">
        <mat-icon>add</mat-icon>
        Create Role
      </button>
    </div>
  </div>

  <!-- Stats Cards -->
  <div class="stats-cards">
    <mat-card class="stat-card">
      <mat-icon>badge</mat-icon>
      <div class="stat-content">
        <span class="stat-value">{{ totalRoles }}</span>
        <span class="stat-label">Total Roles</span>
      </div>
    </mat-card>

    <mat-card class="stat-card">
      <mat-icon class="system-icon">security</mat-icon>
      <div class="stat-content">
        <span class="stat-value">{{ systemRoles }}</span>
        <span class="stat-label">System Roles</span>
      </div>
    </mat-card>

    <mat-card class="stat-card">
      <mat-icon class="custom-icon">edit_note</mat-icon>
      <div class="stat-content">
        <span class="stat-value">{{ customRoles }}</span>
        <span class="stat-label">Custom Roles</span>
      </div>
    </mat-card>
  </div>

  <!-- Table Section -->
  <mat-card class="table-card">
    <div class="filters-row">
      <mat-form-field appearance="outline">
        <mat-label>Filter Roles</mat-label>
        <input matInput (keyup)="applyFilter($event)" placeholder="Search by name, description..." />
        <mat-icon matSuffix>search</mat-icon>
      </mat-form-field>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" *ngIf="isLoading">
      <mat-spinner diameter="40"></mat-spinner>
      <span>Loading user roles...</span>
    </div>

    <div class="table-container">
      <table mat-table [dataSource]="dataSource" matSort>
        <!-- Name Column -->
        <ng-container matColumnDef="name">
          <th mat-header-cell *matHeaderCellDef mat-sort-header>Role</th>
          <td mat-cell *matCellDef="let role">
            <div class="role-name">
              <span>{{ role.name }}</span>
              <span class="role-badge" *ngIf="role.isSystem">System</span>
            </div>
          </td>
        </ng-container>

        <!-- Description Column -->
        <ng-container matColumnDef="description">
          <th mat-header-cell *matHeaderCellDef mat-sort-header>Description</th>
          <td mat-cell *matCellDef="let role">{{ role.description }}</td>
        </ng-container>

        <!-- Permissions Column -->
        <ng-container matColumnDef="permissions">
          <th mat-header-cell *matHeaderCellDef>Permissions</th>
          <td mat-cell *matCellDef="let role">
            <div class="permissions-list-cell">
              {{ getPermissionsList(role.permissions) }}
            </div>
          </td>
        </ng-container>

        <!-- User Count Column -->
        <ng-container matColumnDef="userCount">
          <th mat-header-cell *matHeaderCellDef mat-sort-header>Users</th>
          <td mat-cell *matCellDef="let role">
            <span class="user-count">{{ role.userCount }}</span>
          </td>
        </ng-container>

        <!-- Actions Column -->
        <ng-container matColumnDef="actions">
          <th mat-header-cell *matHeaderCellDef>Actions</th>
          <td mat-cell *matCellDef="let role">
            <button mat-icon-button [matMenuTriggerFor]="menu" aria-label="Actions">
              <mat-icon>more_vert</mat-icon>
            </button>
            <mat-menu #menu="matMenu">
              <button mat-menu-item (click)="editUserRole(role)">
                <mat-icon>edit</mat-icon>
                <span>Edit</span>
              </button>
              <button mat-menu-item (click)="deleteUserRole(role)" [disabled]="role.isSystem || role.userCount > 0">
                <mat-icon>delete</mat-icon>
                <span>Delete</span>
              </button>
            </mat-menu>
          </td>
        </ng-container>

        <!-- Table Setup -->
        <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
        <tr mat-row *matRowDef="let row; columns: displayedColumns"></tr>

        <!-- When no data matches the filter -->
        <tr class="mat-row" *matNoDataRow>
          <td class="mat-cell no-data-cell" [attr.colspan]="displayedColumns.length">
            <div class="no-data-message">
              <mat-icon>search_off</mat-icon>
              <span>No user roles found</span>
            </div>
          </td>
        </tr>
      </table>
    </div>

    <!-- Paginator -->
    <mat-paginator [pageSizeOptions]="[5, 10, 25]" showFirstLastButtons></mat-paginator>
  </mat-card>
</div>


--- ./src/app/pages/settings/user-roles/user-roles.component.scss ---
.settings-page {
  padding: 24px;
  height: 100%;
  display: flex;
  flex-direction: column;
}

.settings-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 24px;

  .header-title {
    h1 {
      margin: 0;
      font-size: 24px;
      font-weight: 500;
      color: var(--primary-color);
    }

    .subtitle {
      margin: 4px 0 0;
      color: rgba(0, 0, 0, 0.6);
      font-size: 14px;
    }
  }

  .header-actions {
    button {
      display: flex;
      align-items: center;
      gap: 8px;
    }
  }
}

.stats-cards {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 20px;
  margin-bottom: 24px;

  .stat-card {
    display: flex;
    align-items: center;
    padding: 20px;
    border-radius: 8px;

    mat-icon {
      font-size: 32px;
      height: 32px;
      width: 32px;
      margin-right: 16px;
      color: var(--primary-color);

      &.system-icon {
        color: #4285f4; // Google blue
      }

      &.custom-icon {
        color: #4caf50; // Material green
      }
    }

    .stat-content {
      display: flex;
      flex-direction: column;

      .stat-value {
        font-size: 28px;
        font-weight: 600;
        color: rgba(0, 0, 0, 0.87);
        line-height: 1.2;
      }

      .stat-label {
        font-size: 14px;
        color: rgba(0, 0, 0, 0.6);
      }
    }
  }
}

.table-card {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;

  .filters-row {
    padding: 16px 16px 0;

    mat-form-field {
      width: 100%;
      max-width: 400px;
    }
  }
}

.table-container {
  position: relative;
  flex: 1;
  overflow: auto;

  table {
    width: 100%;
    min-width: 800px;
  }

  .mat-mdc-header-row {
    background-color: #f5f5f5;
  }

  .mat-mdc-header-cell {
    font-weight: 500;
    color: rgba(0, 0, 0, 0.6);
    white-space: nowrap;
  }

  .no-data-cell {
    padding: 48px 0;
  }

  .no-data-message {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;

    mat-icon {
      font-size: 48px;
      height: 48px;
      width: 48px;
      margin-bottom: 16px;
      color: rgba(0, 0, 0, 0.3);
    }

    span {
      font-size: 16px;
      color: rgba(0, 0, 0, 0.6);
    }
  }
}

.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.8);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 10;

  span {
    margin-top: 16px;
    color: rgba(0, 0, 0, 0.6);
  }
}

.role-name {
  display: flex;
  align-items: center;
  gap: 8px;

  .role-badge {
    font-size: 11px;
    padding: 2px 6px;
    border-radius: 4px;
    background-color: rgba(66, 133, 244, 0.1);
    color: #4285f4;
    font-weight: 500;
    text-transform: uppercase;
  }
}

.permissions-list-cell {
  max-width: 300px;
  white-space: normal;
  line-height: 1.4;
}

.user-count {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  min-width: 28px;
  height: 28px;
  border-radius: 14px;
  background-color: rgba(0, 0, 0, 0.08);
  color: rgba(0, 0, 0, 0.87);
  font-weight: 500;
  padding: 0 8px;
}

/* Responsive adjustments */
@media screen and (max-width: 992px) {
  .stats-cards {
    grid-template-columns: repeat(2, 1fr);

    .stat-card:last-child {
      grid-column: span 2;
    }
  }
}

@media screen and (max-width: 768px) {
  .settings-header {
    flex-direction: column;
    gap: 16px;

    .header-actions {
      width: 100%;

      button {
        width: 100%;
      }
    }
  }

  .stats-cards {
    grid-template-columns: 1fr;

    .stat-card:last-child {
      grid-column: span 1;
    }
  }
}

@media screen and (max-width: 480px) {
  .settings-page {
    padding: 16px;
  }

  .table-card,
  .stat-card {
    border-radius: 4px;
  }

  .filters-row {
    padding: 12px 12px 0;
  }
}


--- ./src/app/pages/settings/user-roles/user-role-dialog/user-role-dialog.component.ts ---
import { Component, Inject, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { MAT_DIALOG_DATA, MatDialogRef } from '@angular/material/dialog';

interface PermissionInfo {
  key: string;
  name: string;
  description: string;
}

interface UserRole {
  id: string;
  name: string;
  description: string;
  permissions: Record<string, boolean>;
  isSystem: boolean;
  createdAt: Date;
  updatedAt: Date;
  userCount: number;
}

interface DialogData {
  isEdit: boolean;
  role?: UserRole;
  allPermissions: PermissionInfo[];
}

@Component({
  selector: 'app-user-role-dialog',
  templateUrl: './user-role-dialog.component.html',
  styleUrls: ['./user-role-dialog.component.scss'],
  standalone: false,
})
export class UserRoleDialogComponent implements OnInit {
  roleForm!: FormGroup;
  isEdit: boolean;
  allPermissions: PermissionInfo[] = [];

  // Special permission keys that have precedence
  specialPermissions = ['isAdmin'];

  // Group permissions by functionality
  permissionGroups = [
    {
      title: 'General Permissions',
      permissions: ['isAdmin'],
    },
    {
      title: 'Job Management',
      permissions: ['canCreateJobs', 'canEditJobs', 'canAllocateJobs', 'canViewUnallocated'],
    },
    {
      title: 'Administrative',
      permissions: ['canManageUsers', 'canViewReports', 'canApproveExpenses'],
    },
  ];

  constructor(private fb: FormBuilder, public dialogRef: MatDialogRef<UserRoleDialogComponent>, @Inject(MAT_DIALOG_DATA) public data: DialogData) {
    this.isEdit = data.isEdit;
    this.allPermissions = data.allPermissions;
  }

  ngOnInit(): void {
    this.createForm();
  }

  createForm(): void {
    // Create base form
    this.roleForm = this.fb.group({
      name: ['', [Validators.required, Validators.minLength(3), Validators.maxLength(50)]],
      description: ['', [Validators.required, Validators.maxLength(200)]],
    });

    // Add permission controls
    const permissionsGroup = this.fb.group({});

    this.allPermissions.forEach((permission) => {
      permissionsGroup.addControl(permission.key, this.fb.control(false));
    });

    this.roleForm.addControl('permissions', permissionsGroup);

    if (this.isEdit && this.data.role) {
      this.roleForm.patchValue({
        name: this.data.role.name,
        description: this.data.role.description,
      });

      // Patch permissions
      const permissionsValue: Record<string, boolean> = {};
      this.allPermissions.forEach((permission) => {
        permissionsValue[permission.key] = this.data.role?.permissions?.[permission.key] || false;
      });

      this.roleForm.get('permissions')?.patchValue(permissionsValue);
    }
  }

  onSubmit(): void {
    if (this.roleForm.invalid) {
      return;
    }

    const formValue = this.roleForm.value;

    const roleData = {
      name: formValue.name,
      description: formValue.description,
      permissions: formValue.permissions,
    };

    this.dialogRef.close(roleData);
  }

  onCancel(): void {
    this.dialogRef.close();
  }

  // When admin permission is selected, manage other permissions
  onAdminChange(event: any): void {
    const isAdmin = event.checked;
    const permissionsGroup = this.roleForm.get('permissions') as FormGroup;

    if (isAdmin) {
      // If admin is enabled, enable all other permissions
      this.allPermissions.forEach((permission) => {
        if (permission.key !== 'isAdmin') {
          permissionsGroup.get(permission.key)?.setValue(true);
          permissionsGroup.get(permission.key)?.disable();
        }
      });
    } else {
      // If admin is disabled, enable editing other permissions but keep values
      this.allPermissions.forEach((permission) => {
        if (permission.key !== 'isAdmin') {
          permissionsGroup.get(permission.key)?.enable();
        }
      });
    }
  }

  // Get permissions for a specific group
  getGroupPermissions(groupKey: string): PermissionInfo[] {
    const group = this.permissionGroups.find((g) => g.title === groupKey);
    if (!group) return [];

    return this.allPermissions.filter((p) => group.permissions.includes(p.key));
  }

  // Check if permission should be treated as special (e.g., Admin)
  isSpecialPermission(key: string): boolean {
    return this.specialPermissions.includes(key);
  }
}


--- ./src/app/pages/settings/user-roles/user-role-dialog/user-role-dialog.component.scss ---
.dialog-content {
  display: flex;
  flex-direction: column;
  gap: 24px;
  padding: 0 8px;
  max-height: 70vh;
  overflow-y: auto;
  min-width: 500px;
}

.form-section {
  display: flex;
  flex-direction: column;
  gap: 16px;

  .section-title {
    font-size: 16px;
    font-weight: 500;
    color: var(--primary-color);
    margin: 0;
  }

  .section-description {
    font-size: 14px;
    color: rgba(0, 0, 0, 0.6);
    margin: -8px 0 8px;
  }
}

.full-width {
  width: 100%;
}

.permissions-container {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.special-permission {
  display: flex;
  flex-direction: column;
  padding: 16px;
  background-color: rgba(66, 133, 244, 0.05);
  border-radius: 8px;
  border-left: 4px solid #4285f4;
  margin-bottom: 16px;

  .permission-name {
    font-weight: 500;
  }

  .permission-description {
    font-size: 13px;
    color: rgba(0, 0, 0, 0.6);
    margin-top: 4px;
    margin-left: 24px; // Aligns with checkbox text
  }
}

.permissions-accordion {
  .mat-expansion-panel {
    margin-bottom: 16px;

    &:last-child {
      margin-bottom: 0;
    }
  }

  .mat-expansion-panel-header {
    height: 48px;
  }

  .mat-expansion-panel-header-title {
    color: rgba(0, 0, 0, 0.87);
    font-weight: 500;
  }

  .group-icon {
    margin-right: 8px;
    color: rgba(0, 0, 0, 0.54);
  }
}

.permission-item {
  display: flex;
  flex-direction: column;
  padding: 8px 0;
  border-bottom: 1px solid rgba(0, 0, 0, 0.08);

  &:last-child {
    border-bottom: none;
  }

  .permission-name {
    font-weight: 500;
  }

  .permission-description {
    font-size: 13px;
    color: rgba(0, 0, 0, 0.6);
    margin-top: 4px;
    margin-left: 24px; // Aligns with checkbox text
  }
}

/* Responsive styles */
@media screen and (max-width: 599px) {
  .dialog-content {
    min-width: unset;
  }

  .special-permission,
  .permission-item {
    padding: 12px 8px;
  }
}


--- ./src/app/pages/settings/user-roles/user-role-dialog/user-role-dialog.component.html ---
<h2 mat-dialog-title>{{ isEdit ? 'Edit' : 'Create' }} User Role</h2>

<form [formGroup]="roleForm" (ngSubmit)="onSubmit()">
  <mat-dialog-content>
    <div class="dialog-content">
      <!-- Basic Information Section -->
      <div class="form-section">
        <h3 class="section-title">Role Information</h3>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Role Name</mat-label>
          <input matInput formControlName="name" placeholder="e.g. Dispatcher" />
          <mat-hint>A unique name to identify this role</mat-hint>
          <mat-error *ngIf="roleForm.get('name')?.hasError('required')"> Role name is required </mat-error>
          <mat-error *ngIf="roleForm.get('name')?.hasError('minlength')"> Role name must be at least 3 characters </mat-error>
          <mat-error *ngIf="roleForm.get('name')?.hasError('maxlength')"> Role name cannot exceed 50 characters </mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Description</mat-label>
          <textarea matInput formControlName="description" placeholder="Describe the role's purpose" rows="3"></textarea>
          <mat-hint>What this role is for and who should have it</mat-hint>
          <mat-error *ngIf="roleForm.get('description')?.hasError('required')"> Description is required </mat-error>
          <mat-error *ngIf="roleForm.get('description')?.hasError('maxlength')"> Description cannot exceed 200 characters </mat-error>
        </mat-form-field>
      </div>

      <!-- Permissions Section -->
      <div class="form-section">
        <h3 class="section-title">Permissions</h3>
        <p class="section-description">Configure what users with this role can do in the system</p>

        <div formGroupName="permissions" class="permissions-container">
          <!-- Admin Permission (Special) -->
          <div class="special-permission" *ngFor="let permission of getGroupPermissions('General Permissions')">
            <mat-checkbox [formControlName]="permission.key" color="primary" (change)="onAdminChange($event)">
              <span class="permission-name">{{ permission.name }}</span>
            </mat-checkbox>
            <span class="permission-description">{{ permission.description }} <strong>(Grants all permissions)</strong></span>
          </div>

          <!-- Grouped Permissions -->
          <mat-accordion class="permissions-accordion">
            <!-- Job Management Permissions -->
            <mat-expansion-panel expanded>
              <mat-expansion-panel-header>
                <mat-panel-title>
                  <mat-icon class="group-icon">work</mat-icon>
                  Job Management
                </mat-panel-title>
              </mat-expansion-panel-header>

              <div class="permission-item" *ngFor="let permission of getGroupPermissions('Job Management')">
                <mat-checkbox [formControlName]="permission.key" color="primary">
                  <span class="permission-name">{{ permission.name }}</span>
                </mat-checkbox>
                <span class="permission-description">{{ permission.description }}</span>
              </div>
            </mat-expansion-panel>

            <!-- Administrative Permissions -->
            <mat-expansion-panel expanded>
              <mat-expansion-panel-header>
                <mat-panel-title>
                  <mat-icon class="group-icon">admin_panel_settings</mat-icon>
                  Administrative
                </mat-panel-title>
              </mat-expansion-panel-header>

              <div class="permission-item" *ngFor="let permission of getGroupPermissions('Administrative')">
                <mat-checkbox [formControlName]="permission.key" color="primary">
                  <span class="permission-name">{{ permission.name }}</span>
                </mat-checkbox>
                <span class="permission-description">{{ permission.description }}</span>
              </div>
            </mat-expansion-panel>
          </mat-accordion>
        </div>
      </div>
    </div>
  </mat-dialog-content>

  <mat-dialog-actions align="end">
    <button mat-button type="button" (click)="onCancel()">Cancel</button>
    <button mat-flat-button color="primary" type="submit" [disabled]="roleForm.invalid">
      {{ isEdit ? 'Update' : 'Create' }}
    </button>
  </mat-dialog-actions>
</form>


--- ./src/app/pages/settings/system-preferences/system-preferences.component.scss ---
.settings-page {
  padding: 24px;
  height: 100%;
  display: flex;
  flex-direction: column;
}

.settings-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 24px;

  .header-title {
    h1 {
      margin: 0;
      font-size: 24px;
      font-weight: 500;
      color: var(--primary-color);
    }

    .subtitle {
      margin: 4px 0 0;
      color: rgba(0, 0, 0, 0.6);
      font-size: 14px;
    }
  }

  .header-actions {
    button {
      display: flex;
      align-items: center;
      gap: 8px;
    }
  }
}

.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.8);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 10;

  span {
    margin-top: 16px;
    color: rgba(0, 0, 0, 0.6);
  }
}

.preferences-content {
  flex: 1;
}

.preferences-accordion {
  margin-bottom: 24px;

  .mat-expansion-panel {
    margin-bottom: 16px;

    &:last-child {
      margin-bottom: 0;
    }
  }

  .panel-title-content {
    display: flex;
    align-items: center;
    gap: 12px;

    mat-icon {
      color: var(--primary-color);
    }

    span {
      font-weight: 500;
      font-size: 16px;
    }
  }

  .mat-expansion-panel-header {
    height: 64px;
  }

  .mat-expansion-panel-header-description {
    color: rgba(0, 0, 0, 0.6);
  }
}

.preferences-form {
  padding: 16px 0;
}

.preferences-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 20px;
  margin-bottom: 24px;
}

.preference-item {
  width: 100%;

  mat-form-field {
    width: 100%;
  }
}

.toggle-control {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  padding: 8px 0;

  .toggle-label {
    display: flex;
    flex-direction: column;

    .toggle-name {
      font-weight: 500;
      font-size: 16px;
      margin-bottom: 4px;
    }

    .toggle-description {
      font-size: 14px;
      color: rgba(0, 0, 0, 0.6);
    }
  }
}

.form-actions {
  display: flex;
  justify-content: flex-end;

  button {
    min-width: 150px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
  }
}

/* Responsive adjustments */
@media screen and (max-width: 992px) {
  .preferences-grid {
    grid-template-columns: 1fr;
  }
}

@media screen and (max-width: 768px) {
  .settings-header {
    flex-direction: column;
    gap: 16px;

    .header-actions {
      width: 100%;

      button {
        width: 100%;
      }
    }
  }

  .mat-expansion-panel-header-description {
    display: none;
  }
}

@media screen and (max-width: 480px) {
  .settings-page {
    padding: 16px;
  }

  .toggle-control {
    flex-direction: column;
    gap: 12px;

    mat-slide-toggle {
      margin-left: auto;
    }
  }
}


--- ./src/app/pages/settings/system-preferences/system-preferences.component.html ---
<div class="settings-page">
  <div class="settings-header">
    <div class="header-title">
      <h1>System Preferences</h1>
      <p class="subtitle">Configure global application settings</p>
    </div>
    <div class="header-actions">
      <button mat-stroked-button color="warn" (click)="resetToDefaults()">
        <mat-icon>restore</mat-icon>
        Reset to Defaults
      </button>
    </div>
  </div>

  <!-- Loading Overlay -->
  <div class="loading-overlay" *ngIf="isLoading">
    <mat-spinner diameter="40"></mat-spinner>
    <span>Loading preferences...</span>
  </div>

  <!-- Preferences Content -->
  <div class="preferences-content" *ngIf="!isLoading">
    <mat-accordion class="preferences-accordion" multi>
      <mat-expansion-panel
        *ngFor="let group of preferenceGroups"
        [expanded]="expandedPanels[group.name]"
        (opened)="expandedPanels[group.name] = true"
        (closed)="expandedPanels[group.name] = false">
        <mat-expansion-panel-header>
          <mat-panel-title>
            <div class="panel-title-content">
              <mat-icon>{{ group.icon }}</mat-icon>
              <span>{{ group.name }}</span>
            </div>
          </mat-panel-title>
          <mat-panel-description>
            {{ group.description }}
          </mat-panel-description>
        </mat-expansion-panel-header>

        <!-- Group Form -->
        <form [formGroup]="preferenceForms[group.name]" class="preferences-form">
          <div class="preferences-grid">
            <div class="preference-item" *ngFor="let pref of group.preferences">
              <!-- String Input -->
              <mat-form-field appearance="outline" *ngIf="pref.type === 'string'">
                <mat-label>{{ pref.name }}</mat-label>
                <input matInput [formControlName]="pref.id" [placeholder]="pref.placeholder || ''" [required]="pref.required || false" />
                <mat-hint>{{ pref.description }}</mat-hint>
              </mat-form-field>

              <!-- Email Input -->
              <mat-form-field appearance="outline" *ngIf="pref.type === 'email'">
                <mat-label>{{ pref.name }}</mat-label>
                <input matInput type="email" [formControlName]="pref.id" [placeholder]="pref.placeholder || ''" [required]="pref.required || false" />
                <mat-hint>{{ pref.description }}</mat-hint>
                <mat-error *ngIf="preferenceForms[group.name].get(pref.id)?.hasError('email')"> Please enter a valid email address </mat-error>
              </mat-form-field>

              <!-- Number Input -->
              <mat-form-field appearance="outline" *ngIf="pref.type === 'number'">
                <mat-label>{{ pref.name }}</mat-label>
                <input matInput type="number" [formControlName]="pref.id" [placeholder]="pref.placeholder || ''" [required]="pref.required || false" />
                <mat-hint>{{ pref.description }}</mat-hint>
                <mat-error *ngIf="preferenceForms[group.name].get(pref.id)?.hasError('min')"> Value must be at least {{ pref.validation?.min }} </mat-error>
                <mat-error *ngIf="preferenceForms[group.name].get(pref.id)?.hasError('max')"> Value cannot exceed {{ pref.validation?.max }} </mat-error>
              </mat-form-field>

              <!-- Date Input -->
              <mat-form-field appearance="outline" *ngIf="pref.type === 'date'">
                <mat-label>{{ pref.name }}</mat-label>
                <input matInput [matDatepicker]="picker" [formControlName]="pref.id" [required]="pref.required || false" />
                <mat-datepicker-toggle matSuffix [for]="picker"></mat-datepicker-toggle>
                <mat-datepicker #picker></mat-datepicker>
                <mat-hint>{{ pref.description }}</mat-hint>
              </mat-form-field>

              <!-- Select Input -->
              <mat-form-field appearance="outline" *ngIf="pref.type === 'select'">
                <mat-label>{{ pref.name }}</mat-label>
                <mat-select [formControlName]="pref.id" [required]="pref.required || false">
                  <mat-option *ngFor="let option of pref.options" [value]="option">
                    {{ option }}
                  </mat-option>
                </mat-select>
                <mat-hint>{{ pref.description }}</mat-hint>
              </mat-form-field>

              <!-- Boolean Toggle -->
              <div class="toggle-control" *ngIf="pref.type === 'boolean'">
                <div class="toggle-label">
                  <span class="toggle-name">{{ pref.name }}</span>
                  <span class="toggle-description">{{ pref.description }}</span>
                </div>
                <mat-slide-toggle [formControlName]="pref.id" color="primary">
                  {{ preferenceForms[group.name].get(pref.id)?.value ? 'Enabled' : 'Disabled' }}
                </mat-slide-toggle>
              </div>
            </div>
          </div>

          <!-- Save Button -->
          <div class="form-actions">
            <button mat-flat-button color="primary" (click)="savePreferenceGroup(group.name)" [disabled]="preferenceForms[group.name].invalid || isSaving">
              <mat-icon>save</mat-icon>
              {{ isSaving ? 'Saving...' : 'Save ' + group.name + ' Settings' }}
            </button>
          </div>
        </form>
      </mat-expansion-panel>
    </mat-accordion>
  </div>
</div>


--- ./src/app/pages/settings/system-preferences/system-preferences.component.ts ---
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { MatSnackBar } from '@angular/material/snack-bar';
import { NotificationService } from '../../../services/notification.service';
import { Firestore, doc, getDoc, setDoc } from '@angular/fire/firestore';
import { finalize } from 'rxjs/operators';
import { from } from 'rxjs';

interface SystemPreference {
  id: string;
  name: string;
  value: any;
  type: 'string' | 'number' | 'boolean' | 'select' | 'email' | 'date';
  description: string;
  group: string;
  options?: string[];
  placeholder?: string;
  required?: boolean;
  validation?: {
    min?: number;
    max?: number;
    pattern?: string;
  };
  updatedAt?: Date;
}

interface PreferenceGroup {
  name: string;
  icon: string;
  description: string;
  preferences: SystemPreference[];
}

@Component({
  selector: 'app-system-preferences',
  templateUrl: './system-preferences.component.html',
  styleUrls: ['./system-preferences.component.scss'],
  standalone: false,
})
export class SystemPreferencesComponent implements OnInit {
  preferenceForms: { [key: string]: FormGroup } = {};
  preferenceGroups: PreferenceGroup[] = [];
  isLoading = false;
  isSaving = false;
  expandedPanels: { [key: string]: boolean } = {};

  constructor(private fb: FormBuilder, private firestore: Firestore, private snackBar: MatSnackBar, private notificationService: NotificationService) {}

  ngOnInit(): void {
    this.loadPreferences();
  }

  loadPreferences(): void {
    this.isLoading = true;

    // Get the system preferences document from Firestore
    const preferencesRef = doc(this.firestore, 'systemConfig/preferences');

    from(getDoc(preferencesRef))
      .pipe(finalize(() => (this.isLoading = false)))
      .subscribe({
        next: (docSnap) => {
          if (docSnap.exists()) {
            const preferences = this.mapPreferencesFromFirestore(docSnap.data());
            this.organizePreferencesByGroup(preferences);
            this.createPreferenceForms();

            // Set all panels to expanded by default
            this.preferenceGroups.forEach((group) => {
              this.expandedPanels[group.name] = true;
            });
          } else {
            // If the preferences document doesn't exist, create it with defaults
            this.createDefaultPreferences();
          }
        },
        error: (error) => {
          console.error('Error loading system preferences:', error);
          this.notificationService.addNotification({
            type: 'error',
            title: 'Error',
            message: 'Failed to load system preferences',
          });
        },
      });
  }

  private mapPreferencesFromFirestore(data: any): SystemPreference[] {
    const preferences: SystemPreference[] = [];

    // Convert the data object to an array of SystemPreference objects
    Object.entries(data).forEach(([id, preferenceData]: [string, any]) => {
      preferences.push({
        id,
        name: preferenceData.name || id,
        value: preferenceData.value,
        type: preferenceData.type || 'string',
        description: preferenceData.description || '',
        group: preferenceData.group || 'General',
        options: preferenceData.options || [],
        placeholder: preferenceData.placeholder,
        required: preferenceData.required !== undefined ? preferenceData.required : true,
        validation: preferenceData.validation || {},
        updatedAt: this.convertTimestamp(preferenceData.updatedAt),
      });
    });

    return preferences;
  }

  private organizePreferencesByGroup(preferences: SystemPreference[]): void {
    // Group the preferences by their group
    const groupMap: { [key: string]: SystemPreference[] } = {};

    preferences.forEach((pref) => {
      if (!groupMap[pref.group]) {
        groupMap[pref.group] = [];
      }
      groupMap[pref.group].push(pref);
    });

    // Create the PreferenceGroup objects
    this.preferenceGroups = Object.entries(groupMap).map(([groupName, prefs]) => {
      return {
        name: groupName,
        icon: this.getGroupIcon(groupName),
        description: this.getGroupDescription(groupName),
        preferences: prefs,
      };
    });

    // Sort the groups alphabetically, but put "General" first
    this.preferenceGroups.sort((a, b) => {
      if (a.name === 'General') return -1;
      if (b.name === 'General') return 1;
      return a.name.localeCompare(b.name);
    });
  }

  private createPreferenceForms(): void {
    // Create a form for each preference group
    this.preferenceGroups.forEach((group) => {
      const groupForm = this.fb.group({});

      group.preferences.forEach((pref) => {
        // Add validators based on preference settings
        const validators = [];

        if (pref.required) {
          validators.push(Validators.required);
        }

        if (pref.type === 'email') {
          validators.push(Validators.email);
        }

        if (pref.validation) {
          if (pref.validation.min !== undefined) {
            validators.push(Validators.min(pref.validation.min));
          }

          if (pref.validation.max !== undefined) {
            validators.push(Validators.max(pref.validation.max));
          }

          if (pref.validation.pattern) {
            validators.push(Validators.pattern(pref.validation.pattern));
          }
        }

        groupForm.addControl(pref.id, this.fb.control(pref.value, validators));
      });

      this.preferenceForms[group.name] = groupForm;
    });
  }

  savePreferenceGroup(groupName: string): void {
    const form = this.preferenceForms[groupName];

    if (form.invalid) {
      this.snackBar.open('Please fix the validation errors before saving', 'OK', {
        duration: 5000,
      });
      return;
    }

    this.isSaving = true;

    // Get the preferences in this group
    const group = this.preferenceGroups.find((g) => g.name === groupName);
    if (!group) return;

    // Create an object with all the preference values
    const preferencesRef = doc(this.firestore, 'systemConfig/preferences');
    const updateData: { [key: string]: any } = {};

    group.preferences.forEach((pref) => {
      const newValue = form.get(pref.id)?.value;

      updateData[pref.id] = {
        name: pref.name,
        value: newValue,
        type: pref.type,
        description: pref.description,
        group: pref.group,
        options: pref.options || [],
        placeholder: pref.placeholder,
        required: pref.required !== undefined ? pref.required : true,
        validation: pref.validation || {},
        updatedAt: new Date(),
      };
    });

    // Update the preferences in Firestore
    from(setDoc(preferencesRef, updateData, { merge: true }))
      .pipe(finalize(() => (this.isSaving = false)))
      .subscribe({
        next: () => {
          this.notificationService.addNotification({
            type: 'success',
            title: 'Success',
            message: `${groupName} preferences saved successfully`,
          });

          // Update the local data
          group.preferences.forEach((pref) => {
            pref.value = form.get(pref.id)?.value;
            pref.updatedAt = new Date();
          });
        },
        error: (error) => {
          console.error(`Error saving ${groupName} preferences:`, error);
          this.notificationService.addNotification({
            type: 'error',
            title: 'Error',
            message: `Failed to save ${groupName} preferences`,
          });
        },
      });
  }

  createDefaultPreferences(): void {
    // Define default system preferences
    const defaultPreferences: { [key: string]: any } = {
      company_name: {
        name: 'Company Name',
        value: 'My Logistics Company',
        type: 'string',
        description: 'Name of the company',
        group: 'General',
        required: true,
      },
      company_email: {
        name: 'Company Email',
        value: 'info@example.com',
        type: 'email',
        description: 'Primary contact email',
        group: 'General',
        required: true,
      },
      company_phone: {
        name: 'Company Phone',
        value: '+1 (555) 123-4567',
        type: 'string',
        description: 'Primary contact phone number',
        group: 'General',
        required: true,
      },
      currency: {
        name: 'Currency',
        value: 'USD',
        type: 'select',
        options: ['USD', 'EUR', 'GBP', 'CAD', 'AUD'],
        description: 'Default currency for the system',
        group: 'General',
        required: true,
      },
      date_format: {
        name: 'Date Format',
        value: 'MM/DD/YYYY',
        type: 'select',
        options: ['MM/DD/YYYY', 'DD/MM/YYYY', 'YYYY-MM-DD'],
        description: 'Format for displaying dates',
        group: 'Display',
        required: true,
      },
      time_format: {
        name: 'Time Format',
        value: '12h',
        type: 'select',
        options: ['12h', '24h'],
        description: 'Format for displaying times',
        group: 'Display',
        required: true,
      },
      default_language: {
        name: 'Default Language',
        value: 'English',
        type: 'select',
        options: ['English', 'Spanish', 'French', 'German'],
        description: 'Default language for the application',
        group: 'Display',
        required: true,
      },
      enable_notifications: {
        name: 'Enable Notifications',
        value: true,
        type: 'boolean',
        description: 'Enable system-wide notifications',
        group: 'Notifications',
        required: true,
      },
      email_notifications: {
        name: 'Email Notifications',
        value: true,
        type: 'boolean',
        description: 'Send notifications via email',
        group: 'Notifications',
        required: true,
      },
      expense_approval_required: {
        name: 'Expense Approval Required',
        value: true,
        type: 'boolean',
        description: 'Require approval for expenses',
        group: 'Finance',
        required: true,
      },
      expense_limit: {
        name: 'Expense Limit',
        value: 500,
        type: 'number',
        description: 'Maximum amount for expenses without additional approval',
        group: 'Finance',
        required: true,
        validation: {
          min: 0,
        },
      },
      default_tax_rate: {
        name: 'Default Tax Rate (%)',
        value: 20,
        type: 'number',
        description: 'Default tax rate percentage',
        group: 'Finance',
        required: true,
        validation: {
          min: 0,
          max: 100,
        },
      },
    };

    // Save the default preferences to Firestore
    const preferencesRef = doc(this.firestore, 'systemConfig/preferences');

    from(setDoc(preferencesRef, defaultPreferences)).subscribe({
      next: () => {
        this.loadPreferences(); // Reload the preferences
      },
      error: (error) => {
        console.error('Error creating default preferences:', error);
        this.notificationService.addNotification({
          type: 'error',
          title: 'Error',
          message: 'Failed to create default system preferences',
        });
      },
    });
  }

  resetToDefaults(): void {
    const confirmReset = window.confirm('Are you sure you want to reset all preferences to defaults? This action cannot be undone.');

    if (confirmReset) {
      this.isLoading = true;
      this.createDefaultPreferences();
    }
  }

  // Helper methods
  private getGroupIcon(groupName: string): string {
    const iconMap: { [key: string]: string } = {
      General: 'settings',
      Display: 'desktop_windows',
      Notifications: 'notifications',
      Finance: 'attach_money',
      Jobs: 'work',
      Users: 'people',
      Security: 'security',
    };

    return iconMap[groupName] || 'settings';
  }

  private getGroupDescription(groupName: string): string {
    const descriptionMap: { [key: string]: string } = {
      General: 'Basic company and system settings',
      Display: 'Appearance and formatting preferences',
      Notifications: 'System and user notification settings',
      Finance: 'Financial and expense settings',
      Jobs: 'Default job configuration',
      Users: 'User account settings',
      Security: 'Security and access control settings',
    };

    return descriptionMap[groupName] || '';
  }

  private convertTimestamp(timestamp: any): Date | undefined {
    if (!timestamp) return undefined;

    if (timestamp && typeof timestamp === 'object' && 'toDate' in timestamp) {
      return timestamp.toDate();
    }

    return new Date(timestamp);
  }
}


--- ./src/app/pages/settings/vehicle-makes/vehicle-makes.component.html ---
<div class="settings-page">
  <div class="settings-header">
    <div class="header-title">
      <h1>Vehicle Makes</h1>
      <p class="subtitle">Manage vehicle manufacturers and brands in the system</p>
    </div>
    <div class="header-actions">
      <button mat-flat-button color="primary" (click)="addVehicleMake()">
        <mat-icon>add</mat-icon>
        Add Vehicle Make
      </button>
    </div>
  </div>

  <!-- Stats Cards -->
  <div class="stats-cards">
    <mat-card class="stat-card">
      <mat-icon>directions_car</mat-icon>
      <div class="stat-content">
        <span class="stat-value">{{ totalMakes }}</span>
        <span class="stat-label">Total Makes</span>
      </div>
    </mat-card>

    <mat-card class="stat-card">
      <mat-icon class="active-icon">check_circle</mat-icon>
      <div class="stat-content">
        <span class="stat-value">{{ activeMakes }}</span>
        <span class="stat-label">Active Makes</span>
      </div>
    </mat-card>

    <mat-card class="stat-card">
      <mat-icon class="inactive-icon">cancel</mat-icon>
      <div class="stat-content">
        <span class="stat-value">{{ inactiveMakes }}</span>
        <span class="stat-label">Inactive Makes</span>
      </div>
    </mat-card>
  </div>

  <!-- Table Section -->
  <mat-card class="table-card">
    <div class="filters-row">
      <mat-form-field appearance="outline">
        <mat-label>Filter Makes</mat-label>
        <input matInput (keyup)="applyFilter($event)" placeholder="Search by name, type, etc." />
        <mat-icon matSuffix>search</mat-icon>
      </mat-form-field>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" *ngIf="isLoading">
      <mat-spinner diameter="40"></mat-spinner>
      <span>Loading vehicle makes...</span>
    </div>

    <div class="table-container">
      <table mat-table [dataSource]="dataSource" matSort>
        <!-- Logo Column -->
        <ng-container matColumnDef="logo">
          <th mat-header-cell *matHeaderCellDef>Logo</th>
          <td mat-cell *matCellDef="let make">
            <div class="make-logo" *ngIf="make.icon">
              <img [src]="'assets/images/car-logos/' + make.icon" [alt]="make.displayName" class="car-logo-img" />
            </div>
            <div class="make-logo-placeholder" *ngIf="!make.icon">
              {{ make.name.charAt(0).toUpperCase() }}
            </div>
          </td>
        </ng-container>

        <!-- Name Column -->
        <ng-container matColumnDef="name">
          <th mat-header-cell *matHeaderCellDef mat-sort-header>ID</th>
          <td mat-cell *matCellDef="let make">{{ make.name }}</td>
        </ng-container>

        <!-- Display Name Column -->
        <ng-container matColumnDef="displayName">
          <th mat-header-cell *matHeaderCellDef mat-sort-header>Make Name</th>
          <td mat-cell *matCellDef="let make">{{ make.displayName }}</td>
        </ng-container>

        <!-- Vehicle Types Column -->
        <ng-container matColumnDef="vehicleTypes">
          <th mat-header-cell *matHeaderCellDef>Vehicle Types</th>
          <td mat-cell *matCellDef="let make">
            <div class="types-container">
              <span class="vehicle-type-chip" *ngFor="let type of make.vehicleTypes">{{ type }}</span>
              <span *ngIf="!make.vehicleTypes || make.vehicleTypes.length === 0">None</span>
            </div>
          </td>
        </ng-container>

        <!-- Status Column -->
        <ng-container matColumnDef="status">
          <th mat-header-cell *matHeaderCellDef mat-sort-header>Status</th>
          <td mat-cell *matCellDef="let make">
            <span class="status-chip" [ngClass]="make.isActive ? 'status-active' : 'status-inactive'">
              {{ make.isActive ? 'Active' : 'Inactive' }}
            </span>
          </td>
        </ng-container>

        <!-- Actions Column -->
        <ng-container matColumnDef="actions">
          <th mat-header-cell *matHeaderCellDef>Actions</th>
          <td mat-cell *matCellDef="let make">
            <button mat-icon-button [matMenuTriggerFor]="menu" aria-label="Actions">
              <mat-icon>more_vert</mat-icon>
            </button>
            <mat-menu #menu="matMenu">
              <button mat-menu-item (click)="editVehicleMake(make)">
                <mat-icon>edit</mat-icon>
                <span>Edit</span>
              </button>
              <button mat-menu-item (click)="toggleVehicleMakeStatus(make)">
                <mat-icon>{{ make.isActive ? 'cancel' : 'check_circle' }}</mat-icon>
                <span>{{ make.isActive ? 'Deactivate' : 'Activate' }}</span>
              </button>
            </mat-menu>
          </td>
        </ng-container>

        <!-- Table Setup -->
        <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
        <tr mat-row *matRowDef="let row; columns: displayedColumns"></tr>

        <!-- When no data matches the filter -->
        <tr class="mat-row" *matNoDataRow>
          <td class="mat-cell no-data-cell" [attr.colspan]="displayedColumns.length">
            <div class="no-data-message">
              <mat-icon>search_off</mat-icon>
              <span>No vehicle makes found</span>
            </div>
          </td>
        </tr>
      </table>
    </div>

    <!-- Paginator -->
    <mat-paginator [pageSizeOptions]="[25, 50, 100]" showFirstLastButtons></mat-paginator>
  </mat-card>
</div>


--- ./src/app/pages/settings/vehicle-makes/vehicle-makes.component.scss ---
.settings-page {
  padding: 24px;
  height: 100%;
  display: flex;
  flex-direction: column;
}

.settings-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 24px;

  .header-title {
    h1 {
      margin: 0;
      font-size: 24px;
      font-weight: 500;
      color: var(--primary-color);
    }

    .subtitle {
      margin: 4px 0 0;
      color: rgba(0, 0, 0, 0.6);
      font-size: 14px;
    }
  }

  .header-actions {
    button {
      display: flex;
      align-items: center;
      gap: 8px;
    }
  }
}

.stats-cards {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 20px;
  margin-bottom: 24px;

  .stat-card {
    display: flex;
    align-items: center;
    padding: 20px;
    border-radius: 8px;

    mat-icon {
      font-size: 32px;
      height: 32px;
      width: 32px;
      margin-right: 16px;
      color: var(--primary-color);

      &.active-icon {
        color: #4caf50;
      }

      &.inactive-icon {
        color: #f44336;
      }
    }

    .stat-content {
      display: flex;
      flex-direction: column;

      .stat-value {
        font-size: 28px;
        font-weight: 600;
        color: rgba(0, 0, 0, 0.87);
        line-height: 1.2;
      }

      .stat-label {
        font-size: 14px;
        color: rgba(0, 0, 0, 0.6);
      }
    }
  }
}

.table-card {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;

  .filters-row {
    padding: 16px 16px 0;

    mat-form-field {
      width: 100%;
      max-width: 400px;
    }
  }
}

.table-container {
  position: relative;
  flex: 1;
  overflow: auto;

  table {
    width: 100%;
    min-width: 800px;
  }

  .mat-mdc-header-row {
    background-color: #f5f5f5;
  }

  .mat-mdc-header-cell {
    font-weight: 500;
    color: rgba(0, 0, 0, 0.6);
    white-space: nowrap;
  }

  .no-data-cell {
    padding: 48px 0;
  }

  .no-data-message {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;

    mat-icon {
      font-size: 48px;
      height: 48px;
      width: 48px;
      margin-bottom: 16px;
      color: rgba(0, 0, 0, 0.3);
    }

    span {
      font-size: 16px;
      color: rgba(0, 0, 0, 0.6);
    }
  }
}

.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.8);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 10;

  span {
    margin-top: 16px;
    color: rgba(0, 0, 0, 0.6);
  }
}

.make-logo {
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  background-color: #f5f5f5;
  overflow: hidden;

  .car-logo-img {
    width: 100%;
    height: 100%;
    object-fit: contain;
    padding: 4px;
  }
}

.make-logo-placeholder {
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  background-color: #e0e0e0;
  color: #616161;
  font-weight: 500;
  font-size: 18px;
}

.types-container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  max-width: 300px;

  .vehicle-type-chip {
    padding: 4px 8px;
    background-color: rgba(var(--primary-color-rgb), 0.1);
    color: var(--primary-color);
    border-radius: 4px;
    font-size: 12px;
    white-space: nowrap;
  }
}

.status-chip {
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
  font-weight: 500;

  &.status-active {
    background-color: rgba(76, 175, 80, 0.1);
    color: #4caf50;
  }

  &.status-inactive {
    background-color: rgba(244, 67, 54, 0.1);
    color: #f44336;
  }
}

/* Responsive adjustments */
@media screen and (max-width: 992px) {
  .stats-cards {
    grid-template-columns: repeat(2, 1fr);

    .stat-card:last-child {
      grid-column: span 2;
    }
  }
}

@media screen and (max-width: 768px) {
  .settings-header {
    flex-direction: column;
    gap: 16px;

    .header-actions {
      width: 100%;

      button {
        width: 100%;
      }
    }
  }

  .stats-cards {
    grid-template-columns: 1fr;

    .stat-card:last-child {
      grid-column: span 1;
    }
  }
}

@media screen and (max-width: 480px) {
  .settings-page {
    padding: 16px;
  }

  .table-card,
  .stat-card {
    border-radius: 4px;
  }

  .filters-row {
    padding: 12px 12px 0;
  }
}


--- ./src/app/pages/settings/vehicle-makes/vehicle-makes.component.ts ---
import { Component, OnInit, ViewChild } from '@angular/core';
import { MatDialog } from '@angular/material/dialog';
import { MatPaginator } from '@angular/material/paginator';
import { MatSort } from '@angular/material/sort';
import { MatTableDataSource } from '@angular/material/table';
import { VehicleMakeDialogComponent } from './vehicle-make-dialog/vehicle-make-dialog.component';
import { VehicleMake, VehicleService } from '../../../services/vehicle.service';
import { ConfirmationDialogComponent } from '../../../dialogs/confirmation-dialog.component';
import { NotificationService } from '../../../services/notification.service';
import { finalize } from 'rxjs/operators';

@Component({
  selector: 'app-vehicle-makes',
  templateUrl: './vehicle-makes.component.html',
  styleUrls: ['./vehicle-makes.component.scss'],
  standalone: false,
})
export class VehicleMakesComponent implements OnInit {
  displayedColumns: string[] = ['logo', 'name', 'displayName', 'vehicleTypes', 'status', 'actions'];
  dataSource = new MatTableDataSource<VehicleMake>([]);
  isLoading = false;
  totalMakes = 0;
  activeMakes = 0;
  inactiveMakes = 0;

  @ViewChild(MatPaginator) paginator!: MatPaginator;
  @ViewChild(MatSort) sort!: MatSort;

  constructor(private vehicleService: VehicleService, private dialog: MatDialog, private notificationService: NotificationService) {}

  ngOnInit(): void {
    this.loadVehicleMakes();
  }

  ngAfterViewInit() {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
  }

  loadVehicleMakes(): void {
    this.isLoading = true;
    this.vehicleService
      .getVehicleMakes()
      .pipe(finalize(() => (this.isLoading = false)))
      .subscribe({
        next: (makes) => {
          this.dataSource.data = makes;
          this.calculateStats(makes);
        },
        error: (error) => {
          console.error('Error loading vehicle makes:', error);
          this.notificationService.addNotification({
            type: 'error',
            title: 'Error',
            message: 'Failed to load vehicle makes',
          });
        },
      });
  }

  calculateStats(makes: VehicleMake[]): void {
    this.totalMakes = makes.length;
    this.activeMakes = makes.filter((make) => make.isActive).length;
    this.inactiveMakes = makes.filter((make) => !make.isActive).length;
  }

  applyFilter(event: Event): void {
    const filterValue = (event.target as HTMLInputElement).value;
    this.dataSource.filter = filterValue.trim().toLowerCase();

    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage();
    }
  }

  addVehicleMake(): void {
    const dialogRef = this.dialog.open(VehicleMakeDialogComponent, {
      width: '600px',
      data: { isEdit: false },
    });

    dialogRef.afterClosed().subscribe((result) => {
      if (result) {
        this.isLoading = true;
        this.vehicleService
          .createVehicleMake(result)
          .pipe(finalize(() => (this.isLoading = false)))
          .subscribe({
            next: () => {
              this.notificationService.addNotification({
                type: 'success',
                title: 'Success',
                message: `Vehicle make "${result.displayName}" created successfully`,
              });
              this.loadVehicleMakes();
            },
            error: (error) => {
              console.error('Error creating vehicle make:', error);
              this.notificationService.addNotification({
                type: 'error',
                title: 'Error',
                message: 'Failed to create vehicle make',
              });
            },
          });
      }
    });
  }

  editVehicleMake(make: VehicleMake): void {
    const dialogRef = this.dialog.open(VehicleMakeDialogComponent, {
      width: '600px',
      data: { isEdit: true, make: make },
    });

    dialogRef.afterClosed().subscribe((result) => {
      if (result) {
        this.isLoading = true;
        this.vehicleService
          .updateVehicleMake(make.id, result)
          .pipe(finalize(() => (this.isLoading = false)))
          .subscribe({
            next: () => {
              this.notificationService.addNotification({
                type: 'success',
                title: 'Success',
                message: `Vehicle make "${result.displayName}" updated successfully`,
              });
              this.loadVehicleMakes();
            },
            error: (error) => {
              console.error('Error updating vehicle make:', error);
              this.notificationService.addNotification({
                type: 'error',
                title: 'Error',
                message: 'Failed to update vehicle make',
              });
            },
          });
      }
    });
  }

  toggleVehicleMakeStatus(make: VehicleMake): void {
    const newStatus = !make.isActive;
    const action = newStatus ? 'activate' : 'deactivate';

    const dialogRef = this.dialog.open(ConfirmationDialogComponent, {
      width: '400px',
      data: {
        title: `${newStatus ? 'Activate' : 'Deactivate'} Vehicle Make`,
        message: `Are you sure you want to ${action} the vehicle make "${make.displayName}"?`,
        confirmText: 'Yes',
        cancelText: 'No',
      },
    });

    dialogRef.afterClosed().subscribe((confirmed) => {
      if (confirmed) {
        this.isLoading = true;
        this.vehicleService
          .updateVehicleMake(make.id, { isActive: newStatus })
          .pipe(finalize(() => (this.isLoading = false)))
          .subscribe({
            next: () => {
              this.notificationService.addNotification({
                type: 'success',
                title: 'Success',
                message: `Vehicle make "${make.displayName}" ${newStatus ? 'activated' : 'deactivated'} successfully`,
              });
              this.loadVehicleMakes();
            },
            error: (error) => {
              console.error(`Error ${action}ing vehicle make:`, error);
              this.notificationService.addNotification({
                type: 'error',
                title: 'Error',
                message: `Failed to ${action} vehicle make`,
              });
            },
          });
      }
    });
  }

  getVehicleTypesList(vehicleTypes: string[]): string {
    return vehicleTypes ? vehicleTypes.join(', ') : 'None';
  }
}


--- ./src/app/pages/settings/vehicle-makes/vehicle-make-dialog/vehicle-make-dialog.component.scss ---
.dialog-content {
  display: flex;
  flex-direction: column;
  gap: 20px;
  min-width: 400px;
  padding: 0 8px;
}

.form-fields-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 16px;
}

.select-icon-preview,
.icon-option {
  display: flex;
  align-items: center;
  gap: 8px;

  mat-icon {
    font-size: 20px;
    height: 20px;
    width: 20px;
  }
}

.full-width {
  width: 100%;
}

.vehicle-types-section {
  margin-top: 8px;
}

/* Make the mat-form-field for chips take the full width */
.vehicle-types-section .mat-form-field {
  width: 100%;
}

/* Responsive styles */
@media screen and (max-width: 599px) {
  .form-fields-grid {
    grid-template-columns: 1fr;
  }

  .dialog-content {
    min-width: unset;
  }
}


--- ./src/app/pages/settings/vehicle-makes/vehicle-make-dialog/vehicle-make-dialog.component.html ---
<h2 mat-dialog-title>{{ isEdit ? 'Edit' : 'Add' }} Vehicle Make</h2>

<form [formGroup]="vehicleMakeForm" (ngSubmit)="onSubmit()">
  <mat-dialog-content>
    <div class="dialog-content">
      <div class="form-fields-grid">
        <!-- Name (ID) Field -->
        <mat-form-field appearance="outline">
          <mat-label>Make ID</mat-label>
          <input matInput formControlName="name" placeholder="e.g. toyota" [readonly]="isEdit" />
          <mat-hint>Unique identifier. Use lowercase with no spaces.</mat-hint>
          <mat-error *ngIf="vehicleMakeForm.get('name')?.hasError('required')"> Make ID is required </mat-error>
          <mat-error *ngIf="vehicleMakeForm.get('name')?.hasError('pattern')"> Use only letters, numbers, hyphens and underscores </mat-error>
        </mat-form-field>

        <!-- Display Name Field -->
        <mat-form-field appearance="outline">
          <mat-label>Display Name</mat-label>
          <input matInput formControlName="displayName" placeholder="e.g. Toyota" />
          <mat-hint>Name shown to users</mat-hint>
          <mat-error *ngIf="vehicleMakeForm.get('displayName')?.hasError('required')"> Display name is required </mat-error>
        </mat-form-field>

        <!-- Icon Field -->
        <mat-form-field appearance="outline">
          <mat-label>Icon</mat-label>
          <mat-select formControlName="icon">
            <mat-select-trigger>
              <div class="select-icon-preview">
                <mat-icon>{{ vehicleMakeForm.get('icon')?.value }}</mat-icon>
                <span>{{ vehicleMakeForm.get('icon')?.value }}</span>
              </div>
            </mat-select-trigger>
            <mat-option *ngFor="let icon of materialIcons" [value]="icon">
              <div class="icon-option">
                <mat-icon>{{ icon }}</mat-icon>
                <span>{{ icon }}</span>
              </div>
            </mat-option>
          </mat-select>
          <mat-hint>Icon to represent this make</mat-hint>
        </mat-form-field>

        <!-- Status Field -->
        <mat-form-field appearance="outline">
          <mat-label>Status</mat-label>
          <mat-select formControlName="isActive">
            <mat-option [value]="true">Active</mat-option>
            <mat-option [value]="false">Inactive</mat-option>
          </mat-select>
          <mat-hint>Controls visibility in the app</mat-hint>
        </mat-form-field>
      </div>

      <!-- Vehicle Types Field -->
      <div class="vehicle-types-section">
        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Vehicle Types</mat-label>
          <mat-chip-grid #chipGrid aria-label="Vehicle type selection">
            <mat-chip-row *ngFor="let type of vehicleTypes" (removed)="removeVehicleType(type)">
              {{ type }}
              <button matChipRemove>
                <mat-icon>cancel</mat-icon>
              </button>
            </mat-chip-row>
            <input
              placeholder="Add vehicle type..."
              [matChipInputFor]="chipGrid"
              [matChipInputSeparatorKeyCodes]="separatorKeysCodes"
              (matChipInputTokenEnd)="addVehicleType($event)"
              formControlName="type" />
          </mat-chip-grid>
          <mat-hint>Press Enter or comma to add</mat-hint>
        </mat-form-field>
      </div>
    </div>
  </mat-dialog-content>

  <mat-dialog-actions align="end">
    <button mat-button type="button" (click)="onCancel()">Cancel</button>
    <button mat-flat-button color="primary" type="submit" [disabled]="vehicleMakeForm.invalid">
      {{ isEdit ? 'Update' : 'Create' }}
    </button>
  </mat-dialog-actions>
</form>


--- ./src/app/pages/settings/vehicle-makes/vehicle-make-dialog/vehicle-make-dialog.component.ts ---
import { Component, Inject, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { MAT_DIALOG_DATA, MatDialogRef } from '@angular/material/dialog';
import { VehicleMake } from '../../../../services/vehicle.service';
import { MatChipInputEvent } from '@angular/material/chips';
import { COMMA, ENTER } from '@angular/cdk/keycodes';

interface DialogData {
  isEdit: boolean;
  make?: VehicleMake;
}

@Component({
  selector: 'app-vehicle-make-dialog',
  templateUrl: './vehicle-make-dialog.component.html',
  styleUrls: ['./vehicle-make-dialog.component.scss'],
  standalone: false,
})
export class VehicleMakeDialogComponent implements OnInit {
  vehicleMakeForm!: FormGroup;
  isEdit: boolean;
  readonly separatorKeysCodes = [ENTER, COMMA] as const;
  vehicleTypes: string[] = [];
  materialIcons: string[] = [
    'directions_car',
    'motorcycle',
    'local_shipping',
    'airport_shuttle',
    'commute',
    'electric_car',
    'electric_bike',
    'electric_moped',
    'emoji_transportation',
    'delivery_dining',
    'pedal_bike',
    'two_wheeler',
  ];

  constructor(private fb: FormBuilder, public dialogRef: MatDialogRef<VehicleMakeDialogComponent>, @Inject(MAT_DIALOG_DATA) public data: DialogData) {
    this.isEdit = data.isEdit;

    if (this.isEdit && data.make) {
      this.vehicleTypes = [...(data.make.vehicleTypes || [])];
    }
  }

  ngOnInit(): void {
    this.createForm();
  }

  createForm(): void {
    this.vehicleMakeForm = this.fb.group({
      name: ['', [Validators.required, Validators.pattern('[a-zA-Z0-9-_]+')]],
      displayName: ['', Validators.required],
      icon: ['directions_car'],
      type: [''],
      isActive: [true],
    });

    if (this.isEdit && this.data.make) {
      this.vehicleMakeForm.patchValue({
        name: this.data.make.name,
        displayName: this.data.make.displayName,
        icon: this.data.make.icon || 'directions_car',
        isActive: this.data.make.isActive,
      });
    }
  }

  onSubmit(): void {
    if (this.vehicleMakeForm.invalid) {
      return;
    }

    const formValue = this.vehicleMakeForm.value;

    const makeData: Partial<VehicleMake> = {
      name: formValue.name,
      displayName: formValue.displayName,
      type: formValue.type || 'Car',
      icon: formValue.icon,
      vehicleTypes: this.vehicleTypes,
      isActive: formValue.isActive,
    };

    this.dialogRef.close(makeData);
  }

  onCancel(): void {
    this.dialogRef.close();
  }

  addVehicleType(event: MatChipInputEvent): void {
    const value = (event.value || '').trim();

    if (value) {
      this.vehicleTypes.push(value);
    }

    event.chipInput!.clear();
    this.vehicleMakeForm.get('type')?.reset();
  }

  removeVehicleType(type: string): void {
    const index = this.vehicleTypes.indexOf(type);

    if (index >= 0) {
      this.vehicleTypes.splice(index, 1);
    }
  }
}


--- ./src/app/pages/settings/vehicle-models/vehicle-models.component.ts ---
import { Component, OnInit, ViewChild } from '@angular/core';
import { MatDialog } from '@angular/material/dialog';
import { MatPaginator } from '@angular/material/paginator';
import { MatSort } from '@angular/material/sort';
import { MatTableDataSource } from '@angular/material/table';
import { finalize, Observable, forkJoin, of } from 'rxjs';
import { VehicleService, VehicleMake, VehicleModel } from '../../../services/vehicle.service';
import { NotificationService } from '../../../services/notification.service';
import { ConfirmationDialogComponent } from '../../../dialogs/confirmation-dialog.component';
import { VehicleModelDialogComponent } from './vehicle-model-dialog/vehicle-model-dialog.component';

interface VehicleModelWithMake extends VehicleModel {
  makeName?: string;
}

@Component({
  selector: 'app-vehicle-models',
  templateUrl: './vehicle-models.component.html',
  styleUrls: ['./vehicle-models.component.scss'],
  standalone: false,
})
export class VehicleModelsComponent implements OnInit {
  displayedColumns: string[] = ['name', 'make', 'type', 'status', 'actions'];
  dataSource = new MatTableDataSource<VehicleModelWithMake>([]);
  isLoading = false;
  makes: VehicleMake[] = [];
  totalModels = 0;
  activeModels = 0;
  inactiveModels = 0;

  @ViewChild(MatPaginator) paginator!: MatPaginator;
  @ViewChild(MatSort) sort!: MatSort;

  constructor(private vehicleService: VehicleService, private dialog: MatDialog, private notificationService: NotificationService) {}

  ngOnInit(): void {
    this.loadData();
  }

  ngAfterViewInit() {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
  }

  loadData(): void {
    this.isLoading = true;

    // Load makes and models in parallel
    forkJoin({
      makes: this.vehicleService.getVehicleMakes(),
      models: this.vehicleService.getVehicleModels(),
    })
      .pipe(finalize(() => (this.isLoading = false)))
      .subscribe({
        next: ({ makes, models }) => {
          this.makes = makes;

          // Enrich models with make name for display
          const modelsWithMakes = models.map((model) => {
            const make = makes.find((m) => m.id === model.makeId);
            return {
              ...model,
              makeName: make?.displayName || 'Unknown Make',
            };
          });

          this.dataSource.data = modelsWithMakes;
          this.calculateStats(models);
        },
        error: (error) => {
          console.error('Error loading data:', error);
          this.notificationService.addNotification({
            type: 'error',
            title: 'Error',
            message: 'Failed to load vehicle models',
          });
        },
      });
  }

  calculateStats(models: VehicleModel[]): void {
    this.totalModels = models.length;
    this.activeModels = models.filter((model) => model.isActive).length;
    this.inactiveModels = models.filter((model) => !model.isActive).length;
  }

  applyFilter(event: Event): void {
    const filterValue = (event.target as HTMLInputElement).value;
    this.dataSource.filter = filterValue.trim().toLowerCase();

    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage();
    }
  }

  addVehicleModel(): void {
    // Don't allow adding models if no makes exist
    if (this.makes.length === 0) {
      this.notificationService.addNotification({
        type: 'warning',
        title: 'No Makes Available',
        message: 'Please create at least one vehicle make first',
      });
      return;
    }

    const dialogRef = this.dialog.open(VehicleModelDialogComponent, {
      width: '600px',
      data: {
        isEdit: false,
        makes: this.makes.filter((make) => make.isActive),
      },
    });

    dialogRef.afterClosed().subscribe((result) => {
      if (result) {
        this.isLoading = true;
        this.vehicleService
          .createVehicleModel(result)
          .pipe(finalize(() => (this.isLoading = false)))
          .subscribe({
            next: () => {
              this.notificationService.addNotification({
                type: 'success',
                title: 'Success',
                message: `Vehicle model "${result.name}" created successfully`,
              });
              this.loadData();
            },
            error: (error) => {
              console.error('Error creating vehicle model:', error);
              this.notificationService.addNotification({
                type: 'error',
                title: 'Error',
                message: 'Failed to create vehicle model',
              });
            },
          });
      }
    });
  }

  editVehicleModel(model: VehicleModelWithMake): void {
    const dialogRef = this.dialog.open(VehicleModelDialogComponent, {
      width: '600px',
      data: {
        isEdit: true,
        model: model,
        makes: this.makes.filter((make) => make.isActive),
      },
    });

    dialogRef.afterClosed().subscribe((result) => {
      if (result) {
        this.isLoading = true;
        this.vehicleService
          .updateVehicleModel(model.id, result)
          .pipe(finalize(() => (this.isLoading = false)))
          .subscribe({
            next: () => {
              this.notificationService.addNotification({
                type: 'success',
                title: 'Success',
                message: `Vehicle model "${result.name}" updated successfully`,
              });
              this.loadData();
            },
            error: (error) => {
              console.error('Error updating vehicle model:', error);
              this.notificationService.addNotification({
                type: 'error',
                title: 'Error',
                message: 'Failed to update vehicle model',
              });
            },
          });
      }
    });
  }

  toggleVehicleModelStatus(model: VehicleModelWithMake): void {
    const newStatus = !model.isActive;
    const action = newStatus ? 'activate' : 'deactivate';

    const dialogRef = this.dialog.open(ConfirmationDialogComponent, {
      width: '400px',
      data: {
        title: `${newStatus ? 'Activate' : 'Deactivate'} Vehicle Model`,
        message: `Are you sure you want to ${action} the vehicle model "${model.name}"?`,
        confirmText: 'Yes',
        cancelText: 'No',
      },
    });

    dialogRef.afterClosed().subscribe((confirmed) => {
      if (confirmed) {
        this.isLoading = true;
        this.vehicleService
          .updateVehicleModel(model.id, { isActive: newStatus })
          .pipe(finalize(() => (this.isLoading = false)))
          .subscribe({
            next: () => {
              this.notificationService.addNotification({
                type: 'success',
                title: 'Success',
                message: `Vehicle model "${model.name}" ${newStatus ? 'activated' : 'deactivated'} successfully`,
              });
              this.loadData();
            },
            error: (error) => {
              console.error(`Error ${action}ing vehicle model:`, error);
              this.notificationService.addNotification({
                type: 'error',
                title: 'Error',
                message: `Failed to ${action} vehicle model`,
              });
            },
          });
      }
    });
  }
}


--- ./src/app/pages/settings/vehicle-models/vehicle-models.component.html ---
<div class="settings-page">
  <div class="settings-header">
    <div class="header-title">
      <h1>Vehicle Models</h1>
      <p class="subtitle">Manage vehicle models associated with makes</p>
    </div>
    <div class="header-actions">
      <button mat-flat-button color="primary" (click)="addVehicleModel()">
        <mat-icon>add</mat-icon>
        Add Vehicle Model
      </button>
    </div>
  </div>

  <!-- Stats Cards -->
  <div class="stats-cards">
    <mat-card class="stat-card">
      <mat-icon>model_training</mat-icon>
      <div class="stat-content">
        <span class="stat-value">{{ totalModels }}</span>
        <span class="stat-label">Total Models</span>
      </div>
    </mat-card>

    <mat-card class="stat-card">
      <mat-icon class="active-icon">check_circle</mat-icon>
      <div class="stat-content">
        <span class="stat-value">{{ activeModels }}</span>
        <span class="stat-label">Active Models</span>
      </div>
    </mat-card>

    <mat-card class="stat-card">
      <mat-icon class="inactive-icon">cancel</mat-icon>
      <div class="stat-content">
        <span class="stat-value">{{ inactiveModels }}</span>
        <span class="stat-label">Inactive Models</span>
      </div>
    </mat-card>
  </div>

  <!-- Table Section -->
  <mat-card class="table-card">
    <div class="filters-row">
      <mat-form-field appearance="outline">
        <mat-label>Filter Models</mat-label>
        <input matInput (keyup)="applyFilter($event)" placeholder="Search by name, make, etc." />
        <mat-icon matSuffix>search</mat-icon>
      </mat-form-field>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" *ngIf="isLoading">
      <mat-spinner diameter="40"></mat-spinner>
      <span>Loading vehicle models...</span>
    </div>

    <div class="table-container">
      <table mat-table [dataSource]="dataSource" matSort>
        <!-- Name Column -->
        <ng-container matColumnDef="name">
          <th mat-header-cell *matHeaderCellDef mat-sort-header>Model Name</th>
          <td mat-cell *matCellDef="let model">{{ model.name }}</td>
        </ng-container>

        <!-- Make Column -->
        <ng-container matColumnDef="make">
          <th mat-header-cell *matHeaderCellDef mat-sort-header>Make</th>
          <td mat-cell *matCellDef="let model">{{ model.makeName }}</td>
        </ng-container>

        <!-- Vehicle Type Column -->
        <ng-container matColumnDef="type">
          <th mat-header-cell *matHeaderCellDef mat-sort-header>Type</th>
          <td mat-cell *matCellDef="let model">
            <span class="type-chip">{{ model.type }}</span>
          </td>
        </ng-container>

        <!-- Status Column -->
        <ng-container matColumnDef="status">
          <th mat-header-cell *matHeaderCellDef mat-sort-header>Status</th>
          <td mat-cell *matCellDef="let model">
            <span class="status-chip" [ngClass]="model.isActive ? 'status-active' : 'status-inactive'">
              {{ model.isActive ? 'Active' : 'Inactive' }}
            </span>
          </td>
        </ng-container>

        <!-- Actions Column -->
        <ng-container matColumnDef="actions">
          <th mat-header-cell *matHeaderCellDef>Actions</th>
          <td mat-cell *matCellDef="let model">
            <button mat-icon-button [matMenuTriggerFor]="menu" aria-label="Actions">
              <mat-icon>more_vert</mat-icon>
            </button>
            <mat-menu #menu="matMenu">
              <button mat-menu-item (click)="editVehicleModel(model)">
                <mat-icon>edit</mat-icon>
                <span>Edit</span>
              </button>
              <button mat-menu-item (click)="toggleVehicleModelStatus(model)">
                <mat-icon>{{ model.isActive ? 'cancel' : 'check_circle' }}</mat-icon>
                <span>{{ model.isActive ? 'Deactivate' : 'Activate' }}</span>
              </button>
            </mat-menu>
          </td>
        </ng-container>

        <!-- Table Setup -->
        <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
        <tr mat-row *matRowDef="let row; columns: displayedColumns"></tr>

        <!-- When no data matches the filter -->
        <tr class="mat-row" *matNoDataRow>
          <td class="mat-cell no-data-cell" [attr.colspan]="displayedColumns.length">
            <div class="no-data-message">
              <mat-icon>search_off</mat-icon>
              <span>No vehicle models found</span>
            </div>
          </td>
        </tr>
      </table>
    </div>

    <!-- Paginator -->
    <mat-paginator [pageSizeOptions]="[5, 10, 25, 100]" showFirstLastButtons></mat-paginator>
  </mat-card>
</div>


--- ./src/app/pages/settings/vehicle-models/vehicle-models.component.scss ---
.settings-page {
  padding: 24px;
  height: 100%;
  display: flex;
  flex-direction: column;
}

.settings-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 24px;

  .header-title {
    h1 {
      margin: 0;
      font-size: 24px;
      font-weight: 500;
      color: var(--primary-color);
    }

    .subtitle {
      margin: 4px 0 0;
      color: rgba(0, 0, 0, 0.6);
      font-size: 14px;
    }
  }

  .header-actions {
    button {
      display: flex;
      align-items: center;
      gap: 8px;
    }
  }
}

.stats-cards {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 20px;
  margin-bottom: 24px;

  .stat-card {
    display: flex;
    align-items: center;
    padding: 20px;
    border-radius: 8px;

    mat-icon {
      font-size: 32px;
      height: 32px;
      width: 32px;
      margin-right: 16px;
      color: var(--primary-color);

      &.active-icon {
        color: #4caf50;
      }

      &.inactive-icon {
        color: #f44336;
      }
    }

    .stat-content {
      display: flex;
      flex-direction: column;

      .stat-value {
        font-size: 28px;
        font-weight: 600;
        color: rgba(0, 0, 0, 0.87);
        line-height: 1.2;
      }

      .stat-label {
        font-size: 14px;
        color: rgba(0, 0, 0, 0.6);
      }
    }
  }
}

.table-card {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;

  .filters-row {
    padding: 16px 16px 0;

    mat-form-field {
      width: 100%;
      max-width: 400px;
    }
  }
}

.table-container {
  position: relative;
  flex: 1;
  overflow: auto;

  table {
    width: 100%;
  }

  .mat-mdc-header-row {
    background-color: #f5f5f5;
  }

  .mat-mdc-header-cell {
    font-weight: 500;
    color: rgba(0, 0, 0, 0.6);
    white-space: nowrap;
  }

  .no-data-cell {
    padding: 48px 0;
  }

  .no-data-message {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;

    mat-icon {
      font-size: 48px;
      height: 48px;
      width: 48px;
      margin-bottom: 16px;
      color: rgba(0, 0, 0, 0.3);
    }

    span {
      font-size: 16px;
      color: rgba(0, 0, 0, 0.6);
    }
  }
}

.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.8);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 10;

  span {
    margin-top: 16px;
    color: rgba(0, 0, 0, 0.6);
  }
}

.type-chip {
  padding: 4px 8px;
  border-radius: 4px;
  background-color: rgba(var(--primary-color-rgb), 0.1);
  color: var(--primary-color);
  font-size: 12px;
  font-weight: 500;
}

.status-chip {
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
  font-weight: 500;

  &.status-active {
    background-color: rgba(76, 175, 80, 0.1);
    color: #4caf50;
  }

  &.status-inactive {
    background-color: rgba(244, 67, 54, 0.1);
    color: #f44336;
  }
}

/* Responsive adjustments */
@media screen and (max-width: 992px) {
  .stats-cards {
    grid-template-columns: repeat(2, 1fr);

    .stat-card:last-child {
      grid-column: span 2;
    }
  }
}

@media screen and (max-width: 768px) {
  .settings-header {
    flex-direction: column;
    gap: 16px;

    .header-actions {
      width: 100%;

      button {
        width: 100%;
      }
    }
  }

  .stats-cards {
    grid-template-columns: 1fr;

    .stat-card:last-child {
      grid-column: span 1;
    }
  }
}

@media screen and (max-width: 480px) {
  .settings-page {
    padding: 16px;
  }

  .table-card,
  .stat-card {
    border-radius: 4px;
  }

  .filters-row {
    padding: 12px 12px 0;
  }
}


--- ./src/app/pages/settings/vehicle-models/vehicle-model-dialog/vehicle-model-dialog.component.ts ---
import { Component, Inject, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { MAT_DIALOG_DATA, MatDialogRef } from '@angular/material/dialog';
import { VehicleMake, VehicleModel } from '../../../../services/vehicle.service';

interface DialogData {
  isEdit: boolean;
  model?: VehicleModel;
  makes: VehicleMake[];
}

@Component({
  selector: 'app-vehicle-model-dialog',
  templateUrl: './vehicle-model-dialog.component.html',
  styleUrls: ['./vehicle-model-dialog.component.scss'],
  standalone: false,
})
export class VehicleModelDialogComponent implements OnInit {
  modelForm!: FormGroup;
  isEdit: boolean;
  availableMakes: VehicleMake[] = [];

  vehicleTypes: string[] = ['Car', 'Van', 'SUV', 'Truck', 'Motorbike', 'Bus', 'Lorry', 'Trailer'];

  constructor(private fb: FormBuilder, public dialogRef: MatDialogRef<VehicleModelDialogComponent>, @Inject(MAT_DIALOG_DATA) public data: DialogData) {
    this.isEdit = data.isEdit;
    this.availableMakes = data.makes || [];
  }

  ngOnInit(): void {
    this.createForm();
  }

  createForm(): void {
    this.modelForm = this.fb.group({
      name: ['', [Validators.required, Validators.minLength(2), Validators.maxLength(50)]],
      makeId: ['', Validators.required],
      type: ['Car', Validators.required],
      isActive: [true],
    });

    if (this.isEdit && this.data.model) {
      this.modelForm.patchValue({
        name: this.data.model.name,
        makeId: this.data.model.makeId,
        type: this.data.model.type || 'Car',
        isActive: this.data.model.isActive,
      });

      // If editing, disable the make field if the make is inactive
      const makeStillActive = this.availableMakes.some((make) => make.id === this.data.model?.makeId);

      if (!makeStillActive && this.data.model?.makeId) {
        // Make isn't in the active list, but we need to show it anyway
        const makeId = this.data.model.makeId;

        // Display a disabled option for the inactive make
        this.modelForm.get('makeId')?.disable();
      }
    }
  }

  onSubmit(): void {
    if (this.modelForm.invalid) {
      return;
    }

    const formValue = this.modelForm.value;

    // If the makeId control is disabled, we need to get its value manually
    const makeId = this.modelForm.get('makeId')?.disabled ? this.data.model?.makeId : formValue.makeId;

    const modelData: Partial<VehicleModel> = {
      name: formValue.name,
      makeId: makeId,
      type: formValue.type,
      isActive: formValue.isActive,
    };

    this.dialogRef.close(modelData);
  }

  onCancel(): void {
    this.dialogRef.close();
  }

  // Get display name for a make by ID
  getMakeName(makeId: string): string {
    const make = this.availableMakes.find((m) => m.id === makeId);
    return make ? make.displayName : 'Unknown';
  }
}


--- ./src/app/pages/settings/vehicle-models/vehicle-model-dialog/vehicle-model-dialog.component.scss ---
.dialog-content {
  display: flex;
  flex-direction: column;
  gap: 16px;
  min-width: 400px;
  padding: 0 8px;
}

.full-width {
  width: 100%;
}

/* Responsive styles */
@media screen and (max-width: 599px) {
  .dialog-content {
    min-width: unset;
  }
}


--- ./src/app/pages/settings/vehicle-models/vehicle-model-dialog/vehicle-model-dialog.component.html ---
<h2 mat-dialog-title>{{ isEdit ? 'Edit' : 'Add' }} Vehicle Model</h2>

<form [formGroup]="modelForm" (ngSubmit)="onSubmit()">
  <mat-dialog-content>
    <div class="dialog-content">
      <!-- Name Field -->
      <mat-form-field appearance="outline" class="full-width">
        <mat-label>Model Name</mat-label>
        <input matInput formControlName="name" placeholder="e.g. Corolla" />
        <mat-hint>Name of the vehicle model</mat-hint>
        <mat-error *ngIf="modelForm.get('name')?.hasError('required')"> Model name is required </mat-error>
        <mat-error *ngIf="modelForm.get('name')?.hasError('minlength')"> Model name must be at least 2 characters </mat-error>
        <mat-error *ngIf="modelForm.get('name')?.hasError('maxlength')"> Model name cannot exceed 50 characters </mat-error>
      </mat-form-field>

      <!-- Vehicle Make Field -->
      <mat-form-field appearance="outline" class="full-width">
        <mat-label>Vehicle Make</mat-label>
        <mat-select formControlName="makeId">
          <mat-option *ngFor="let make of availableMakes" [value]="make.id">
            {{ make.displayName }}
          </mat-option>
        </mat-select>
        <mat-hint>The manufacturer of this model</mat-hint>
        <mat-error *ngIf="modelForm.get('makeId')?.hasError('required')"> Vehicle make is required </mat-error>
      </mat-form-field>

      <!-- Type Field -->
      <mat-form-field appearance="outline" class="full-width">
        <mat-label>Vehicle Type</mat-label>
        <mat-select formControlName="type">
          <mat-option *ngFor="let type of vehicleTypes" [value]="type">
            {{ type }}
          </mat-option>
        </mat-select>
        <mat-hint>Type of vehicle</mat-hint>
        <mat-error *ngIf="modelForm.get('type')?.hasError('required')"> Vehicle type is required </mat-error>
      </mat-form-field>

      <!-- Status Field -->
      <mat-form-field appearance="outline" class="full-width">
        <mat-label>Status</mat-label>
        <mat-select formControlName="isActive">
          <mat-option [value]="true">Active</mat-option>
          <mat-option [value]="false">Inactive</mat-option>
        </mat-select>
        <mat-hint>Controls visibility in the app</mat-hint>
      </mat-form-field>
    </div>
  </mat-dialog-content>

  <mat-dialog-actions align="end">
    <button mat-button type="button" (click)="onCancel()">Cancel</button>
    <button mat-flat-button color="primary" type="submit" [disabled]="modelForm.invalid">
      {{ isEdit ? 'Update' : 'Create' }}
    </button>
  </mat-dialog-actions>
</form>


--- ./src/app/pages/drivers/driver-list/driver-list.component.html ---
<!-- driver-list.component.html -->
<mat-card class="mat-elevation-z3">
  <!-- Header -->
  <div class="header-wrapper">
    <div class="header-title">
      <h1>Drivers</h1>
      <p class="subtitle">
        {{ dataSource.filteredData.length }} total drivers
        <ng-container *ngIf="selection.hasValue()"> ({{ selection.selected.length }} selected) </ng-container>
      </p>
    </div>
  </div>

  <!-- Filters and Actions Bar -->
  <div class="filters-actions-wrapper">
    <div class="filters-section">
      <mat-form-field appearance="outline" class="search-field">
        <mat-label>Search drivers</mat-label>
        <input matInput (keyup)="applyFilter($event)" placeholder="Search by name, email, or company" />
        <mat-icon matSuffix>search</mat-icon>
      </mat-form-field>

      <div class="filters-group">
        <mat-form-field appearance="outline">
          <mat-label>Type</mat-label>
          <mat-select [(value)]="typeFilter" (selectionChange)="onFilterChange()">
            <mat-option *ngFor="let type of typeOptions" [value]="type">
              {{ type }}
            </mat-option>
          </mat-select>
        </mat-form-field>

        <mat-form-field appearance="outline">
          <mat-label>Role</mat-label>
          <mat-select [(value)]="roleFilter" (selectionChange)="onFilterChange()">
            <mat-option *ngFor="let role of roleOptions" [value]="role">
              {{ role }}
            </mat-option>
          </mat-select>
        </mat-form-field>

        <mat-form-field appearance="outline">
          <mat-label>Status</mat-label>
          <mat-select [(value)]="statusFilter" (selectionChange)="onFilterChange()">
            <mat-option *ngFor="let status of statusOptions" [value]="status">
              {{ status }}
            </mat-option>
          </mat-select>
        </mat-form-field>
      </div>
    </div>

    <div class="actions-group">
      <button mat-stroked-button [matMenuTriggerFor]="exportMenu" class="export-button">
        <mat-icon>download</mat-icon>
        Export
      </button>
      <button mat-flat-button color="primary" (click)="createNewDriver()" class="create-button">
        <mat-icon>add</mat-icon>
        New Driver
      </button>
    </div>
  </div>

  <!-- Table Container -->
  <div class="table-container">
    <!-- Loading Overlay -->
    <div class="loading-overlay" *ngIf="isLoading">
      <mat-spinner diameter="40"></mat-spinner>
      <span>Loading drivers...</span>
    </div>

    <!-- Table -->
    <table mat-table [dataSource]="dataSource" matSort [class.loading]="isLoading">
      <!-- Checkbox Column -->
      <ng-container matColumnDef="select">
        <th mat-header-cell *matHeaderCellDef>
          <mat-checkbox
            (change)="$event ? toggleAllRows() : null"
            [checked]="selection.hasValue() && isAllSelected()"
            [indeterminate]="selection.hasValue() && !isAllSelected()"
            [aria-label]="checkboxLabel()">
          </mat-checkbox>
        </th>
        <td mat-cell *matCellDef="let row">
          <mat-checkbox
            (click)="$event.stopPropagation()"
            (change)="$event ? selection.toggle(row) : null"
            [checked]="selection.isSelected(row)"
            [aria-label]="checkboxLabel(row)">
          </mat-checkbox>
        </td>
      </ng-container>

      <!-- ID Column -->
      <ng-container matColumnDef="id">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>ID</th>
        <td mat-cell *matCellDef="let driver">{{ driver.id }}</td>
      </ng-container>

      <!-- Name Column -->
      <ng-container matColumnDef="name">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Name</th>
        <td mat-cell *matCellDef="let driver">
          <div class="name-cell">
            <div class="avatar">{{ getDriverInitials(driver) }}</div>
            <div class="name-details">
              <span class="primary-text">{{ driver.firstName }} {{ driver.lastName }}</span>
              <span class="secondary-text" *ngIf="driver.company">{{ driver.company }}</span>
            </div>
          </div>
        </td>
      </ng-container>

      <!-- Email Column -->
      <ng-container matColumnDef="email">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Email</th>
        <td mat-cell *matCellDef="let driver">
          <a [href]="'mailto:' + driver.email" (click)="$event.stopPropagation()">
            {{ driver.email }}
          </a>
        </td>
      </ng-container>

      <!-- Phone Column -->
      <ng-container matColumnDef="phone">
        <th mat-header-cell *matHeaderCellDef>Phone</th>
        <td mat-cell *matCellDef="let driver">{{ driver.phone }}</td>
      </ng-container>

      <!-- Company Column -->
      <ng-container matColumnDef="company">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Company</th>
        <td mat-cell *matCellDef="let driver">{{ driver.company }}</td>
      </ng-container>

      <!-- Role Column -->
      <ng-container matColumnDef="role">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Role</th>
        <td mat-cell *matCellDef="let driver">
          <span class="role-chip" [ngClass]="getRoleClass(driver.role)">
            {{ driver.role || 'Driver' }}
          </span>
        </td>
      </ng-container>

      <!-- Type Column -->
      <ng-container matColumnDef="type">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Type</th>
        <td mat-cell *matCellDef="let driver">
          <span class="status-chip" [ngClass]="getTypeClass(driver.type)">
            {{ driver.type }}
          </span>
        </td>
      </ng-container>

      <!-- Status Column -->
      <ng-container matColumnDef="status">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Status</th>
        <td mat-cell *matCellDef="let driver">
          <span class="status-chip" [ngClass]="getStatusClass(driver.status)">
            {{ driver.status }}
          </span>
        </td>
      </ng-container>

      <!-- Last Activity Column -->
      <ng-container matColumnDef="lastActivity">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Last Activity</th>
        <td mat-cell *matCellDef="let driver">
          {{ driver.lastDriver | date : 'medium' }}
        </td>
      </ng-container>

      <!-- Actions Column -->
      <ng-container matColumnDef="actions">
        <th mat-header-cell *matHeaderCellDef></th>
        <td mat-cell *matCellDef="let driver">
          <button mat-icon-button [matMenuTriggerFor]="menu" (click)="$event.stopPropagation()">
            <mat-icon>more_vert</mat-icon>
          </button>
          <mat-menu #menu="matMenu" xPosition="before">
            <button mat-menu-item (click)="editDriver(driver)">
              <mat-icon>edit</mat-icon>
              <span>Edit</span>
            </button>
            <button mat-menu-item (click)="viewDriverJobs(driver, $event)">
              <mat-icon>work</mat-icon>
              <span>View Jobs</span>
            </button>
            <button mat-menu-item (click)="deleteDriver(driver, $event)" class="delete-action">
              <mat-icon>delete</mat-icon>
              <span>Delete</span>
            </button>
          </mat-menu>
        </td>
      </ng-container>

      <!-- Header and Data Rows -->
      <tr mat-header-row *matHeaderRowDef="displayedColumns; sticky: true"></tr>
      <tr mat-row *matRowDef="let row; columns: displayedColumns" (click)="editDriver(row)" [class.selected]="selection.isSelected(row)" class="driver-row"></tr>
    </table>

    <!-- Empty State -->
    <div class="empty-state" *ngIf="!isLoading && dataSource.filteredData.length === 0">
      <mat-icon class="empty-icon">people_outline</mat-icon>
      <h3>No drivers found</h3>
      <p>Try adjusting your filters or add a new driver</p>
      <button mat-flat-button color="primary" (click)="createNewDriver()">
        <mat-icon>add</mat-icon>
        New Driver
      </button>
    </div>
  </div>

  <!-- Paginator -->
  <mat-paginator [length]="dataSource.filteredData.length" [pageSize]="25" [pageSizeOptions]="[10, 25, 50, 100]" showFirstLastButtons> </mat-paginator>
</mat-card>

<!-- Export Menu -->
<mat-menu #exportMenu="matMenu">
  <button mat-menu-item (click)="exportAllDrivers()">
    <mat-icon>file_download</mat-icon>
    <span>Export All</span>
  </button>
  <button mat-menu-item [disabled]="selection.selected.length === 0" (click)="exportSelectedDrivers()">
    <mat-icon>checklist</mat-icon>
    <span>Export Selected ({{ selection.selected.length }})</span>
  </button>
</mat-menu>


--- ./src/app/pages/drivers/driver-list/driver-list.component.scss ---
// Main container styles
:host {
  display: block;
  padding: 24px;
  background-color: #f5f5f5;
  min-height: 100vh;
  margin-left: 250px; /* Account for sidebar width */
  padding-top: 88px; /* Account for topbar height (64px) + some padding */
}

// Card styles
.mat-mdc-card {
  margin-bottom: 24px;
  background-color: white;
  border-radius: 8px;
}

// Header Section
.header-wrapper {
  padding: 24px 24px 0;

  .header-title {
    h1 {
      margin: 0;
      font-size: 24px;
      font-weight: 500;
      color: var(--primary-color);
    }

    .subtitle {
      margin: 4px 0 0;
      color: rgba(0, 0, 0, 0.6);
      font-size: 14px;
    }
  }
}

// Filters and Actions Section
.filters-actions-wrapper {
  padding: 24px;
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 24px;
  border-bottom: 1px solid rgba(0, 0, 0, 0.12);

  .filters-section {
    display: flex;
    flex: 1;
    gap: 16px;
    align-items: flex-start;
    flex-direction: column;

    .search-field {
      width: 100%;
      max-width: 400px;

      ::ng-deep .mat-mdc-text-field-wrapper {
        background-color: #f8f9fa;
      }

      input {
        height: 20px;
      }
    }

    .filters-group {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      width: 100%;

      mat-form-field {
        flex: 1;
        min-width: 150px;
      }
    }
  }

  .actions-group {
    display: flex;
    gap: 12px;
    margin-left: auto;

    .export-button {
      height: 40px;
      padding: 0 16px;
      border-color: rgba(0, 0, 0, 0.12);

      &:hover {
        background-color: rgba(0, 0, 0, 0.04);
      }
    }

    .create-button {
      height: 40px;
      padding: 0 20px;
    }

    .mat-icon {
      margin-right: 8px;
    }
  }
}

// Table Container
.table-container {
  position: relative;
  min-height: 400px;
  overflow: auto;

  // Loading Overlay
  .loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255, 255, 255, 0.9);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    gap: 16px;

    span {
      color: rgba(0, 0, 0, 0.6);
      font-size: 14px;
      margin-top: 8px;
    }
  }

  // Table Styles
  table {
    width: 100%;

    &.loading {
      opacity: 0.6;
    }

    // Header Styles
    .mat-mdc-header-row {
      background-color: #f8f9fa;
      min-height: 48px;
    }

    .mat-mdc-header-cell {
      color: rgba(0, 0, 0, 0.6);
      font-size: 12px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      padding: 0 16px;
      white-space: nowrap;

      &:first-of-type {
        padding-left: 24px;
      }

      &:last-of-type {
        padding-right: 24px;
      }
    }

    // Cell Styles
    .mat-mdc-cell {
      font-size: 14px;
      color: rgba(0, 0, 0, 0.87);
      padding: 0 16px;

      &:first-of-type {
        padding-left: 24px;
      }

      &:last-of-type {
        padding-right: 24px;
      }

      // Email links
      a {
        color: #1976d2;
        text-decoration: none;

        &:hover {
          text-decoration: underline;
        }
      }
    }

    // Name cell with avatar
    .name-cell {
      display: flex;
      align-items: center;
      gap: 12px;

      .avatar {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        background-color: var(--primary-color);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 500;
        font-size: 14px;
      }

      .name-details {
        display: flex;
        flex-direction: column;

        .primary-text {
          font-weight: 500;
          color: rgba(0, 0, 0, 0.87);
        }

        .secondary-text {
          font-size: 12px;
          color: rgba(0, 0, 0, 0.6);
        }
      }
    }

    // Row Styles
    .driver-row {
      min-height: 52px;
      cursor: pointer;
      transition: background-color 0.2s ease;

      &:hover {
        background-color: #fafafa;
      }

      &.selected {
        background-color: #e3f2fd;
      }

      &:active {
        background-color: #e3f2fd;
      }
    }

    // Column Widths
    .mat-column-select {
      width: 48px;
      padding-right: 0;
    }

    .mat-column-actions {
      width: 48px;
      padding-left: 0;
    }

    .mat-column-id {
      width: 100px;
    }

    .mat-column-name {
      min-width: 200px;
    }

    .mat-column-email {
      min-width: 200px;
    }

    .mat-column-phone {
      min-width: 140px;
    }

    .mat-column-role,
    .mat-column-type,
    .mat-column-status {
      width: 120px;
    }
  }
}

// Role Chips
.role-chip {
  padding: 4px 12px;
  border-radius: 16px;
  font-size: 12px;
  font-weight: 500;
  display: inline-flex;
  align-items: center;
  text-transform: capitalize;

  &.role-admin {
    background-color: rgba(156, 39, 176, 0.12);
    color: #9c27b0;
  }

  &.role-manager {
    background-color: rgba(63, 81, 181, 0.12);
    color: #3f51b5;
  }

  &.role-dispatcher {
    background-color: rgba(0, 150, 136, 0.12);
    color: #009688;
  }

  &.role-driver {
    background-color: rgba(33, 150, 243, 0.12);
    color: #2196f3;
  }

  &.role-user {
    background-color: rgba(97, 97, 97, 0.12);
    color: #616161;
  }
}

// Status Chips
.status-chip {
  padding: 4px 12px;
  border-radius: 16px;
  font-size: 12px;
  font-weight: 500;
  display: inline-flex;
  align-items: center;
  text-transform: capitalize;

  // Type colors
  &.type-blue {
    background-color: rgba(25, 118, 210, 0.12);
    color: #1976d2;
  }

  &.type-purple {
    background-color: rgba(156, 39, 176, 0.12);
    color: #9c27b0;
  }

  &.type-orange {
    background-color: rgba(245, 124, 0, 0.12);
    color: #f57c00;
  }

  // Status colors
  &.status-green {
    background-color: rgba(76, 175, 80, 0.12);
    color: #4caf50;
  }

  &.status-gray {
    background-color: rgba(97, 97, 97, 0.12);
    color: #616161;
  }

  &.status-orange {
    background-color: rgba(255, 152, 0, 0.12);
    color: #ff9800;
  }
}

// Empty State
.empty-state {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  width: 100%;
  padding: 0 24px;
  box-sizing: border-box;

  .empty-icon {
    font-size: 48px;
    width: 48px;
    height: 48px;
    color: rgba(0, 0, 0, 0.38);
    margin-bottom: 16px;
  }

  h3 {
    margin: 0 0 8px;
    font-size: 16px;
    color: rgba(0, 0, 0, 0.87);
  }

  p {
    margin: 0 0 24px;
    color: rgba(0, 0, 0, 0.6);
    font-size: 14px;
  }

  button {
    min-width: 160px;
  }
}

// Delete Action
.delete-action {
  color: #f44336;
}

// Responsive Design
@media screen and (max-width: 1200px) {
  .filters-section {
    flex-direction: column;

    .search-field {
      width: 100%;
    }

    .filters-group {
      width: 100%;
    }
  }
}

@media screen and (max-width: 960px) {
  :host {
    padding: 16px;
    padding-top: 80px; /* Slightly reduced top padding */
  }

  .filters-actions-wrapper {
    flex-direction: column;

    .actions-group {
      width: 100%;
      justify-content: space-between;
    }
  }

  .mat-column-company,
  .mat-column-lastActivity {
    display: none;
  }
}

@media screen and (max-width: 768px) {
  :host {
    margin-left: 60px; /* Collapsed sidebar width */
    padding-top: 80px; /* Adjust for smaller topbar */
  }

  .mat-column-phone {
    display: none;
  }
}

@media screen and (max-width: 600px) {
  :host {
    padding: 8px;
    padding-top: 72px; /* Further reduced for mobile */
  }

  .header-wrapper {
    padding: 16px 16px 0;
  }

  .filters-actions-wrapper {
    padding: 16px;
  }

  .filters-group {
    flex-direction: column;

    mat-form-field {
      width: 100% !important;
    }
  }

  .actions-group {
    flex-direction: column;
    gap: 8px;
  }

  .mat-column-id {
    display: none;
  }
}

// Print Styles
@media print {
  :host {
    padding: 0;
    background: white;
    margin-left: 0; /* No sidebar in print */
    padding-top: 0; /* No topbar in print */
  }

  .mat-mdc-card {
    box-shadow: none !important;
  }

  .filters-actions-wrapper,
  .mat-mdc-paginator,
  .mat-column-select,
  .mat-column-actions {
    display: none !important;
  }

  .table-container {
    overflow: visible;
  }

  .driver-row {
    break-inside: avoid;
  }
}


--- ./src/app/pages/drivers/driver-list/driver-list.component.ts ---
import { Component, OnInit, ViewChild, AfterViewInit, OnDestroy } from '@angular/core';
import { Router } from '@angular/router';
import { MatTableDataSource } from '@angular/material/table';
import { MatSort } from '@angular/material/sort';
import { MatPaginator } from '@angular/material/paginator';
import { SelectionModel } from '@angular/cdk/collections';
import { MatDialog } from '@angular/material/dialog';
import { MatSnackBar } from '@angular/material/snack-bar';
import { Subscription } from 'rxjs';
import { finalize } from 'rxjs/operators';

import { AuthService } from '../../../services/auth.service';
import { DriverService } from '../../../services/driver.service';
import { ConfirmationDialogComponent } from '../../../dialogs/confirmation-dialog.component';
import { NotificationService } from '../../../services/notification.service';
import { UserProfile, UserRole } from '../../../interfaces/user-profile.interface';

@Component({
  selector: 'app-driver-list',
  templateUrl: './driver-list.component.html',
  styleUrls: ['./driver-list.component.scss'],
  standalone: false,
})
export class DriverListComponent implements OnInit, AfterViewInit, OnDestroy {
  displayedColumns: string[] = ['select', 'id', 'name', 'email', 'phone', 'company', 'role', 'type', 'status', 'lastActivity', 'actions'];

  isLoading = false;
  dataSource = new MatTableDataSource<UserProfile>([]);
  selection = new SelectionModel<UserProfile>(true, []);
  hasEditPermission = false;

  @ViewChild(MatSort) sort!: MatSort;
  @ViewChild(MatPaginator) paginator!: MatPaginator;

  typeFilter = 'All';
  roleFilter = 'All';
  statusFilter = 'All';

  typeOptions = ['All', 'Customer', 'Supplier', 'Partner'];
  roleOptions = ['All', ...Object.values(UserRole)];
  statusOptions = ['All', 'Active', 'Inactive', 'Pending'];

  private subscriptions: Subscription[] = [];

  constructor(
    private router: Router,
    private authService: AuthService,
    private driverService: DriverService,
    private dialog: MatDialog,
    private snackBar: MatSnackBar,
    private notificationService: NotificationService
  ) {}

  ngOnInit(): void {
    this.checkPermissions();
    this.loadDrivers();
  }

  ngAfterViewInit(): void {
    this.dataSource.sort = this.sort;
    this.dataSource.paginator = this.paginator;
    this.setupCustomFilter();
  }

  ngOnDestroy(): void {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }

  private checkPermissions(): void {
    const permissionSub = this.authService.hasPermission('canManageUsers').subscribe((hasPermission) => {
      this.hasEditPermission = hasPermission;
    });
    this.subscriptions.push(permissionSub);
  }

  private setupCustomFilter(): void {
    this.dataSource.filterPredicate = (data: UserProfile, filter: string) => {
      const searchText = filter.toLowerCase();
      const shouldInclude = (value: string | undefined) => value?.toLowerCase().includes(searchText) || false;

      // Apply type filter
      if (this.typeFilter !== 'All' && data.type?.toLowerCase() !== this.typeFilter.toLowerCase()) {
        return false;
      }

      // Apply role filter
      if (this.roleFilter !== 'All' && data.role !== this.roleFilter) {
        return false;
      }

      // Apply status filter
      if (this.statusFilter !== 'All' && data.status?.toLowerCase() !== this.statusFilter.toLowerCase()) {
        return false;
      }

      // Apply text search
      return (
        shouldInclude(data.firstName) ||
        shouldInclude(data.lastName) ||
        shouldInclude(data.name) ||
        shouldInclude(data.email) ||
        shouldInclude(data.company) ||
        shouldInclude(data.phoneNumber) ||
        shouldInclude(data.phone)
      );
    };
  }

  applyFilter(event: Event): void {
    const filterValue = (event.target as HTMLInputElement).value;
    this.dataSource.filter = filterValue.trim().toLowerCase();

    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage();
    }
  }

  onFilterChange(): void {
    // Force the filter to re-evaluate
    this.dataSource.filter = this.dataSource.filter || ' ';
  }

  loadDrivers(): void {
    this.isLoading = true;

    const driversSub = this.driverService
      .getAllDrivers()
      .pipe(finalize(() => (this.isLoading = false)))
      .subscribe({
        next: (drivers) => {
          this.dataSource.data = drivers;
        },
        error: (error) => {
          console.error('Error loading drivers:', error);
          this.snackBar.open('Error loading drivers', 'Close', { duration: 3000 });
        },
      });

    this.subscriptions.push(driversSub);
  }

  getStatusClass(status: string | undefined): string {
    if (!status) return 'status-gray';

    switch (status.toLowerCase()) {
      case 'active':
        return 'status-green';
      case 'pending':
        return 'status-orange';
      case 'inactive':
      default:
        return 'status-gray';
    }
  }

  getTypeClass(type: string | undefined): string {
    if (!type) return 'type-blue';

    switch (type.toLowerCase()) {
      case 'customer':
        return 'type-blue';
      case 'supplier':
        return 'type-purple';
      case 'partner':
        return 'type-orange';
      default:
        return 'type-blue';
    }
  }

  getRoleClass(role: string | undefined): string {
    if (!role) return 'role-driver';

    switch (role.toLowerCase()) {
      case 'admin':
        return 'role-admin';
      case 'system user':
        return 'role-manager';
      case 'contractor':
        return 'role-dispatcher';
      case 'driver':
        return 'role-driver';
      default:
        return 'role-driver';
    }
  }

  getDriverInitials(driver: UserProfile): string {
    if (!driver) return '??';

    if (driver.name && driver.name.length > 0) {
      const nameParts = driver.name.split(' ');
      if (nameParts.length > 1) {
        return (nameParts[0][0] + nameParts[1][0]).toUpperCase();
      }
      return nameParts[0][0].toUpperCase();
    }

    const firstName = driver.firstName || '';
    const lastName = driver.lastName || '';

    if (!firstName && !lastName) {
      return driver.email[0].toUpperCase();
    }

    return ((firstName[0] || '') + (lastName[0] || '')).toUpperCase();
  }

  isAllSelected(): boolean {
    const numSelected = this.selection.selected.length;
    const numRows = this.dataSource.data.length;
    return numSelected === numRows;
  }

  toggleAllRows(): void {
    if (this.isAllSelected()) {
      this.selection.clear();
      return;
    }
    this.selection.select(...this.dataSource.data);
  }

  checkboxLabel(row?: UserProfile): string {
    if (!row) {
      return `${this.isAllSelected() ? 'deselect' : 'select'} all`;
    }
    return `${this.selection.isSelected(row) ? 'deselect' : 'select'} row ${row.id}`;
  }

  createNewDriver(): void {
    this.router.navigate(['/drivers/new']);
  }

  editDriver(driver: UserProfile): void {
    this.router.navigate(['/drivers', driver.id]);
  }

  viewDriverJobs(driver: UserProfile, event?: Event): void {
    if (event) {
      event.stopPropagation(); // Prevent row click event
    }
    this.router.navigate(['/jobs'], {
      queryParams: {
        driverId: driver.id,
        driverName: `${driver.firstName} ${driver.lastName}`,
      },
    });
  }

  exportAllDrivers(): void {
    const allDrivers = this.dataSource.filteredData;
    this.downloadDriversCsv(allDrivers);
  }

  exportSelectedDrivers(): void {
    const selectedDrivers = this.selection.selected;
    if (selectedDrivers.length === 0) {
      this.showSnackbar('No drivers selected');
      return;
    }
    this.downloadDriversCsv(selectedDrivers);
  }

  private downloadDriversCsv(drivers: UserProfile[]): void {
    // Convert drivers to CSV format
    const headers = ['ID', 'First Name', 'Last Name', 'Email', 'Phone', 'Company', 'Role', 'Type', 'Status', 'Last Activity'];
    const rows = drivers.map((driver) => [
      driver.id,
      driver.firstName || '',
      driver.lastName || '',
      driver.email || '',
      driver.phone || driver.phoneNumber || '',
      driver.company || '',
      driver.role || '',
      driver.type || '',
      driver.status || (driver.isActive ? 'active' : 'inactive'),
      driver.lastActivity ? new Date(driver.lastActivity).toLocaleDateString() : '',
    ]);

    // Combine headers and rows
    const csvContent = [headers.join(','), ...rows.map((row) => row.join(','))].join('\n');

    // Create and trigger download
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', 'drivers.csv');
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    // Show success notification
    this.notificationService.addNotification({
      type: 'success',
      title: 'Export Complete',
      message: `${drivers.length} drivers exported successfully`,
    });
  }

  deleteDriver(driver: UserProfile, event: Event): void {
    event.stopPropagation();

    const dialogRef = this.dialog.open(ConfirmationDialogComponent, {
      data: {
        title: 'Delete Driver',
        message: `Are you sure you want to delete driver ${driver.firstName} ${driver.lastName}? This action cannot be undone.`,
        confirmText: 'Delete',
        cancelText: 'Cancel',
        confirmColor: 'warn',
        icon: 'delete_forever',
      },
      width: '400px',
    });

    dialogRef.afterClosed().subscribe((result) => {
      if (result) {
        this.driverService.deactivateDriver(driver.id).subscribe({
          next: () => {
            // Remove from the data source
            this.dataSource.data = this.dataSource.data.filter((d) => d.id !== driver.id);

            // Show success notification
            this.notificationService.addNotification({
              type: 'success',
              title: 'Driver Deleted',
              message: `${driver.firstName} ${driver.lastName} has been deleted successfully`,
            });
          },
          error: (error) => {
            console.error(`Error deleting driver ${driver.id}:`, error);
            this.snackBar.open('Error deleting driver', 'Close', { duration: 3000 });
          },
        });
      }
    });
  }

  private showSnackbar(message: string): void {
    this.snackBar.open(message, 'Close', {
      duration: 3000,
      horizontalPosition: 'center',
      verticalPosition: 'bottom',
    });
  }
}


--- ./src/app/pages/drivers/driver-edit/driver-edit.component.html ---
<!-- driver-edit.component.html -->
<div class="driver-edit-container">
  <!-- Loading Overlay -->
  <div class="loading-overlay" *ngIf="isLoading">
    <mat-spinner diameter="40"></mat-spinner>
    <span>Loading driver data...</span>
  </div>

  <div class="content-wrapper" *ngIf="driver">
    <!-- Back Button and Header -->
    <div class="page-header">
      <button mat-icon-button class="back-button" (click)="cancel()">
        <mat-icon>arrow_back</mat-icon>
      </button>
      <div class="header-content">
        <h1>Edit Driver</h1>
        <p class="subtitle">Update information for {{ driver.firstName }} {{ driver.lastName }}</p>
      </div>
    </div>

    <!-- Form Cards -->
    <div class="form-grid">
      <!-- Basic Information Card -->
      <mat-card class="form-card">
        <mat-card-header>
          <mat-icon mat-card-avatar>person</mat-icon>
          <mat-card-title>Basic Information</mat-card-title>
          <mat-card-subtitle>Driver profile details</mat-card-subtitle>
        </mat-card-header>

        <mat-card-content>
          <form [formGroup]="driverForm" class="form-content">
            <div class="form-row">
              <mat-form-field appearance="outline">
                <mat-label>First Name</mat-label>
                <input matInput formControlName="firstName" placeholder="Enter first name" required />
                <mat-error *ngIf="driverForm.get('firstName')?.hasError('required')">First name is required</mat-error>
              </mat-form-field>

              <mat-form-field appearance="outline">
                <mat-label>Last Name</mat-label>
                <input matInput formControlName="lastName" placeholder="Enter last name" required />
                <mat-error *ngIf="driverForm.get('lastName')?.hasError('required')">Last name is required</mat-error>
              </mat-form-field>
            </div>

            <div class="form-row">
              <mat-form-field appearance="outline">
                <mat-label>Email</mat-label>
                <input matInput formControlName="email" placeholder="Enter email address" required type="email" />
                <mat-icon matSuffix>email</mat-icon>
                <mat-error *ngIf="driverForm.get('email')?.hasError('required')">Email is required</mat-error>
                <mat-error *ngIf="driverForm.get('email')?.hasError('email')">Please enter a valid email address</mat-error>
              </mat-form-field>

              <mat-form-field appearance="outline">
                <mat-label>Phone Number</mat-label>
                <input matInput formControlName="phoneNumber" placeholder="Enter phone number" />
                <mat-icon matSuffix>phone</mat-icon>
                <mat-error *ngIf="driverForm.get('phoneNumber')?.hasError('pattern')">Please enter a valid phone number</mat-error>
              </mat-form-field>
            </div>

            <div class="form-row">
              <mat-form-field appearance="outline">
                <mat-label>Company</mat-label>
                <input matInput formControlName="company" placeholder="Company name (optional)" />
                <mat-icon matSuffix>business</mat-icon>
              </mat-form-field>

              <mat-form-field appearance="outline">
                <mat-label>Driver Type</mat-label>
                <mat-select formControlName="type">
                  <mat-option *ngFor="let type of getDriverTypes()" [value]="type">
                    {{ type | titlecase }}
                  </mat-option>
                </mat-select>
                <mat-icon matSuffix>category</mat-icon>
              </mat-form-field>
            </div>
          </form>
        </mat-card-content>
      </mat-card>

      <!-- Driver Settings Card -->
      <mat-card class="form-card">
        <mat-card-header>
          <mat-icon mat-card-avatar>settings</mat-icon>
          <mat-card-title>Driver Settings</mat-card-title>
          <mat-card-subtitle>Access and account settings</mat-card-subtitle>
        </mat-card-header>

        <mat-card-content>
          <form [formGroup]="driverForm" class="form-content">
            <div class="form-row">
              <mat-form-field appearance="outline">
                <mat-label>Role</mat-label>
                <mat-select formControlName="role" required (selectionChange)="onRoleChange($event)">
                  <mat-option *ngFor="let role of availableRoles" [value]="role">
                    {{ role }}
                  </mat-option>
                </mat-select>
                <mat-hint>Role will automatically set appropriate permissions</mat-hint>
                <mat-error *ngIf="driverForm.get('role')?.hasError('required')">Role is required</mat-error>
              </mat-form-field>

              <mat-form-field appearance="outline">
                <mat-label>Status</mat-label>
                <mat-select formControlName="status" required>
                  <mat-option value="active">Active</mat-option>
                  <mat-option value="inactive">Inactive</mat-option>
                  <mat-option value="pending">Pending</mat-option>
                </mat-select>
                <mat-icon matSuffix>toggle_on</mat-icon>
                <mat-error *ngIf="driverForm.get('status')?.hasError('required')">Status is required</mat-error>
              </mat-form-field>
            </div>

            <!-- Admin notice -->
            <div class="admin-notice" *ngIf="!isCurrentUserAdmin">
              <mat-icon>info</mat-icon>
              <p>
                Permissions are automatically set based on the selected role. Only administrators can modify individual permissions.
                <span *ngIf="driverForm.get('role')?.value === 'Admin'" class="warning-text">
                  Note: You cannot edit Admin users. Contact an administrator for help.
                </span>
              </p>
            </div>

            <!-- Role permissions summary -->
            <div class="role-permissions-summary">
              <p>
                <strong>{{ driverForm.get('role')?.value }}</strong
                >:
                <span *ngIf="driverForm.get('role')?.value === 'Admin'"> Has full access to all system features and settings. </span>
                <span *ngIf="driverForm.get('role')?.value === 'Driver'"> Can view and manage assigned jobs and submit expenses. </span>
                <span *ngIf="driverForm.get('role')?.value === 'Contractor'"> Has limited access to view only assigned jobs and submit expenses. </span>
                <span *ngIf="driverForm.get('role')?.value === 'System User'"> Can access most features except system administration. </span>
              </p>
            </div>
          </form>
        </mat-card-content>
      </mat-card>

      <!-- Driver License Card -->
      <mat-card class="form-card">
        <mat-card-header>
          <mat-icon mat-card-avatar>badge</mat-icon>
          <mat-card-title>License Information</mat-card-title>
          <mat-card-subtitle>Driver's license and qualifications</mat-card-subtitle>
        </mat-card-header>

        <mat-card-content>
          <form [formGroup]="driverForm" class="form-content">
            <div class="form-row">
              <mat-form-field appearance="outline">
                <mat-label>License Number</mat-label>
                <input matInput formControlName="licenseNumber" placeholder="Driver's license number" />
                <mat-icon matSuffix>credit_card</mat-icon>
              </mat-form-field>

              <mat-form-field appearance="outline">
                <mat-label>License Expiry Date</mat-label>
                <input matInput [matDatepicker]="picker" formControlName="licenseExpiry" placeholder="License expiry date" />
                <mat-hint>MM/DD/YYYY</mat-hint>
                <mat-datepicker-toggle matIconSuffix [for]="picker"></mat-datepicker-toggle>
                <mat-datepicker #picker></mat-datepicker>
              </mat-form-field>
            </div>

            <div class="form-row">
              <mat-form-field appearance="outline">
                <mat-label>Vehicle Type</mat-label>
                <input matInput formControlName="vehicleType" placeholder="Vehicle types qualified to drive" />
                <mat-icon matSuffix>directions_car</mat-icon>
              </mat-form-field>

              <mat-form-field appearance="outline">
                <mat-label>Availability</mat-label>
                <mat-select formControlName="availability">
                  <mat-option *ngFor="let option of getAvailabilityOptions()" [value]="option">
                    {{ option }}
                  </mat-option>
                </mat-select>
                <mat-icon matSuffix>schedule</mat-icon>
              </mat-form-field>
            </div>

            <div class="form-row full-width">
              <mat-form-field appearance="outline">
                <mat-label>Area Coverage</mat-label>
                <textarea matInput formControlName="areaCoverage" placeholder="Geographic areas covered" rows="2"></textarea>
                <mat-icon matSuffix>pin_drop</mat-icon>
              </mat-form-field>
            </div>
          </form>
        </mat-card-content>
      </mat-card>

      <!-- Permissions Section -->
      <mat-card class="form-card" *ngIf="isCurrentUserAdmin">
        <mat-card-header>
          <mat-icon mat-card-avatar>security</mat-icon>
          <mat-card-title>Advanced Permissions</mat-card-title>
          <mat-card-subtitle>Custom permission settings (Admin only)</mat-card-subtitle>
        </mat-card-header>

        <mat-card-content>
          <div class="admin-editor-notice">
            <mat-icon>admin_panel_settings</mat-icon>
            <p>As an administrator, you can override the default permissions for this role by checking or unchecking boxes below.</p>
          </div>

          <form [formGroup]="driverForm" class="form-content">
            <div formGroupName="permissions" class="permissions-grid">
              <!-- General Permissions -->
              <div class="permissions-category">
                <h3>General Permissions</h3>
                <div class="permission-group">
                  <mat-checkbox formControlName="isAdmin" color="primary" [class.admin-only]="true">
                    Administrator
                    <span class="admin-badge" *ngIf="!isCurrentUserAdmin">Admin Only</span>
                  </mat-checkbox>
                  <mat-checkbox formControlName="canManageUsers" color="primary"> Manage Users </mat-checkbox>
                  <mat-checkbox formControlName="canViewSystemSettings" color="primary"> View System Settings </mat-checkbox>
                  <mat-checkbox formControlName="canManageCompanies" color="primary"> Manage Companies </mat-checkbox>
                </div>
              </div>

              <!-- Job Management -->
              <div class="permissions-category">
                <h3>Job Management</h3>
                <div class="permission-group">
                  <mat-checkbox formControlName="canViewAllJobs" color="primary"> View All Jobs </mat-checkbox>
                  <mat-checkbox formControlName="canViewAssignedJobs" color="primary"> View Assigned Jobs </mat-checkbox>
                  <mat-checkbox formControlName="canCreateJobs" color="primary"> Create Jobs </mat-checkbox>
                  <mat-checkbox formControlName="canEditJobs" color="primary"> Edit Jobs </mat-checkbox>
                  <mat-checkbox formControlName="canAllocateJobs" color="primary"> Allocate Jobs </mat-checkbox>
                  <mat-checkbox formControlName="canViewUnallocated" color="primary"> View Unallocated Jobs </mat-checkbox>
                </div>
              </div>

              <!-- Financial Permissions -->
              <div class="permissions-category">
                <h3>Financial Permissions</h3>
                <div class="permission-group">
                  <mat-checkbox formControlName="canCreateExpenses" color="primary"> Create Expenses </mat-checkbox>
                  <mat-checkbox formControlName="canApproveExpenses" color="primary"> Approve Expenses </mat-checkbox>
                  <mat-checkbox formControlName="canViewReports" color="primary"> View Reports </mat-checkbox>
                </div>
              </div>
            </div>
          </form>
        </mat-card-content>
      </mat-card>
    </div>

    <!-- Form Actions -->
    <div class="form-actions">
      <button mat-stroked-button (click)="cancel()">
        <mat-icon>close</mat-icon>
        Cancel
      </button>
      <button mat-flat-button color="primary" (click)="onSubmit()" [disabled]="driverForm.invalid || isSubmitting">
        <mat-icon>save</mat-icon>
        {{ isSubmitting ? 'Saving...' : 'Update Driver' }}
      </button>
    </div>
  </div>
</div>


--- ./src/app/pages/drivers/driver-edit/driver-edit.component.scss ---
:host {
  display: block;
  padding: 24px;
  background-color: #f5f5f5;
  min-height: 100vh;
  margin-left: 250px; /* Account for sidebar width */
  padding-top: 88px; /* Account for topbar height (64px) + some padding */
}

.driver-edit-container {
  max-width: 1200px;
  margin: 0 auto;
  position: relative;
}

/* Loading Overlay */
.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.9);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  gap: 16px;

  span {
    color: rgba(0, 0, 0, 0.6);
    font-size: 14px;
    margin-top: 8px;
  }
}

/* Content Wrapper */
.content-wrapper {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

/* Page Header */
.page-header {
  display: flex;
  align-items: center;
  gap: 16px;
  margin-bottom: 8px;

  .back-button {
    background-color: white;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    transition: transform 0.2s;

    &:hover {
      transform: translateX(-3px);
    }
  }

  .header-content {
    h1 {
      margin: 0;
      font-size: 28px;
      font-weight: 600;
      color: var(--primary-color);
    }

    .subtitle {
      margin: 4px 0 0;
      color: rgba(0, 0, 0, 0.6);
      font-size: 16px;
    }
  }
}

/* Form Grid Layout */
.form-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  grid-gap: 24px;

  @media (max-width: 1024px) {
    grid-template-columns: 1fr;
  }
}

/* Form Card Styling */
.form-card {
  border-radius: 12px;
  overflow: hidden;
  transition: transform 0.2s, box-shadow 0.2s;
  height: fit-content;

  &:hover {
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
    transform: translateY(-2px);
  }

  mat-card-header {
    padding: 16px 16px 0 16px;
    background-color: #fafafa;
    border-bottom: 1px solid rgba(0, 0, 0, 0.06);

    .mat-mdc-card-avatar {
      background-color: var(--primary-color);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      padding: 8px;
    }

    mat-card-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 4px;
      color: var(--primary-color);
    }

    mat-card-subtitle {
      color: rgba(0, 0, 0, 0.6);
      font-size: 14px;
    }
  }

  mat-card-content {
    padding: 24px 16px;
  }
}

/* Form Content */
.form-content {
  .form-row {
    display: flex;
    gap: 16px;
    margin-bottom: 16px;

    &.full-width {
      flex-direction: column;
    }

    mat-form-field {
      flex: 1;
      width: 100%;
    }
  }
}

/* Admin Notice Banner */
.admin-notice {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  margin-bottom: 20px;
  padding: 12px 16px;
  background-color: #f0f7ff;
  border-radius: 6px;
  border-left: 4px solid #2196f3;

  mat-icon {
    color: #2196f3;
    margin-top: 2px;
  }

  p {
    margin: 0;
    font-size: 14px;
    color: rgba(0, 0, 0, 0.7);
    line-height: 1.5;

    .warning-text {
      display: block;
      margin-top: 8px;
      color: #f44336;
      font-weight: 500;
    }
  }
}

.admin-editor-notice {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  margin-bottom: 20px;
  padding: 12px 16px;
  background-color: #f3e5f5;
  border-radius: 6px;
  border-left: 4px solid #9c27b0;

  mat-icon {
    color: #9c27b0;
    margin-top: 2px;
  }

  p {
    margin: 0;
    font-size: 14px;
    color: rgba(0, 0, 0, 0.7);
    line-height: 1.5;
  }
}

/* Role permissions summary */
.role-permissions-summary {
  margin-top: 16px;
  padding: 16px;
  background-color: #edf7ff;
  border-radius: 8px;
  border-left: 4px solid var(--primary-color);

  p {
    margin: 0;
    font-size: 14px;
    line-height: 1.5;
    color: rgba(0, 0, 0, 0.8);
  }

  strong {
    font-weight: 500;
  }
}

/* Permissions Grid */
.permissions-grid {
  display: grid;
  grid-template-columns: repeat(1, 1fr);
  gap: 24px;
  margin-top: 16px;

  .permissions-category {
    background-color: #f9f9f9;
    border-radius: 8px;
    padding: 16px;

    h3 {
      font-size: 16px;
      font-weight: 500;
      color: var(--primary-color);
      margin: 0 0 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.08);
    }

    .permission-group {
      display: grid;
      grid-template-columns: repeat(1, 1fr);
      gap: 12px;
    }
  }
}

/* Admin-only checkbox styling */
.admin-only {
  position: relative;

  .admin-badge {
    position: absolute;
    right: -70px;
    top: 0;
    background-color: #9c27b0;
    color: white;
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 10px;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
}

/* Form Actions */
.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  margin-top: 16px;

  button {
    min-width: 120px;
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 0 24px;
    height: 48px;
  }
}

/* Media Queries for Responsive Design */
@media (min-width: 992px) {
  .permissions-grid {
    grid-template-columns: repeat(2, 1fr) !important;

    .permissions-category:last-child {
      grid-column: span 2;
    }
  }

  .permissions-category .permission-group {
    grid-template-columns: repeat(2, 1fr) !important;
  }
}

@media (max-width: 768px) {
  :host {
    margin-left: 60px; /* Collapsed sidebar width */
    padding-top: 80px;
    padding: 16px;
  }

  .form-row {
    flex-direction: column !important;
  }

  .form-actions {
    flex-direction: column-reverse;

    button {
      width: 100%;
    }
  }

  .admin-badge {
    position: static !important;
    display: inline-block;
    margin-left: 8px;
  }
}

@media (max-width: 480px) {
  .page-header {
    flex-direction: column;
    align-items: flex-start;

    .back-button {
      align-self: flex-start;
    }
  }
}


--- ./src/app/pages/drivers/driver-edit/driver-edit.component.ts ---
import { Component, OnInit, OnDestroy } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { ActivatedRoute, Router } from '@angular/router';
import { MatSnackBar } from '@angular/material/snack-bar';
import { Subscription } from 'rxjs';
import { finalize } from 'rxjs/operators';

import { AuthService } from '../../../services/auth.service';
import { DriverService } from '../../../services/driver.service';
import { NotificationService } from '../../../services/notification.service';
import { UserProfile, UserRole, ROLE_PERMISSION_PRESETS } from '../../../interfaces/user-profile.interface';

@Component({
  selector: 'app-driver-edit',
  templateUrl: './driver-edit.component.html',
  styleUrls: ['./driver-edit.component.scss'],
  standalone: false,
})
export class DriverEditComponent implements OnInit, OnDestroy {
  driverForm!: FormGroup;
  isLoading = false;
  isSubmitting = false;
  driverId: string = '';
  driver: UserProfile | null = null;

  // Current user permissions
  isCurrentUserAdmin = false;

  // Available options for dropdowns
  availableRoles = Object.values(UserRole);

  private subscriptions: Subscription[] = [];

  constructor(
    private fb: FormBuilder,
    private authService: AuthService,
    private driverService: DriverService,
    private router: Router,
    private route: ActivatedRoute,
    private snackBar: MatSnackBar,
    private notificationService: NotificationService
  ) {
    this.createForm();
  }

  ngOnInit(): void {
    // Check if the current user is an admin
    const adminSub = this.authService.getUserProfile().subscribe((userProfile) => {
      this.isCurrentUserAdmin = !!userProfile?.permissions?.isAdmin;

      // Make permissions form controls readonly if not admin
      this.setPermissionsReadonly(!this.isCurrentUserAdmin);

      // If not admin, remove Admin from available roles
      if (!this.isCurrentUserAdmin) {
        this.availableRoles = this.availableRoles.filter((role) => role !== UserRole.ADMIN);
      }
    });

    this.subscriptions.push(adminSub);

    // Get driver ID from route
    const routeSub = this.route.paramMap.subscribe((params) => {
      const id = params.get('id');
      if (id) {
        this.driverId = id;
        this.loadDriverData();
      } else {
        this.notificationService.addNotification({
          type: 'error',
          title: 'Error',
          message: 'Driver ID not provided',
        });
        this.router.navigate(['/drivers']);
      }
    });
    this.subscriptions.push(routeSub);
  }

  ngOnDestroy(): void {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }

  /**
   * Create the driver form with validation
   */
  private createForm(): void {
    this.driverForm = this.fb.group({
      firstName: ['', Validators.required],
      lastName: ['', Validators.required],
      email: ['', [Validators.required, Validators.email]],
      phoneNumber: ['', Validators.pattern(/^[+]?[(]?[0-9]{3}[)]?[-\s.]?[0-9]{3}[-\s.]?[0-9]{4,6}$/)],
      role: [UserRole.DRIVER, Validators.required],
      status: ['active', Validators.required],

      // Additional driver details
      company: [''],
      type: ['customer'],
      licenseNumber: [''],
      licenseExpiry: [''],
      vehicleType: [''],
      areaCoverage: [''],
      availability: [''],

      // Permissions
      permissions: this.fb.group({
        canAllocateJobs: [{ value: false, disabled: true }],
        canApproveExpenses: [{ value: false, disabled: true }],
        canCreateJobs: [{ value: false, disabled: true }],
        canEditJobs: [{ value: false, disabled: true }],
        canManageUsers: [{ value: false, disabled: true }],
        canViewReports: [{ value: false, disabled: true }],
        canViewUnallocated: [{ value: false, disabled: true }],
        isAdmin: [{ value: false, disabled: true }],
        canViewSystemSettings: [{ value: false, disabled: true }],
        canManageCompanies: [{ value: false, disabled: true }],
        canViewAllJobs: [{ value: false, disabled: true }],
        canViewAssignedJobs: [{ value: true, disabled: true }],
        canCreateExpenses: [{ value: false, disabled: true }],
      }),
    });
  }

  /**
   * Set permissions form controls to readonly or editable
   */
  private setPermissionsReadonly(readonly: boolean): void {
    const permissionsGroup = this.driverForm.get('permissions') as FormGroup;
    if (!permissionsGroup) return;

    Object.keys(permissionsGroup.controls).forEach((controlName) => {
      const control = permissionsGroup.get(controlName);
      if (control) {
        if (readonly) {
          control.disable();
        } else {
          // Only enable non-admin controls or if the current user is admin
          if (controlName !== 'isAdmin' || this.isCurrentUserAdmin) {
            control.enable();
          }
        }
      }
    });
  }

  /**
   * Load driver data
   */
  private loadDriverData(): void {
    this.isLoading = true;

    const userSub = this.driverService
      .getDriverById(this.driverId)
      .pipe(finalize(() => (this.isLoading = false)))
      .subscribe({
        next: (driver) => {
          if (driver) {
            this.driver = driver;
            this.updateFormWithDriverData(driver);
          } else {
            this.notificationService.addNotification({
              type: 'error',
              title: 'Error',
              message: 'Driver not found',
            });
            this.router.navigate(['/drivers']);
          }
        },
        error: (error) => {
          console.error('Error loading driver:', error);
          this.notificationService.addNotification({
            type: 'error',
            title: 'Error',
            message: 'Failed to load driver data',
          });
          this.router.navigate(['/drivers']);
        },
      });

    this.subscriptions.push(userSub);
  }

  /**
   * Update form with driver data
   */
  private updateFormWithDriverData(driver: UserProfile): void {
    // Check if editing an admin and current user is not admin
    const driverRole = driver.role || '';
    if (driverRole === UserRole.ADMIN && !this.isCurrentUserAdmin) {
      this.notificationService.addNotification({
        type: 'warning',
        title: 'Permission Restricted',
        message: 'You do not have permission to edit admin accounts. Contact an administrator for help.',
      });
      this.router.navigate(['/drivers']);
      return;
    }

    // Update form with driver data
    this.driverForm.patchValue({
      firstName: driver.firstName || '',
      lastName: driver.lastName || '',
      email: driver.email || '',
      phoneNumber: driver.phoneNumber || driver.phone || '',
      role: driver.role || UserRole.DRIVER,
      status: driver.isActive ? 'active' : 'inactive',
      company: driver.company || '',
      type: driver.type || 'customer',
      licenseNumber: driver.licenseNumber || '',
      licenseExpiry: driver.licenseExpiry || '',
      vehicleType: driver.vehicleType || '',
      areaCoverage: driver.areaCoverage || '',
      availability: driver.availability || '',
    });

    // Update permissions values with null safety checks
    const permissionsGroup = this.driverForm.get('permissions') as FormGroup;
    if (permissionsGroup && driver.permissions) {
      Object.keys(driver.permissions).forEach((key) => {
        const control = permissionsGroup.get(key);
        if (control) {
          control.setValue(!!driver.permissions?.[key]);
        }
      });
    }
  }

  /**
   * Handle role change - set default permissions based on role
   */
  onRoleChange(event: any): void {
    const selectedRole = event.value as UserRole;
    this.applyRolePermissions(selectedRole);
  }

  /**
   * Apply preset permissions based on selected role
   */
  private applyRolePermissions(role: UserRole): void {
    const permissionsGroup = this.driverForm.get('permissions') as FormGroup;
    if (!permissionsGroup) return;

    // Get the preset permissions for the selected role
    const presetPermissions = ROLE_PERMISSION_PRESETS[role];
    if (!presetPermissions) return;

    // Apply each permission to the form
    Object.entries(presetPermissions).forEach(([key, value]) => {
      const control = permissionsGroup.get(key);
      if (control) {
        // Check if setting admin status and current user is not admin
        if (key === 'isAdmin' && value === true && !this.isCurrentUserAdmin) {
          // Skip setting admin status
          return;
        }

        control.setValue(value);
      }
    });
  }

  /**
   * Submit the form to update driver
   */
  onSubmit(): void {
    if (this.driverForm.invalid) {
      this.markFormGroupTouched(this.driverForm);
      return;
    }

    this.isSubmitting = true;

    const formValues = this.driverForm.value;
    const permissionsGroup = this.driverForm.get('permissions') as FormGroup;

    // Set permissions from the role if controls are disabled (non-admin user)
    if (permissionsGroup && permissionsGroup.disabled) {
      const role = (formValues.role as UserRole) || UserRole.DRIVER;
      formValues.permissions = ROLE_PERMISSION_PRESETS[role];

      // Ensure non-admins can't set admin status
      if (!this.isCurrentUserAdmin) {
        formValues.permissions.isAdmin = false;
      }
    }

    // Update driver
    this.updateDriver(formValues);
  }

  /**
   * Update driver
   */
  private updateDriver(formValues: any): void {
    const updateSub = this.driverService.updateDriver(this.driverId, formValues).subscribe({
      next: () => {
        this.isSubmitting = false;

        this.notificationService.addNotification({
          type: 'success',
          title: 'Driver Updated',
          message: `${formValues.firstName} ${formValues.lastName} has been updated successfully`,
        });

        this.router.navigate(['/drivers', this.driverId]);
      },
      error: (error) => {
        this.handleError(error);
      },
    });

    this.subscriptions.push(updateSub);
  }

  /**
   * Handle form submission errors
   */
  private handleError(error: any): void {
    console.error('Error updating driver:', error);

    this.isSubmitting = false;

    this.notificationService.addNotification({
      type: 'error',
      title: 'Error',
      message: `Failed to update driver. ${error.message || ''}`,
    });
  }

  /**
   * Mark all form controls as touched to show validation errors
   */
  private markFormGroupTouched(formGroup: FormGroup): void {
    Object.values(formGroup.controls).forEach((control) => {
      control.markAsTouched();

      if (control instanceof FormGroup) {
        this.markFormGroupTouched(control);
      }
    });
  }

  /**
   * Cancel form and return to driver details
   */
  cancel(): void {
    this.router.navigate(['/drivers', this.driverId]);
  }

  /**
   * Check if current user can edit admin permissions
   */
  canManageAdminPermissions(): boolean {
    return this.isCurrentUserAdmin;
  }

  /**
   * Get available driver types
   */
  getDriverTypes(): string[] {
    return ['customer', 'supplier', 'partner'];
  }

  /**
   * Get available availability options
   */
  getAvailabilityOptions(): string[] {
    return ['Full-time', 'Part-time', 'Weekdays Only', 'Weekends Only', 'On Demand'];
  }
}


--- ./src/app/pages/drivers/driver-create/driver-create.component.scss ---
:host {
  display: block;
  padding: 24px;
  background-color: #f5f5f5;
  min-height: 100vh;
  margin-left: 250px; /* Account for sidebar width */
  padding-top: 88px; /* Account for topbar height (64px) + some padding */
}

.driver-form-container {
  max-width: 1200px;
  margin: 0 auto;
  position: relative;
}

/* Loading Overlay */
.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.9);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  gap: 16px;

  span {
    color: rgba(0, 0, 0, 0.6);
    font-size: 14px;
    margin-top: 8px;
  }
}

/* Form Card */
.form-card {
  margin-bottom: 24px;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
  overflow: hidden;
}

/* Header Section */
.header-wrapper {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 24px;
  border-bottom: 1px solid rgba(0, 0, 0, 0.12);
  background-color: var(--primary-color);
  color: white;

  .header-title {
    display: flex;
    align-items: center;
    gap: 16px;

    .back-button {
      color: white;
      background: rgba(255, 255, 255, 0.1);

      &:hover {
        background: rgba(255, 255, 255, 0.2);
      }
    }

    h1 {
      margin: 0;
      font-size: 24px;
      font-weight: 600;
      color: white;
    }

    .subtitle {
      margin: 4px 0 0;
      color: rgba(255, 255, 255, 0.8);
      font-size: 14px;
    }
  }

  .header-actions {
    display: flex;
    gap: 12px;

    button {
      display: flex;
      align-items: center;
      gap: 8px;

      &.mat-mdc-stroked-button {
        color: white;
        border-color: rgba(255, 255, 255, 0.5);

        &:hover {
          background: rgba(255, 255, 255, 0.1);
        }
      }

      &.mat-mdc-flat-button {
        background-color: rgba(255, 255, 255, 0.9);
        color: var(--primary-color);

        &:hover {
          background-color: white;
        }

        &:disabled {
          background-color: rgba(255, 255, 255, 0.3);
          color: rgba(0, 0, 0, 0.3);
        }
      }
    }
  }
}

/* Tab styles */
:host ::ng-deep {
  .mat-mdc-tab-header {
    margin-bottom: 20px;
  }

  .mat-mdc-tab-label {
    height: 54px;
    opacity: 1;

    .mat-mdc-tab-label-content {
      font-weight: 500;
    }
  }

  .mat-mdc-tab-body-content {
    padding: 0;
    overflow: hidden;
  }
}

.tab-content {
  padding: 0 24px 24px;
}

/* Form Content */
.form-content {
  padding: 24px 0 0;

  /* Section Styles */
  .form-section {
    margin-bottom: 32px;
    background-color: #fff;
    border-radius: 8px;
    padding: 24px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);

    &:last-child {
      margin-bottom: 0;
    }

    .section-title {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 20px;

      mat-icon {
        color: var(--primary-color);
        background-color: rgba(var(--primary-color-rgb), 0.1);
        padding: 8px;
        border-radius: 50%;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      h2 {
        font-size: 18px;
        font-weight: 600;
        color: var(--primary-color);
        margin: 0;
      }
    }

    .form-hint {
      font-size: 14px;
      color: rgba(0, 0, 0, 0.6);
      margin: 0 0 16px;
    }
  }

  /* Admin Notice Banner */
  .admin-notice {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    margin-bottom: 20px;
    padding: 12px 16px;
    background-color: #f0f7ff;
    border-radius: 6px;
    border-left: 4px solid #2196f3;

    mat-icon {
      color: #2196f3;
      margin-top: 2px;
    }

    p {
      margin: 0;
      font-size: 14px;
      color: rgba(0, 0, 0, 0.7);
      line-height: 1.5;

      .warning-text {
        display: block;
        margin-top: 8px;
        color: #f44336;
        font-weight: 500;
      }
    }

    &.admin-editor-notice {
      background-color: #f3e5f5;
      border-left-color: #9c27b0;

      mat-icon {
        color: #9c27b0;
      }
    }
  }

  /* Grid Layout for Form Fields */
  .form-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 16px;

    .full-width {
      grid-column: span 2;
    }
  }

  /* Permissions Grid */
  .permissions-grid {
    display: grid;
    grid-template-columns: repeat(1, 1fr);
    gap: 24px;
    margin-top: 16px;

    .permissions-category {
      background-color: #f9f9f9;
      border-radius: 8px;
      padding: 16px;

      h3 {
        font-size: 16px;
        font-weight: 500;
        color: var(--primary-color);
        margin: 0 0 12px;
        padding-bottom: 8px;
        border-bottom: 1px solid rgba(0, 0, 0, 0.08);
      }

      .permission-group {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
      }
    }
  }

  /* Admin-only checkbox styling */
  .admin-only {
    position: relative;

    .admin-badge {
      position: absolute;
      right: -70px;
      top: 0;
      background-color: #9c27b0;
      color: white;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 10px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
  }

  /* Disabled checkboxes styling */
  ::ng-deep {
    .mat-mdc-checkbox.mdc-checkbox--disabled {
      .mdc-checkbox__background {
        opacity: 0.6;
      }

      .mdc-checkbox__native-control:disabled ~ .mdc-checkbox__background {
        border-color: rgba(0, 0, 0, 0.26) !important;
      }

      .mdc-form-field label {
        color: rgba(0, 0, 0, 0.6);
      }
    }
  }

  /* Role permissions summary */
  .role-permissions-summary {
    margin-top: 24px;
    padding: 16px;
    background-color: #edf7ff;
    border-radius: 8px;
    border-left: 4px solid var(--primary-color);

    p {
      margin: 0;
      font-size: 14px;
      line-height: 1.5;
      color: rgba(0, 0, 0, 0.8);
    }

    strong {
      font-weight: 500;
    }
  }

  /* Send Credentials Option */
  .send-credentials-option {
    grid-column: span 2;
    margin-top: 8px;
    display: flex;
    flex-direction: column;

    .helper-text {
      font-size: 12px;
      color: rgba(0, 0, 0, 0.6);
      margin-top: 4px;
      margin-left: 24px; /* Align with checkbox text */
    }
  }

  /* Permissions section */
  .permissions-section {
    margin-top: 24px;
  }
}

/* Form Actions */
.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  padding: 16px 24px 24px;
  border-top: 1px solid rgba(0, 0, 0, 0.12);
  background-color: #f9f9f9;

  button {
    min-width: 120px;
  }
}

/* Form Field Customization */
::ng-deep {
  .mat-mdc-form-field-appearance-outline {
    .mat-mdc-form-field-wrapper {
      margin: 0;
      padding: 0;
    }

    .mat-mdc-form-field-infix {
      min-height: unset;
    }
  }

  .mat-mdc-checkbox {
    .mdc-form-field {
      label {
        font-size: 14px;
      }
    }
  }

  textarea.mat-mdc-input-element {
    resize: vertical;
    min-height: 80px;
  }
}

/* Responsive Design */
@media screen and (min-width: 992px) {
  .permissions-grid {
    grid-template-columns: repeat(2, 1fr) !important;

    .permissions-category:last-child {
      grid-column: span 2;
    }
  }
}

@media screen and (max-width: 1200px) {
  .driver-form-container {
    max-width: 100%;
  }
}

@media screen and (max-width: 992px) {
  .form-grid,
  .permissions-grid .permission-group {
    grid-template-columns: 1fr;
  }

  .full-width {
    grid-column: 1 !important;
  }

  .admin-badge {
    position: static !important;
    display: inline-block;
    margin-left: 8px;
  }
}

@media screen and (max-width: 768px) {
  :host {
    margin-left: 60px; /* Collapsed sidebar width */
    padding-top: 80px; /* Reduced topbar padding for smaller screens */
    padding: 16px;
  }

  .header-wrapper {
    flex-direction: column;
    align-items: flex-start;
    gap: 16px;

    .header-actions {
      width: 100%;
      justify-content: flex-end;
    }
  }

  .form-section {
    padding: 16px !important;
  }

  .tab-content {
    padding: 0 16px 16px;
  }
}

@media screen and (max-width: 576px) {
  :host {
    padding: 8px;
    padding-top: 72px; /* Further reduced for mobile */
  }

  .header-wrapper,
  .form-content,
  .form-actions {
    padding: 16px;
  }

  .header-wrapper {
    .header-title {
      flex-direction: column;
      align-items: flex-start;
      gap: 8px;
    }
  }

  .header-actions,
  .form-actions {
    flex-direction: column;
    width: 100%;

    button {
      width: 100%;
    }
  }

  :host ::ng-deep {
    .mat-mdc-tab-labels {
      flex-direction: column;
    }

    .mat-mdc-tab-body-content {
      padding: 0;
    }
  }
}

/* Print Styles */
@media print {
  :host {
    padding: 0;
    background: white;
    margin-left: 0; /* No sidebar in print */
    padding-top: 0; /* No topbar in print */
  }

  .form-card {
    box-shadow: none !important;
    border: 1px solid #ddd;
  }

  .header-actions,
  .form-actions {
    display: none !important;
  }

  :host ::ng-deep {
    .mat-mdc-tab-header {
      display: none !important;
    }

    .mat-mdc-tab-body-content {
      padding: 0 !important;
    }
  }
}


--- ./src/app/pages/drivers/driver-create/driver-create.component.html ---
<!-- driver-create.component.html -->
<div class="driver-form-container">
  <!-- Loading Overlay -->
  <div class="loading-overlay" *ngIf="isLoading">
    <mat-spinner diameter="40"></mat-spinner>
    <span>{{ isEditMode ? 'Loading driver data...' : 'Preparing form...' }}</span>
  </div>

  <mat-card class="form-card">
    <!-- Header -->
    <div class="header-wrapper">
      <div class="header-title">
        <button mat-icon-button (click)="cancel()" class="back-button">
          <mat-icon>arrow_back</mat-icon>
        </button>
        <div>
          <h1>{{ isEditMode ? 'Edit Driver' : 'Create New Driver' }}</h1>
          <p class="subtitle">
            {{ isEditMode ? 'Update driver information' : 'Add a new driver to the system' }}
          </p>
        </div>
      </div>
      <div class="header-actions">
        <button mat-stroked-button (click)="cancel()">
          <mat-icon>close</mat-icon>
          Cancel
        </button>
        <button mat-flat-button color="primary" (click)="onSubmit()" [disabled]="driverForm.invalid || isSubmitting">
          <mat-icon>save</mat-icon>
          {{ isSubmitting ? 'Saving...' : isEditMode ? 'Update' : 'Create' }}
        </button>
      </div>
    </div>

    <!-- Form Content -->
    <div class="form-content">
      <form [formGroup]="driverForm">
        <!-- Form Tabs -->
        <mat-tab-group animationDuration="0ms" backgroundColor="primary">
          <!-- Basic Information Tab -->
          <mat-tab label="Basic Information">
            <div class="tab-content">
              <section class="form-section">
                <div class="section-title">
                  <mat-icon>person</mat-icon>
                  <h2>Personal Details</h2>
                </div>

                <div class="form-grid">
                  <mat-form-field appearance="outline">
                    <mat-label>First Name</mat-label>
                    <input matInput formControlName="firstName" placeholder="Enter first name" required />
                    <mat-error *ngIf="driverForm.get('firstName')?.hasError('required')"> First name is required </mat-error>
                  </mat-form-field>

                  <mat-form-field appearance="outline">
                    <mat-label>Last Name</mat-label>
                    <input matInput formControlName="lastName" placeholder="Enter last name" required />
                    <mat-error *ngIf="driverForm.get('lastName')?.hasError('required')"> Last name is required </mat-error>
                  </mat-form-field>

                  <mat-form-field appearance="outline">
                    <mat-label>Email</mat-label>
                    <input matInput formControlName="email" placeholder="Enter email address" required type="email" />
                    <mat-icon matSuffix>email</mat-icon>
                    <mat-error *ngIf="driverForm.get('email')?.hasError('required')"> Email is required </mat-error>
                    <mat-error *ngIf="driverForm.get('email')?.hasError('email')"> Please enter a valid email address </mat-error>
                  </mat-form-field>

                  <mat-form-field appearance="outline">
                    <mat-label>Phone Number</mat-label>
                    <input matInput formControlName="phoneNumber" placeholder="Enter phone number" />
                    <mat-icon matSuffix>phone</mat-icon>
                    <mat-error *ngIf="driverForm.get('phoneNumber')?.hasError('pattern')"> Please enter a valid phone number </mat-error>
                  </mat-form-field>

                  <mat-form-field appearance="outline">
                    <mat-label>Company</mat-label>
                    <input matInput formControlName="company" placeholder="Enter company name (optional)" />
                    <mat-icon matSuffix>business</mat-icon>
                  </mat-form-field>

                  <mat-form-field appearance="outline">
                    <mat-label>Type</mat-label>
                    <mat-select formControlName="type">
                      <mat-option value="employee">Employee</mat-option>
                      <mat-option value="customer">Customer</mat-option>
                      <mat-option value="supplier">Supplier</mat-option>
                      <mat-option value="partner">Partner</mat-option>
                    </mat-select>
                  </mat-form-field>

                  <mat-form-field appearance="outline">
                    <mat-label>Role</mat-label>
                    <mat-select formControlName="role" required (selectionChange)="onRoleChange($event)">
                      <mat-option *ngFor="let role of availableRoles" [value]="role">
                        {{ role }}
                      </mat-option>
                    </mat-select>
                    <mat-error *ngIf="driverForm.get('role')?.hasError('required')"> Role is required </mat-error>
                    <mat-hint>Role will automatically set appropriate permissions</mat-hint>
                  </mat-form-field>

                  <mat-form-field appearance="outline">
                    <mat-label>Status</mat-label>
                    <mat-select formControlName="status" required>
                      <mat-option value="active">Active</mat-option>
                      <mat-option value="inactive">Inactive</mat-option>
                      <mat-option value="pending">Pending</mat-option>
                    </mat-select>
                    <mat-error *ngIf="driverForm.get('status')?.hasError('required')"> Status is required </mat-error>
                  </mat-form-field>
                </div>
              </section>

              <section class="form-section">
                <div class="section-title">
                  <mat-icon>badge</mat-icon>
                  <h2>Driver Details</h2>
                </div>
                <div class="form-grid">
                  <mat-form-field appearance="outline">
                    <mat-label>License Number</mat-label>
                    <input matInput formControlName="licenseNumber" placeholder="Enter license number" />
                  </mat-form-field>

                  <mat-form-field appearance="outline">
                    <mat-label>License Expiry</mat-label>
                    <input matInput [matDatepicker]="licenseDatepicker" formControlName="licenseExpiry" placeholder="Choose date" />
                    <mat-datepicker-toggle matIconSuffix [for]="licenseDatepicker"></mat-datepicker-toggle>
                    <mat-datepicker #licenseDatepicker></mat-datepicker>
                  </mat-form-field>

                  <mat-form-field appearance="outline">
                    <mat-label>Vehicle Type</mat-label>
                    <input matInput formControlName="vehicleType" placeholder="Enter vehicle type" />
                  </mat-form-field>

                  <mat-form-field appearance="outline">
                    <mat-label>Area Coverage</mat-label>
                    <input matInput formControlName="areaCoverage" placeholder="Enter area coverage" />
                  </mat-form-field>

                  <mat-form-field appearance="outline">
                    <mat-label>Availability</mat-label>
                    <mat-select formControlName="availability">
                      <mat-option value="Full-time">Full-time</mat-option>
                      <mat-option value="Part-time">Part-time</mat-option>
                      <mat-option value="Weekends Only">Weekends Only</mat-option>
                      <mat-option value="On Call">On Call</mat-option>
                    </mat-select>
                  </mat-form-field>
                </div>
              </section>

              <!-- Account Setup Information (only for new driver) -->
              <section class="form-section" *ngIf="!isEditMode">
                <div class="section-title">
                  <mat-icon>key</mat-icon>
                  <h2>Account Setup</h2>
                </div>
                <p class="form-hint">Set the initial password for this driver. They will be prompted to change it on first login.</p>

                <div class="form-grid">
                  <mat-form-field appearance="outline">
                    <mat-label>Password</mat-label>
                    <input matInput formControlName="password" [type]="hidePassword ? 'password' : 'text'" required />
                    <button mat-icon-button matSuffix (click)="hidePassword = !hidePassword" type="button">
                      <mat-icon>{{ hidePassword ? 'visibility_off' : 'visibility' }}</mat-icon>
                    </button>
                    <mat-error *ngIf="driverForm.get('password')?.hasError('required')"> Password is required </mat-error>
                    <mat-error *ngIf="driverForm.get('password')?.hasError('minlength')"> Password must be at least 8 characters </mat-error>
                  </mat-form-field>

                  <mat-form-field appearance="outline">
                    <mat-label>Confirm Password</mat-label>
                    <input matInput formControlName="confirmPassword" [type]="hidePassword ? 'password' : 'text'" required />
                    <mat-error *ngIf="driverForm.get('confirmPassword')?.hasError('required')"> Please confirm password </mat-error>
                    <mat-error *ngIf="driverForm.get('confirmPassword')?.hasError('passwordMismatch')"> Passwords do not match </mat-error>
                  </mat-form-field>

                  <div class="send-credentials-option">
                    <mat-checkbox formControlName="sendCredentials" color="primary"> Send login credentials to driver's email </mat-checkbox>
                    <span class="helper-text">An email will be sent with login instructions</span>
                  </div>
                </div>
              </section>

              <section class="form-section">
                <div class="section-title">
                  <mat-icon>notes</mat-icon>
                  <h2>Additional Notes</h2>
                </div>
                <div class="form-grid">
                  <mat-form-field appearance="outline" class="full-width">
                    <mat-label>Notes</mat-label>
                    <textarea matInput formControlName="notes" rows="4" placeholder="Enter any additional notes about this driver"></textarea>
                  </mat-form-field>
                </div>
              </section>
            </div>
          </mat-tab>

          <!-- Permissions Tab -->
          <mat-tab label="Permissions">
            <div class="tab-content">
              <section class="form-section permissions-section">
                <div class="section-title">
                  <mat-icon>security</mat-icon>
                  <h2>Permissions & Access</h2>
                </div>

                <!-- Admin notice -->
                <div class="admin-notice" *ngIf="!isCurrentUserAdmin">
                  <mat-icon>info</mat-icon>
                  <p>
                    Permissions are automatically set based on the selected role. Only administrators can modify individual permissions.
                    <span *ngIf="driverForm.get('role')?.value === 'Admin'" class="warning-text">
                      Note: You cannot create or edit Admin users. Contact an administrator for help.
                    </span>
                  </p>
                </div>

                <!-- Admin permissions editor notice -->
                <div class="admin-notice admin-editor-notice" *ngIf="isCurrentUserAdmin">
                  <mat-icon>admin_panel_settings</mat-icon>
                  <p>As an administrator, you can override the default permissions for this role by checking or unchecking boxes below.</p>
                </div>

                <div formGroupName="permissions" class="permissions-grid">
                  <!-- General Permissions -->
                  <div class="permissions-category">
                    <h3>General Permissions</h3>
                    <div class="permission-group">
                      <mat-checkbox formControlName="isAdmin" color="primary" [class.admin-only]="true">
                        Administrator
                        <span class="admin-badge" *ngIf="!isCurrentUserAdmin">Admin Only</span>
                      </mat-checkbox>
                      <mat-checkbox formControlName="canManageUsers" color="primary"> Manage Users </mat-checkbox>
                      <mat-checkbox formControlName="canViewSystemSettings" color="primary"> View System Settings </mat-checkbox>
                      <mat-checkbox formControlName="canManageCompanies" color="primary"> Manage Companies </mat-checkbox>
                    </div>
                  </div>

                  <!-- Job Management -->
                  <div class="permissions-category">
                    <h3>Job Management</h3>
                    <div class="permission-group">
                      <mat-checkbox formControlName="canViewAllJobs" color="primary"> View All Jobs </mat-checkbox>
                      <mat-checkbox formControlName="canViewAssignedJobs" color="primary"> View Assigned Jobs </mat-checkbox>
                      <mat-checkbox formControlName="canCreateJobs" color="primary"> Create Jobs </mat-checkbox>
                      <mat-checkbox formControlName="canEditJobs" color="primary"> Edit Jobs </mat-checkbox>
                      <mat-checkbox formControlName="canAllocateJobs" color="primary"> Allocate Jobs </mat-checkbox>
                      <mat-checkbox formControlName="canViewUnallocated" color="primary"> View Unallocated Jobs </mat-checkbox>
                    </div>
                  </div>

                  <!-- Financial Permissions -->
                  <div class="permissions-category">
                    <h3>Financial Permissions</h3>
                    <div class="permission-group">
                      <mat-checkbox formControlName="canCreateExpenses" color="primary"> Create Expenses </mat-checkbox>
                      <mat-checkbox formControlName="canApproveExpenses" color="primary"> Approve Expenses </mat-checkbox>
                      <mat-checkbox formControlName="canViewReports" color="primary"> View Reports </mat-checkbox>
                    </div>
                  </div>
                </div>

                <!-- Role permissions summary -->
                <div class="role-permissions-summary">
                  <p>
                    <strong>{{ driverForm.get('role')?.value }}</strong
                    >:
                    <span *ngIf="driverForm.get('role')?.value === 'Admin'"> Has full access to all system features and settings. </span>
                    <span *ngIf="driverForm.get('role')?.value === 'Driver'"> Can view and manage assigned jobs and submit expenses. </span>
                    <span *ngIf="driverForm.get('role')?.value === 'Contractor'"> Has limited access to view only assigned jobs and submit expenses. </span>
                    <span *ngIf="driverForm.get('role')?.value === 'System User'"> Can access most features except system administration. </span>
                  </p>
                </div>
              </section>
            </div>
          </mat-tab>
        </mat-tab-group>
      </form>
    </div>

    <!-- Form Actions -->
    <div class="form-actions">
      <button mat-stroked-button (click)="cancel()">Cancel</button>
      <button mat-flat-button color="primary" (click)="onSubmit()" [disabled]="driverForm.invalid || isSubmitting">
        {{ isSubmitting ? 'Saving...' : isEditMode ? 'Update Driver' : 'Create Driver' }}
      </button>
    </div>
  </mat-card>
</div>


--- ./src/app/pages/drivers/driver-create/driver-create.component.ts ---
import { Component, OnInit, OnDestroy } from '@angular/core';
import { FormBuilder, FormGroup, Validators, AbstractControl, ValidationErrors } from '@angular/forms';
import { ActivatedRoute, Router } from '@angular/router';
import { MatSnackBar } from '@angular/material/snack-bar';
import { Subscription } from 'rxjs';
import { finalize } from 'rxjs/operators';

import { AuthService } from '../../../services/auth.service';
import { DriverService } from '../../../services/driver.service';
import { NotificationService } from '../../../services/notification.service';
import { UserProfile, UserRole, ROLE_PERMISSION_PRESETS } from '../../../interfaces/user-profile.interface';

@Component({
  selector: 'app-driver-create',
  templateUrl: './driver-create.component.html',
  styleUrls: ['./driver-create.component.scss'],
  standalone: false,
})
export class DriverCreateComponent implements OnInit, OnDestroy {
  driverForm!: FormGroup;
  isLoading = false;
  isSubmitting = false;
  isEditMode = false;
  driverId: string = '';
  hidePassword = true;

  // Current user permissions
  isCurrentUserAdmin = false;

  // Available options for dropdowns
  availableRoles = Object.values(UserRole);

  private subscriptions: Subscription[] = [];

  constructor(
    private fb: FormBuilder,
    private authService: AuthService,
    private driverService: DriverService,
    private router: Router,
    private route: ActivatedRoute,
    private snackBar: MatSnackBar,
    private notificationService: NotificationService
  ) {
    this.createForm();
  }

  ngOnInit(): void {
    // Check if the current user is an admin
    const adminSub = this.authService.getUserProfile().subscribe((userProfile) => {
      this.isCurrentUserAdmin = !!userProfile?.permissions?.isAdmin;

      // Make permissions form controls readonly if not admin
      this.setPermissionsReadonly(!this.isCurrentUserAdmin);

      // If not admin, remove Admin from available roles
      if (!this.isCurrentUserAdmin) {
        this.availableRoles = this.availableRoles.filter((role) => role !== UserRole.ADMIN);
      }
    });

    this.subscriptions.push(adminSub);

    // Check if we're in edit mode by looking for an ID in the route
    const routeSub = this.route.paramMap.subscribe((params) => {
      const id = params.get('id');
      if (id) {
        this.isEditMode = true;
        this.driverId = id;
        this.loadDriverData();
      }
    });
    this.subscriptions.push(routeSub);
  }

  ngOnDestroy(): void {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }

  /**
   * Create the driver form with validation
   */
  private createForm(): void {
    this.driverForm = this.fb.group(
      {
        firstName: ['', Validators.required],
        lastName: ['', Validators.required],
        email: ['', [Validators.required, Validators.email]],
        phoneNumber: ['', Validators.pattern(/^[+]?[(]?[0-9]{3}[)]?[-\s.]?[0-9]{3}[-\s.]?[0-9]{4,6}$/)],
        role: [UserRole.DRIVER, Validators.required],
        status: ['active', Validators.required],
        company: [''],
        type: ['customer'],
        licenseNumber: [''],
        licenseExpiry: [null],
        vehicleType: [''],
        areaCoverage: [''],
        availability: ['Full-time'],

        // Permissions
        permissions: this.fb.group({
          canAllocateJobs: [{ value: false, disabled: true }],
          canApproveExpenses: [{ value: false, disabled: true }],
          canCreateJobs: [{ value: false, disabled: true }],
          canEditJobs: [{ value: false, disabled: true }],
          canManageUsers: [{ value: false, disabled: true }],
          canViewReports: [{ value: false, disabled: true }],
          canViewUnallocated: [{ value: false, disabled: true }],
          isAdmin: [{ value: false, disabled: true }],
          canViewSystemSettings: [{ value: false, disabled: true }],
          canManageCompanies: [{ value: false, disabled: true }],
          canViewAllJobs: [{ value: false, disabled: true }],
          canViewAssignedJobs: [{ value: true, disabled: true }],
          canCreateExpenses: [{ value: false, disabled: true }],
        }),

        // Account setup (only for new drivers)
        password: ['', [Validators.required, Validators.minLength(8)]],
        confirmPassword: ['', Validators.required],
        sendCredentials: [true],
        notes: [''],
      },
      {
        validators: this.passwordMatchValidator,
      }
    );

    // Apply initial role permissions
    this.applyRolePermissions(UserRole.DRIVER);
  }

  /**
   * Set permissions form controls to readonly or editable
   */
  private setPermissionsReadonly(readonly: boolean): void {
    const permissionsGroup = this.driverForm.get('permissions') as FormGroup;
    if (!permissionsGroup) return;

    Object.keys(permissionsGroup.controls).forEach((controlName) => {
      const control = permissionsGroup.get(controlName);
      if (control) {
        if (readonly) {
          control.disable();
        } else {
          // Only enable non-admin controls or if the current user is admin
          if (controlName !== 'isAdmin' || this.isCurrentUserAdmin) {
            control.enable();
          }
        }
      }
    });
  }

  /**
   * Custom validator to check if passwords match
   */
  private passwordMatchValidator(control: AbstractControl): ValidationErrors | null {
    const password = control.get('password');
    const confirmPassword = control.get('confirmPassword');

    if (!password || !confirmPassword) {
      return null;
    }

    if (password.value !== confirmPassword.value) {
      confirmPassword.setErrors({ passwordMismatch: true });
      return { passwordMismatch: true };
    }

    return null;
  }

  /**
   * Load driver data when in edit mode
   */
  private loadDriverData(): void {
    this.isLoading = true;

    const userSub = this.driverService
      .getDriverById(this.driverId)
      .pipe(finalize(() => (this.isLoading = false)))
      .subscribe({
        next: (driver) => {
          if (driver) {
            this.updateFormWithDriverData(driver);
          } else {
            this.notificationService.addNotification({
              type: 'error',
              title: 'Error',
              message: 'Driver not found',
            });
            this.router.navigate(['/drivers']);
          }
        },
        error: (error) => {
          console.error('Error loading driver:', error);
          this.notificationService.addNotification({
            type: 'error',
            title: 'Error',
            message: 'Failed to load driver data',
          });
          this.router.navigate(['/drivers']);
        },
      });

    this.subscriptions.push(userSub);
  }

  /**
   * Update form with driver data in edit mode
   */
  private updateFormWithDriverData(driver: UserProfile): void {
    // Remove password fields validation in edit mode
    this.driverForm.get('password')?.clearValidators();
    this.driverForm.get('confirmPassword')?.clearValidators();
    this.driverForm.get('password')?.updateValueAndValidity();
    this.driverForm.get('confirmPassword')?.updateValueAndValidity();

    // Check if editing an admin and current user is not admin
    const driverRole = driver.role || '';
    if (driverRole === UserRole.ADMIN && !this.isCurrentUserAdmin) {
      this.notificationService.addNotification({
        type: 'warning',
        title: 'Permission Restricted',
        message: 'You do not have permission to edit admin accounts. Contact an administrator for help.',
      });
      this.router.navigate(['/drivers']);
      return;
    }

    // Update form with driver data
    this.driverForm.patchValue({
      firstName: driver.firstName || '',
      lastName: driver.lastName || '',
      email: driver.email || '',
      phoneNumber: driver.phoneNumber || driver.phone || '',
      role: driver.role || UserRole.DRIVER,
      status: driver.isActive ? 'active' : 'inactive',
      company: driver.company || '',
      type: driver.type || 'customer',
      licenseNumber: driver.licenseNumber || '',
      licenseExpiry: driver.licenseExpiry || null,
      vehicleType: driver.vehicleType || '',
      areaCoverage: driver.areaCoverage || '',
      availability: driver.availability || 'Full-time',
      notes: driver.notes || '',
    });

    // Update permissions values with null safety checks
    const permissionsGroup = this.driverForm.get('permissions') as FormGroup;
    if (permissionsGroup && driver.permissions) {
      Object.keys(driver.permissions).forEach((key) => {
        const control = permissionsGroup.get(key);
        if (control) {
          control.setValue(!!driver.permissions?.[key]);
        }
      });
    }
  }

  /**
   * Handle role change - set default permissions based on role
   */
  onRoleChange(event: any): void {
    const selectedRole = event.value as UserRole;
    this.applyRolePermissions(selectedRole);
  }

  /**
   * Apply preset permissions based on selected role
   */
  private applyRolePermissions(role: UserRole): void {
    const permissionsGroup = this.driverForm.get('permissions') as FormGroup;
    if (!permissionsGroup) return;

    // Get the preset permissions for the selected role
    const presetPermissions = ROLE_PERMISSION_PRESETS[role];
    if (!presetPermissions) return;

    // Apply each permission to the form
    Object.entries(presetPermissions).forEach(([key, value]) => {
      const control = permissionsGroup.get(key);
      if (control) {
        // Check if setting admin status and current user is not admin
        if (key === 'isAdmin' && value === true && !this.isCurrentUserAdmin) {
          // Skip setting admin status
          return;
        }

        control.setValue(value);
      }
    });
  }

  /**
   * Submit the form to create or update a driver
   */
  onSubmit(): void {
    if (this.driverForm.invalid) {
      this.markFormGroupTouched(this.driverForm);
      return;
    }

    this.isSubmitting = true;

    const formValues = this.driverForm.value;
    const permissionsGroup = this.driverForm.get('permissions') as FormGroup;

    // Set permissions from the role if controls are disabled (non-admin user)
    if (permissionsGroup && permissionsGroup.disabled) {
      const role = (formValues.role as UserRole) || UserRole.DRIVER;
      formValues.permissions = ROLE_PERMISSION_PRESETS[role];

      // Ensure non-admins can't set admin status
      if (!this.isCurrentUserAdmin && formValues.permissions) {
        formValues.permissions.isAdmin = false;
      }
    }

    if (this.isEditMode) {
      // Update existing driver
      this.updateDriver(formValues);
    } else {
      // Create new driver
      this.createDriver(formValues);
    }
  }

  /**
   * Create a new driver
   */
  private createDriver(formValues: any): void {
    const { password, confirmPassword, sendCredentials, ...userData } = formValues;

    const createSub = this.driverService.createDriver(userData.email, password, userData, sendCredentials).subscribe({
      next: (driverId) => {
        this.isSubmitting = false;

        this.notificationService.addNotification({
          type: 'success',
          title: 'Driver Created',
          message: `${userData.firstName} ${userData.lastName} has been created successfully`,
        });

        this.router.navigate(['/drivers']);
      },
      error: (error) => {
        this.handleError(error, 'creating driver');
      },
    });

    this.subscriptions.push(createSub);
  }

  /**
   * Update an existing driver
   */
  private updateDriver(formValues: any): void {
    const { password, confirmPassword, sendCredentials, ...userData } = formValues;

    const updateSub = this.driverService.updateDriver(this.driverId, userData).subscribe({
      next: () => {
        this.isSubmitting = false;

        this.notificationService.addNotification({
          type: 'success',
          title: 'Driver Updated',
          message: `${userData.firstName} ${userData.lastName} has been updated successfully`,
        });

        this.router.navigate(['/drivers', this.driverId]);
      },
      error: (error) => {
        this.handleError(error, 'updating driver');
      },
    });

    this.subscriptions.push(updateSub);
  }

  /**
   * Handle form submission errors
   */
  private handleError(error: any, context: string): void {
    console.error(`Error ${context}:`, error);

    this.isSubmitting = false;

    this.notificationService.addNotification({
      type: 'error',
      title: 'Error',
      message: `Failed to ${this.isEditMode ? 'update' : 'create'} driver. ${error.message || ''}`,
    });
  }

  /**
   * Mark all form controls as touched to show validation errors
   */
  private markFormGroupTouched(formGroup: FormGroup): void {
    Object.values(formGroup.controls).forEach((control) => {
      control.markAsTouched();

      if (control instanceof FormGroup) {
        this.markFormGroupTouched(control);
      }
    });
  }

  /**
   * Cancel form and return to drivers list
   */
  cancel(): void {
    if (this.isEditMode) {
      this.router.navigate(['/drivers', this.driverId]);
    } else {
      this.router.navigate(['/drivers']);
    }
  }

  /**
   * Check if current user can edit admin permissions
   */
  canManageAdminPermissions(): boolean {
    return this.isCurrentUserAdmin;
  }
}


--- ./src/app/pages/drivers/driver-details/driver-details.component.html ---
<!-- driver-details.component.html -->
<mat-card class="mat-elevation-z3">
  <!-- Loading Spinner -->
  <div class="loading-overlay" *ngIf="isLoading">
    <mat-spinner diameter="40"></mat-spinner>
    <span>Loading driver details...</span>
  </div>

  <!-- Header -->
  <div class="header-wrapper">
    <div class="header-title">
      <button mat-icon-button (click)="goBack()">
        <mat-icon>arrow_back</mat-icon>
      </button>
      <div class="title-content" *ngIf="driver">
        <h1>{{ driver.firstName }} {{ driver.lastName }}</h1>
        <div class="driver-status">
          <span class="status-chip" [ngClass]="getStatusClass(driver.status)">
            {{ driver.status || (driver.isActive ? 'Active' : 'Inactive') }}
          </span>
          <span class="role-chip" [ngClass]="getRoleClass(driver.role)">
            {{ driver.role }}
          </span>
        </div>
      </div>
    </div>
    <div class="header-actions">
      <button mat-stroked-button color="warn" (click)="deleteDriver()" *ngIf="hasEditPermission">
        <mat-icon>delete</mat-icon>
        Delete Driver
      </button>
      <button mat-flat-button color="primary" (click)="editDriver()" *ngIf="hasEditPermission">
        <mat-icon>edit</mat-icon>
        Edit Driver
      </button>
    </div>
  </div>

  <!-- Tab Navigation -->
  <div class="tab-navigation">
    <button [class.active]="activeTab === 'details'" (click)="setActiveTab('details')">Details</button>
    <button [class.active]="activeTab === 'jobs'" (click)="setActiveTab('jobs')">Jobs</button>
    <button [class.active]="activeTab === 'permissions'" (click)="setActiveTab('permissions')">Permissions</button>
    <button [class.active]="activeTab === 'notes'" (click)="setActiveTab('notes')">Notes</button>
  </div>

  <!-- Driver Details -->
  <mat-card-content class="content-wrapper" *ngIf="driver">
    <div [ngSwitch]="activeTab">
      <!-- Details Tab -->
      <div *ngSwitchCase="'details'" class="details-tab">
        <div class="details-grid">
          <!-- Driver Information -->
          <mat-card class="details-section">
            <h2>Driver Information</h2>
            <div class="info-grid">
              <div class="info-item">
                <label>Driver ID</label>
                <span>{{ driver.id }}</span>
              </div>
              <div class="info-item">
                <label>Email</label>
                <a [href]="'mailto:' + driver.email">{{ driver.email }}</a>
              </div>
              <div class="info-item">
                <label>Phone</label>
                <a [href]="'tel:' + (driver.phone || driver.phoneNumber)">{{ driver.phone || driver.phoneNumber }}</a>
              </div>
              <div class="info-item">
                <label>Company</label>
                <span>{{ driver.company || 'Not assigned' }}</span>
              </div>
              <div class="info-item">
                <label>Type</label>
                <span class="status-chip small" [ngClass]="getTypeClass(driver.type)">
                  {{ driver.type || 'Customer' }}
                </span>
              </div>
              <div class="info-item">
                <label>Role</label>
                <span class="role-chip small" [ngClass]="getRoleClass(driver.role)">
                  {{ driver.role }}
                </span>
              </div>
              <div class="info-item">
                <label>Status</label>
                <span class="status-chip small" [ngClass]="getStatusClass(driver.status)">
                  {{ driver.status || (driver.isActive ? 'Active' : 'Inactive') }}
                </span>
              </div>
              <div class="info-item">
                <label>Last Activity</label>
                <span>{{ driver.lastActivity | date }}</span>
              </div>
            </div>
          </mat-card>

          <!-- Statistics Card -->
          <mat-card class="details-section stats-section">
            <h2>Activity Overview</h2>
            <div class="stats-grid">
              <div class="stat-item">
                <div class="stat-icon">
                  <mat-icon>directions_car</mat-icon>
                </div>
                <div class="stat-content">
                  <span class="stat-value">{{ driverStats.totalJobs }}</span>
                  <span class="stat-label">Total Jobs</span>
                </div>
              </div>
              <div class="stat-item">
                <div class="stat-icon">
                  <mat-icon>pending_actions</mat-icon>
                </div>
                <div class="stat-content">
                  <span class="stat-value">{{ driverStats.pendingJobs }}</span>
                  <span class="stat-label">Pending Jobs</span>
                </div>
              </div>
              <div class="stat-item">
                <div class="stat-icon">
                  <mat-icon>check_circle</mat-icon>
                </div>
                <div class="stat-content">
                  <span class="stat-value">{{ driverStats.completedJobs }}</span>
                  <span class="stat-label">Completed Jobs</span>
                </div>
              </div>
              <div class="stat-item">
                <div class="stat-icon">
                  <mat-icon>payments</mat-icon>
                </div>
                <div class="stat-content">
                  <span class="stat-value">{{ driverStats.pendingExpenses }}</span>
                  <span class="stat-label">Pending Expenses</span>
                </div>
              </div>
            </div>
          </mat-card>
        </div>

        <!-- Additional Information -->
        <mat-card class="profile-section">
          <h2>Driver Profile</h2>
          <div class="profile-content">
            <div class="profile-header">
              <div class="profile-avatar">
                {{ getDriverInitials(driver) }}
              </div>
              <div class="profile-details">
                <h3>{{ driver.firstName }} {{ driver.lastName }}</h3>
                <p class="profile-company">{{ driver.company || 'Independent Driver' }}</p>
                <div class="contact-buttons">
                  <a mat-stroked-button [href]="'mailto:' + driver.email" class="contact-button">
                    <mat-icon>email</mat-icon>
                    Email
                  </a>
                  <a mat-stroked-button [href]="'tel:' + (driver.phone || driver.phoneNumber)" class="contact-button">
                    <mat-icon>phone</mat-icon>
                    Call
                  </a>
                  <button mat-stroked-button class="contact-button" (click)="sendMessage()">
                    <mat-icon>message</mat-icon>
                    Message
                  </button>
                </div>
              </div>
            </div>
            <div class="profile-section-divider"></div>
            <div class="profile-info">
              <div class="info-row">
                <span class="info-label">License Number</span>
                <span class="info-value">{{ driver.licenseNumber || 'Not provided' }}</span>
              </div>
              <div class="info-row">
                <span class="info-label">License Expiry</span>
                <span class="info-value">{{ driver.licenseExpiry | date }}</span>
              </div>
              <div class="info-row">
                <span class="info-label">Vehicle Type</span>
                <span class="info-value">{{ driver.vehicleType || 'Not specified' }}</span>
              </div>
              <div class="info-row">
                <span class="info-label">Area Coverage</span>
                <span class="info-value">{{ driver.areaCoverage || 'No restrictions' }}</span>
              </div>
              <div class="info-row">
                <span class="info-label">Availability</span>
                <span class="info-value">{{ driver.availability || 'Full-time' }}</span>
              </div>
            </div>
          </div>
        </mat-card>
      </div>

      <!-- Jobs Tab -->
      <div *ngSwitchCase="'jobs'" class="jobs-tab">
        <mat-card class="jobs-section">
          <div class="section-header">
            <h2>Job History</h2>
            <button mat-stroked-button color="primary" [routerLink]="['/jobs/new']" [queryParams]="{ driverId: driver.id }">
              <mat-icon>add</mat-icon>
              Assign New Job
            </button>
          </div>

          <!-- Loading Jobs Spinner -->
          <div class="loading-overlay" *ngIf="isJobsLoading">
            <mat-spinner diameter="30"></mat-spinner>
            <span>Loading jobs...</span>
          </div>

          <div class="table-container">
            <table mat-table [dataSource]="jobsDataSource" class="jobs-table" matSort>
              <!-- Job ID Column -->
              <ng-container matColumnDef="id">
                <th mat-header-cell *matHeaderCellDef mat-sort-header>Job ID</th>
                <td mat-cell *matCellDef="let job">{{ job.id }}</td>
              </ng-container>

              <!-- Status Column -->
              <ng-container matColumnDef="status">
                <th mat-header-cell *matHeaderCellDef mat-sort-header>Status</th>
                <td mat-cell *matCellDef="let job">
                  <span class="status-chip small" [ngClass]="getJobStatusClass(job.status)">
                    {{ job.status }}
                  </span>
                </td>
              </ng-container>

              <!-- Vehicle Column -->
              <ng-container matColumnDef="vehicle">
                <th mat-header-cell *matHeaderCellDef mat-sort-header>Vehicle</th>
                <td mat-cell *matCellDef="let job">
                  {{ job.registration || 'N/A' }}
                </td>
              </ng-container>

              <!-- Collection Column -->
              <ng-container matColumnDef="collection">
                <th mat-header-cell *matHeaderCellDef>Collection</th>
                <td mat-cell *matCellDef="let job">
                  {{ job.collectionAddress ? (job.collectionAddress | slice : 0 : 30) + (job.collectionAddress.length > 30 ? '...' : '') : 'N/A' }}
                </td>
              </ng-container>

              <!-- Delivery Column -->
              <ng-container matColumnDef="delivery">
                <th mat-header-cell *matHeaderCellDef>Delivery</th>
                <td mat-cell *matCellDef="let job">
                  {{ job.deliveryAddress ? (job.deliveryAddress | slice : 0 : 30) + (job.deliveryAddress.length > 30 ? '...' : '') : 'N/A' }}
                </td>
              </ng-container>

              <!-- Date Column -->
              <ng-container matColumnDef="date">
                <th mat-header-cell *matHeaderCellDef mat-sort-header>Date</th>
                <td mat-cell *matCellDef="let job">{{ job.createdAt | date }}</td>
              </ng-container>

              <!-- Actions Column -->
              <ng-container matColumnDef="actions">
                <th mat-header-cell *matHeaderCellDef></th>
                <td mat-cell *matCellDef="let job">
                  <button mat-icon-button [matMenuTriggerFor]="menu">
                    <mat-icon>more_vert</mat-icon>
                  </button>
                  <mat-menu #menu="matMenu">
                    <button mat-menu-item (click)="viewJobDetails(job.id)">
                      <mat-icon>visibility</mat-icon>
                      <span>View Details</span>
                    </button>
                    <button mat-menu-item (click)="editJob(job.id)" *ngIf="hasEditPermission">
                      <mat-icon>edit</mat-icon>
                      <span>Edit Job</span>
                    </button>
                    <button mat-menu-item (click)="unassignJob(job)" *ngIf="hasEditPermission && canUnassignJob(job)">
                      <mat-icon>person_remove</mat-icon>
                      <span>Unassign Job</span>
                    </button>
                  </mat-menu>
                </td>
              </ng-container>

              <tr mat-header-row *matHeaderRowDef="jobColumns"></tr>
              <tr mat-row *matRowDef="let row; columns: jobColumns" (click)="viewJobDetails(row.id)" class="job-row"></tr>
            </table>

            <!-- Empty state for jobs -->
            <div class="empty-state" *ngIf="!isJobsLoading && jobsDataSource.data.length === 0">
              <mat-icon>work_off</mat-icon>
              <h3>No Jobs Found</h3>
              <p>This driver doesn't have any jobs yet.</p>
              <button mat-flat-button color="primary" [routerLink]="['/jobs/new']" [queryParams]="{ driverId: driver.id }">
                <mat-icon>add</mat-icon>
                Assign First Job
              </button>
            </div>
          </div>

          <!-- Jobs Paginator -->
          <mat-paginator [pageSizeOptions]="[5, 10, 25]" [length]="jobsDataSource.data.length" showFirstLastButtons> </mat-paginator>
        </mat-card>
      </div>

      <!-- Permissions Tab -->
      <div *ngSwitchCase="'permissions'" class="permissions-tab">
        <mat-card class="permissions-section">
          <div class="section-header">
            <h2>Permissions & Access</h2>
            <button mat-flat-button color="primary" (click)="editPermissions()" *ngIf="hasEditPermission">
              <mat-icon>edit</mat-icon>
              Edit Permissions
            </button>
          </div>

          <div class="permissions-content">
            <div class="role-summary">
              <h3>Role: {{ driver.role }}</h3>
              <p class="role-description">
                {{ getRoleDescription(driver.role) }}
              </p>
            </div>

            <div class="permissions-grid">
              <!-- General Permissions -->
              <div class="permissions-category">
                <h3>General Permissions</h3>
                <div class="permission-group">
                  <div class="permission-item" *ngFor="let perm of permissionList | slice : 0 : 4">
                    <div class="permission-header">
                      <mat-icon>{{ getPermissionIcon(perm.key) }}</mat-icon>
                      <span class="permission-name">{{ perm.name }}</span>
                    </div>
                    <div class="permission-status" [ngClass]="{ 'permission-granted': hasPermission(perm.key), 'permission-denied': !hasPermission(perm.key) }">
                      <mat-icon>{{ hasPermission(perm.key) ? 'check_circle' : 'cancel' }}</mat-icon>
                      <span>{{ hasPermission(perm.key) ? 'Granted' : 'Not Granted' }}</span>
                    </div>
                    <p class="permission-description">{{ perm.description }}</p>
                  </div>
                </div>
              </div>

              <!-- Job Management Permissions -->
              <div class="permissions-category">
                <h3>Job Management</h3>
                <div class="permission-group">
                  <div class="permission-item" *ngFor="let perm of permissionList | slice : 4 : 8">
                    <div class="permission-header">
                      <mat-icon>{{ getPermissionIcon(perm.key) }}</mat-icon>
                      <span class="permission-name">{{ perm.name }}</span>
                    </div>
                    <div class="permission-status" [ngClass]="{ 'permission-granted': hasPermission(perm.key), 'permission-denied': !hasPermission(perm.key) }">
                      <mat-icon>{{ hasPermission(perm.key) ? 'check_circle' : 'cancel' }}</mat-icon>
                      <span>{{ hasPermission(perm.key) ? 'Granted' : 'Not Granted' }}</span>
                    </div>
                    <p class="permission-description">{{ perm.description }}</p>
                  </div>
                </div>
              </div>

              <!-- Financial Permissions -->
              <div class="permissions-category">
                <h3>Financial & Reports</h3>
                <div class="permission-group">
                  <div class="permission-item" *ngFor="let perm of permissionList | slice : 8 : 13">
                    <div class="permission-header">
                      <mat-icon>{{ getPermissionIcon(perm.key) }}</mat-icon>
                      <span class="permission-name">{{ perm.name }}</span>
                    </div>
                    <div class="permission-status" [ngClass]="{ 'permission-granted': hasPermission(perm.key), 'permission-denied': !hasPermission(perm.key) }">
                      <mat-icon>{{ hasPermission(perm.key) ? 'check_circle' : 'cancel' }}</mat-icon>
                      <span>{{ hasPermission(perm.key) ? 'Granted' : 'Not Granted' }}</span>
                    </div>
                    <p class="permission-description">{{ perm.description }}</p>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </mat-card>
      </div>

      <!-- Notes Tab -->
      <div *ngSwitchCase="'notes'" class="notes-tab">
        <mat-card class="notes-section">
          <div class="section-header">
            <h2>Driver Notes</h2>
            <button mat-flat-button color="primary" (click)="addNote()" *ngIf="hasEditPermission">
              <mat-icon>add</mat-icon>
              Add Note
            </button>
          </div>

          <div class="notes-timeline" *ngIf="driverNotes.length > 0">
            <div class="note-item" *ngFor="let note of driverNotes">
              <div class="note-header">
                <div class="note-author">
                  <span class="author-avatar">{{ getInitials(note.authorName) }}</span>
                  <div class="author-details">
                    <span class="author-name">{{ note.authorName }}</span>
                    <span class="note-date">{{ note.date | date : 'medium' }}</span>
                  </div>
                </div>
                <button mat-icon-button [matMenuTriggerFor]="noteMenu" *ngIf="hasEditPermission">
                  <mat-icon>more_vert</mat-icon>
                </button>
                <mat-menu #noteMenu="matMenu">
                  <button mat-menu-item (click)="editNote(note)">
                    <mat-icon>edit</mat-icon>
                    <span>Edit</span>
                  </button>
                  <button mat-menu-item (click)="deleteNote(note)">
                    <mat-icon>delete</mat-icon>
                    <span>Delete</span>
                  </button>
                </mat-menu>
              </div>
              <div class="note-content">
                <p>{{ note.content }}</p>
              </div>
            </div>
          </div>

          <div class="empty-notes" *ngIf="driverNotes.length === 0">
            <mat-icon>note</mat-icon>
            <h3>No Notes</h3>
            <p>There are no notes for this driver yet.</p>
            <button mat-flat-button color="primary" (click)="addNote()" *ngIf="hasEditPermission">
              <mat-icon>add</mat-icon>
              Add First Note
            </button>
          </div>
        </mat-card>
      </div>
    </div>
  </mat-card-content>
</mat-card>

<!-- Permissions Dialog Template -->
<ng-template #permissionsDialog>
  <h2 mat-dialog-title>Edit Permissions for {{ driver?.firstName }} {{ driver?.lastName }}</h2>
  <mat-dialog-content>
    <form [formGroup]="permissionsForm">
      <!-- Role Selection -->
      <mat-form-field appearance="outline" class="full-width">
        <mat-label>Role</mat-label>
        <mat-select formControlName="role">
          <mat-option *ngFor="let role of availableRoles" [value]="role">{{ role }}</mat-option>
        </mat-select>
        <mat-hint>Selecting a role will automatically set appropriate permissions</mat-hint>
      </mat-form-field>

      <div class="permissions-info">
        <h3>Role Permissions</h3>

        <div class="role-permissions-description" [ngSwitch]="permissionsForm.get('role')?.value">
          <div *ngSwitchCase="'Admin'" class="role-description">
            <mat-icon>admin_panel_settings</mat-icon>
            <div>
              <h4>Admin Role</h4>
              <p>Full system administrator with access to all features and settings. Has complete control and can manage all aspects of the system.</p>
            </div>
          </div>
          <div *ngSwitchCase="'System User'" class="role-description">
            <mat-icon>supervisor_account</mat-icon>
            <div>
              <h4>System User Role</h4>
              <p>Has access to most system features except administrative settings. Can manage jobs, drivers, and perform daily operations.</p>
            </div>
          </div>
          <div *ngSwitchCase="'Driver'" class="role-description">
            <mat-icon>directions_car</mat-icon>
            <div>
              <h4>Driver Role</h4>
              <p>Can view and manage assigned jobs and submit expenses. Has limited access to system features focused on job execution.</p>
            </div>
          </div>
          <div *ngSwitchCase="'Contractor'" class="role-description">
            <mat-icon>work_outline</mat-icon>
            <div>
              <h4>Contractor Role</h4>
              <p>Has very limited access to only view assigned jobs and submit expenses. Cannot access any management features.</p>
            </div>
          </div>
        </div>
      </div>
    </form>
  </mat-dialog-content>
  <mat-dialog-actions align="end">
    <button mat-button mat-dialog-close>Cancel</button>
    <button mat-flat-button color="primary" (click)="savePermissions()">Save Permissions</button>
  </mat-dialog-actions>
</ng-template>

<!-- Note Dialog Template -->
<ng-template #noteDialog>
  <h2 mat-dialog-title>{{ editingNote ? 'Edit Note' : 'Add Note' }}</h2>
  <mat-dialog-content>
    <form [formGroup]="noteForm">
      <mat-form-field appearance="outline" class="full-width">
        <mat-label>Note</mat-label>
        <textarea matInput formControlName="content" rows="6" placeholder="Enter note about this driver"></textarea>
        <mat-error *ngIf="noteForm.get('content')?.hasError('required')">Note content is required</mat-error>
      </mat-form-field>
    </form>
  </mat-dialog-content>
  <mat-dialog-actions align="end">
    <button mat-button mat-dialog-close>Cancel</button>
    <button mat-flat-button color="primary" (click)="saveNote()" [disabled]="noteForm.invalid">Save Note</button>
  </mat-dialog-actions>
</ng-template>


--- ./src/app/pages/drivers/driver-details/driver-details.component.ts ---
import { Location } from '@angular/common';
import { Component, OnDestroy, OnInit, TemplateRef, ViewChild } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { MatDialog } from '@angular/material/dialog';
import { MatPaginator } from '@angular/material/paginator';
import { MatSnackBar } from '@angular/material/snack-bar';
import { MatSort } from '@angular/material/sort';
import { MatTableDataSource } from '@angular/material/table';
import { ActivatedRoute, Router } from '@angular/router';
import { Observable, Subscription, forkJoin, of } from 'rxjs';
import { catchError, finalize, switchMap, tap } from 'rxjs/operators';

import { ConfirmationDialogComponent } from '../../../dialogs/confirmation-dialog.component';
import { Job } from '../../../interfaces/job.interface';
import { UserProfile, UserRole } from '../../../interfaces/user-profile.interface';
import { AuthService } from '../../../services/auth.service';
import { DriverNote, DriverService, DriverStats } from '../../../services/driver.service';
import { JobService } from '../../../services/job.service';
import { NotificationService } from '../../../services/notification.service';

interface PermissionInfo {
  key: string;
  name: string;
  description: string;
}

@Component({
  selector: 'app-driver-details',
  templateUrl: './driver-details.component.html',
  styleUrls: ['./driver-details.component.scss'],
  standalone: false,
})
export class DriverDetailsComponent implements OnInit, OnDestroy {
  driverId: string = '';
  driver: UserProfile | null = null;
  isLoading = true;
  hasEditPermission = false;
  activeTab: 'details' | 'jobs' | 'permissions' | 'notes' = 'details';

  // Jobs table
  jobsDataSource = new MatTableDataSource<Job>([]);
  jobColumns: string[] = ['id', 'status', 'vehicle', 'collection', 'delivery', 'date', 'actions'];
  isJobsLoading = false;

  // Driver stats
  driverStats: DriverStats = {
    totalJobs: 0,
    pendingJobs: 0,
    completedJobs: 0,
    pendingExpenses: 0,
  };

  // Driver notes
  driverNotes: DriverNote[] = [];
  isNotesLoading = false;

  // Permissions
  permissionsForm!: FormGroup;
  availableRoles = Object.values(UserRole);

  // Notes
  noteForm!: FormGroup;
  editingNote: DriverNote | null = null;

  // Permission list
  permissionList: PermissionInfo[] = [
    {
      key: 'canAllocateJobs',
      name: 'Allocate Jobs',
      description: 'Ability to assign jobs to drivers',
    },
    {
      key: 'canApproveExpenses',
      name: 'Approve Expenses',
      description: 'Ability to approve expense claims submitted by drivers',
    },
    {
      key: 'canCreateJobs',
      name: 'Create Jobs',
      description: 'Ability to create new jobs in the system',
    },
    {
      key: 'canEditJobs',
      name: 'Edit Jobs',
      description: 'Ability to modify existing job details',
    },
    {
      key: 'canManageUsers',
      name: 'Manage Users',
      description: 'Ability to create, edit, and delete users',
    },
    {
      key: 'canViewReports',
      name: 'View Reports',
      description: 'Access to system reports and analytics',
    },
    {
      key: 'canViewUnallocated',
      name: 'View Unallocated Jobs',
      description: 'Ability to see jobs that have not been assigned to a driver',
    },
    {
      key: 'isAdmin',
      name: 'Administrator',
      description: 'Full system access with all permissions granted',
    },
    {
      key: 'canViewSystemSettings',
      name: 'View System Settings',
      description: 'Access to system configuration and settings',
    },
    {
      key: 'canManageCompanies',
      name: 'Manage Companies',
      description: 'Ability to create and edit company information',
    },
    {
      key: 'canViewAllJobs',
      name: 'View All Jobs',
      description: 'Access to see all jobs in the system regardless of assignment',
    },
    {
      key: 'canViewAssignedJobs',
      name: 'View Assigned Jobs',
      description: 'Ability to see jobs assigned to the driver',
    },
    {
      key: 'canCreateExpenses',
      name: 'Create Expenses',
      description: 'Ability to submit expense claims',
    },
  ];

  @ViewChild(MatSort) sort!: MatSort;
  @ViewChild(MatPaginator) paginator!: MatPaginator;
  @ViewChild('permissionsDialog') permissionsDialog!: TemplateRef<any>;
  @ViewChild('noteDialog') noteDialog!: TemplateRef<any>;

  private subscriptions: Subscription[] = [];

  constructor(
    private route: ActivatedRoute,
    private router: Router,
    private location: Location,
    private authService: AuthService,
    private driverService: DriverService,
    private jobService: JobService,
    private notificationService: NotificationService,
    private dialog: MatDialog,
    private snackBar: MatSnackBar,
    private fb: FormBuilder
  ) {
    this.createForms();
  }

  ngOnInit(): void {
    // Get driver ID from route
    const routeSub = this.route.paramMap.subscribe((params) => {
      const id = params.get('id');
      if (id) {
        this.driverId = id;
        this.loadDriverDetails();
      } else {
        this.router.navigate(['/drivers']);
      }
    });
    this.subscriptions.push(routeSub);

    // Check permissions
    const permissionSub = this.authService.hasPermission('canManageUsers').subscribe((hasPermission) => {
      this.hasEditPermission = hasPermission;
    });
    this.subscriptions.push(permissionSub);
  }

  ngOnDestroy(): void {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }

  private createForms(): void {
    // Permissions form
    this.permissionsForm = this.fb.group({
      role: ['', Validators.required],
    });

    // Note form
    this.noteForm = this.fb.group({
      content: ['', Validators.required],
    });
  }

  /**
   * Load driver details and related data
   */
  loadDriverDetails(): void {
    this.isLoading = true;

    const detailsSub = this.driverService
      .getDriverById(this.driverId)
      .pipe(
        tap((driver) => {
          this.driver = driver;
        }),
        switchMap((driver) => {
          if (driver) {
            // Load related data in parallel
            return forkJoin({
              jobs: this.loadDriverJobs(),
              notes: this.loadDriverNotes(),
              stats: this.driverService.getDriverStats(driver.id),
            });
          }
          return of(null);
        }),
        finalize(() => {
          this.isLoading = false;
        }),
        catchError((error) => {
          console.error('Error loading driver details:', error);
          this.notificationService.addNotification({
            type: 'error',
            title: 'Error',
            message: 'Failed to load driver details',
          });
          this.router.navigate(['/drivers']);
          return of(null);
        })
      )
      .subscribe((result) => {
        if (result && this.driver) {
          this.driverStats = result.stats;
        }
      });

    this.subscriptions.push(detailsSub);
  }

  /**
   * Load driver jobs
   */
  loadDriverJobs(): Observable<Job[]> {
    this.isJobsLoading = true;

    return this.jobService.getJobsByDriver(this.driverId).pipe(
      tap((jobs) => {
        this.jobsDataSource.data = jobs;
        setTimeout(() => {
          if (this.sort && this.paginator) {
            this.jobsDataSource.sort = this.sort;
            this.jobsDataSource.paginator = this.paginator;
          }
        });
        this.isJobsLoading = false;
      }),
      catchError((error) => {
        console.error('Error loading driver jobs:', error);
        this.isJobsLoading = false;
        return of([]);
      })
    );
  }

  /**
   * Load driver notes
   */
  loadDriverNotes(): Observable<DriverNote[]> {
    this.isNotesLoading = true;

    return this.driverService.getDriverNotes(this.driverId).pipe(
      tap((notes) => {
        this.driverNotes = notes;
        this.isNotesLoading = false;
      }),
      catchError((error) => {
        console.error('Error loading driver notes:', error);
        this.isNotesLoading = false;
        return of([]);
      })
    );
  }

  /**
   * Open permissions dialog
   */
  editPermissions(): void {
    if (!this.driver) return;

    // Initialize form with current role
    this.permissionsForm.patchValue({
      role: this.driver.role || UserRole.DRIVER,
    });

    this.dialog.open(this.permissionsDialog, {
      width: '500px',
      disableClose: true,
    });
  }

  /**
   * Save updated permissions based on role
   */
  savePermissions(): void {
    if (!this.driver) return;

    const role = this.permissionsForm.value.role as UserRole;

    this.driverService.updateDriverPermissions(this.driverId, role).subscribe({
      next: () => {
        this.dialog.closeAll();
        this.notificationService.addNotification({
          type: 'success',
          title: 'Permissions Updated',
          message: `The driver permissions have been set to ${role} role successfully`,
        });
        this.loadDriverDetails(); // Refresh driver data
      },
      error: (error) => {
        console.error('Error updating permissions:', error);
        this.notificationService.addNotification({
          type: 'error',
          title: 'Error',
          message: 'Failed to update permissions',
        });
      },
    });
  }

  /**
   * Open note dialog for adding
   */
  addNote(): void {
    this.editingNote = null;
    this.noteForm.reset();
    this.dialog.open(this.noteDialog, {
      width: '500px',
    });
  }

  /**
   * Open note dialog for editing
   */
  editNote(note: DriverNote): void {
    this.editingNote = note;
    this.noteForm.patchValue({
      content: note.content,
    });
    this.dialog.open(this.noteDialog, {
      width: '500px',
    });
  }

  /**
   * Save new or updated note
   */
  saveNote(): void {
    if (this.noteForm.invalid || !this.driver) return;

    const content = this.noteForm.get('content')?.value;

    // Get current user for author info
    this.authService.getUserProfile().subscribe((userProfile) => {
      if (!userProfile) {
        this.snackBar.open('You must be logged in to add notes', 'Close', { duration: 3000 });
        return;
      }

      if (this.editingNote) {
        // Update existing note
        this.driverService.updateDriverNote(this.editingNote.id, content).subscribe({
          next: () => {
            this.dialog.closeAll();
            this.loadDriverNotes(); // Refresh notes
            this.snackBar.open('Note updated successfully', 'Close', { duration: 3000 });
          },
          error: (error) => {
            console.error('Error updating note:', error);
            this.snackBar.open('Error updating note', 'Close', { duration: 3000 });
          },
        });
      } else {
        // Add new note
        this.driverService.addDriverNote(this.driverId, content, userProfile.id, userProfile.name).subscribe({
          next: () => {
            this.dialog.closeAll();
            this.loadDriverNotes(); // Refresh notes
            this.snackBar.open('Note added successfully', 'Close', { duration: 3000 });
          },
          error: (error) => {
            console.error('Error adding note:', error);
            this.snackBar.open('Error adding note', 'Close', { duration: 3000 });
          },
        });
      }
    });
  }

  /**
   * Delete note
   */
  deleteNote(note: DriverNote): void {
    const dialogRef = this.dialog.open(ConfirmationDialogComponent, {
      data: {
        title: 'Delete Note',
        message: 'Are you sure you want to delete this note? This action cannot be undone.',
        confirmText: 'Delete',
        cancelText: 'Cancel',
        confirmColor: 'warn',
      },
      width: '400px',
    });

    dialogRef.afterClosed().subscribe((result) => {
      if (result) {
        this.driverService.deleteDriverNote(note.id).subscribe({
          next: () => {
            this.loadDriverNotes(); // Refresh notes
            this.snackBar.open('Note deleted successfully', 'Close', { duration: 3000 });
          },
          error: (error) => {
            console.error('Error deleting note:', error);
            this.snackBar.open('Error deleting note', 'Close', { duration: 3000 });
          },
        });
      }
    });
  }

  /**
   * Delete driver
   */
  deleteDriver(): void {
    if (!this.driver) return;

    const dialogRef = this.dialog.open(ConfirmationDialogComponent, {
      data: {
        title: 'Delete Driver',
        message: `Are you sure you want to delete ${this.driver.firstName} ${this.driver.lastName}? This action cannot be undone.`,
        confirmText: 'Delete',
        cancelText: 'Cancel',
        confirmColor: 'warn',
        icon: 'delete_forever',
      },
      width: '400px',
    });

    dialogRef.afterClosed().subscribe((result) => {
      if (result) {
        // Deactivate the driver (soft delete)
        this.driverService.deactivateDriver(this.driverId).subscribe({
          next: () => {
            this.notificationService.addNotification({
              type: 'success',
              title: 'Driver Deleted',
              message: `${this.driver?.firstName} ${this.driver?.lastName} has been deleted successfully`,
            });
            this.router.navigate(['/drivers']);
          },
          error: (error) => {
            console.error('Error deleting driver:', error);
            this.notificationService.addNotification({
              type: 'error',
              title: 'Error',
              message: 'Failed to delete driver',
            });
          },
        });
      }
    });
  }

  /**
   * Navigate to edit driver page
   */
  editDriver(): void {
    this.router.navigate(['/drivers', this.driverId, 'edit']);
  }

  /**
   * Send message to driver
   */
  sendMessage(): void {
    // This would integrate with a messaging system in a real app
    this.snackBar.open('Messaging functionality will be implemented in a future release', 'Close', {
      duration: 3000,
    });
  }

  /**
   * Handle unassign job
   */
  unassignJob(job: Job): void {
    const dialogRef = this.dialog.open(ConfirmationDialogComponent, {
      data: {
        title: 'Unassign Job',
        message: `Are you sure you want to unassign job ${job.id} from this driver?`,
        confirmText: 'Unassign',
        cancelText: 'Cancel',
        confirmColor: 'warn',
      },
      width: '400px',
    });

    dialogRef.afterClosed().subscribe((result) => {
      if (result) {
        this.jobService.unallocateJob(job.id).subscribe({
          next: () => {
            this.loadDriverJobs(); // Refresh jobs list
            // Refresh driver stats
            this.driverService.getDriverStats(this.driverId).subscribe((stats) => {
              this.driverStats = stats;
            });

            this.notificationService.addNotification({
              type: 'success',
              title: 'Job Unassigned',
              message: `Job ${job.id} has been unassigned successfully`,
            });
          },
          error: (error) => {
            console.error('Error unassigning job:', error);
            this.notificationService.addNotification({
              type: 'error',
              title: 'Error',
              message: 'Failed to unassign job',
            });
          },
        });
      }
    });
  }

  /**
   * Check if a job can be unassigned (based on status)
   */
  canUnassignJob(job: Job): boolean {
    // Only allow unassigning if the job is allocated (not yet started)
    return job.status === 'allocated' || job.status === 'unallocated';
  }

  /**
   * Navigate to view job details
   */
  viewJobDetails(jobId: string): void {
    this.router.navigate(['/jobs', jobId]);
  }

  /**
   * Navigate to edit job
   */
  editJob(jobId: string): void {
    this.router.navigate(['/jobs', jobId, 'edit']);
  }

  /**
   * Set active tab
   */
  setActiveTab(tab: 'details' | 'jobs' | 'permissions' | 'notes'): void {
    this.activeTab = tab;
  }

  /**
   * Get initials for driver avatar
   */
  getDriverInitials(driver: UserProfile | null): string {
    if (!driver) return '??';

    if (driver.name && driver.name.length > 0) {
      const nameParts = driver.name.split(' ');
      if (nameParts.length > 1) {
        return (nameParts[0][0] + nameParts[1][0]).toUpperCase();
      }
      return nameParts[0][0].toUpperCase();
    }

    const firstName = driver.firstName || '';
    const lastName = driver.lastName || '';

    if (!firstName && !lastName) {
      return driver.email[0].toUpperCase();
    }

    return ((firstName[0] || '') + (lastName[0] || '')).toUpperCase();
  }

  /**
   * Get initials from name for notes
   */
  getInitials(name: string): string {
    if (!name) return '??';

    const nameParts = name.split(' ');
    if (nameParts.length === 1) {
      return nameParts[0][0].toUpperCase();
    }
    return (nameParts[0][0] + nameParts[nameParts.length - 1][0]).toUpperCase();
  }

  /**
   * Get status class for CSS styling
   */
  getStatusClass(status: string | undefined): string {
    if (!status) return 'status-gray';

    switch (status.toLowerCase()) {
      case 'active':
        return 'status-green';
      case 'pending':
        return 'status-orange';
      case 'inactive':
      default:
        return 'status-gray';
    }
  }

  /**
   * Get type class for CSS styling
   */
  getTypeClass(type: string | undefined): string {
    if (!type) return 'type-blue';

    switch (type.toLowerCase()) {
      case 'customer':
        return 'type-blue';
      case 'supplier':
        return 'type-purple';
      case 'partner':
        return 'type-orange';
      default:
        return 'type-blue';
    }
  }

  /**
   * Get role class for CSS styling
   */
  getRoleClass(role: string | undefined): string {
    if (!role) return 'role-driver';

    switch (role.toLowerCase()) {
      case 'admin':
        return 'role-admin';
      case 'system user':
        return 'role-manager';
      case 'contractor':
        return 'role-dispatcher';
      case 'driver':
        return 'role-driver';
      default:
        return 'role-driver';
    }
  }

  /**
   * Get job status class for CSS styling
   */
  getJobStatusClass(status: string | undefined): string {
    if (!status) return 'status-gray';

    switch (status.toLowerCase()) {
      case 'allocated':
        return 'status-orange';
      case 'collected':
        return 'status-info';
      case 'delivered':
        return 'status-success';
      case 'completed':
        return 'status-green';
      case 'unallocated':
        return 'status-gray';
      default:
        return 'status-gray';
    }
  }

  /**
   * Get permission icon for CSS styling
   */
  getPermissionIcon(key: string): string {
    const icons: { [key: string]: string } = {
      canAllocateJobs: 'assignment_ind',
      canApproveExpenses: 'payments',
      canCreateJobs: 'add_task',
      canEditJobs: 'edit_note',
      canManageUsers: 'manage_accounts',
      canViewReports: 'assessment',
      canViewUnallocated: 'visibility',
      isAdmin: 'admin_panel_settings',
      canViewSystemSettings: 'settings',
      canManageCompanies: 'business',
      canViewAllJobs: 'list_alt',
      canViewAssignedJobs: 'assignment_turned_in',
      canCreateExpenses: 'receipt_long',
    };

    return icons[key] || 'check_circle';
  }

  /**
   * Check if driver has a specific permission
   */
  hasPermission(key: string): boolean {
    if (!this.driver || !this.driver.permissions) {
      return false;
    }

    // Check for admin first (admins have all permissions)
    if (this.driver.permissions.isAdmin) {
      return true;
    }

    // Check specific permission
    return !!this.driver.permissions[key as keyof typeof this.driver.permissions];
  }

  /**
   * Get role description
   */
  getRoleDescription(role: string | undefined): string {
    if (!role) return 'Standard user with limited access';

    switch (role.toLowerCase()) {
      case 'admin':
        return 'Full system administrator with access to all features and settings';
      case 'system user':
        return 'Access to most features except system administration';
      case 'contractor':
        return 'Limited access to view only assigned jobs and submit expenses';
      case 'driver':
        return 'Can view and manage assigned jobs and submit expenses';
      default:
        return 'Standard user with limited access';
    }
  }

  /**
   * Navigate back
   */
  goBack(): void {
    this.location.back();
  }
}


--- ./src/app/pages/drivers/driver-details/driver-details.component.scss ---
:host {
  display: block;
  padding: 24px;
  background-color: #f5f5f5;
  min-height: 100vh;
  margin-left: 250px; /* Account for sidebar width */
  padding-top: 88px; /* Account for topbar height (64px) + some padding */
}

/* Card styles */
.mat-mdc-card {
  margin-bottom: 24px;
  background-color: white;
  border-radius: 8px;
}

/* Loading Overlay */
.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.9);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  gap: 16px;

  span {
    color: rgba(0, 0, 0, 0.6);
    font-size: 14px;
  }
}

/* Header Section */
.header-wrapper {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 24px;
  border-bottom: 1px solid rgba(0, 0, 0, 0.12);

  .header-title {
    display: flex;
    align-items: center;
    gap: 16px;

    .title-content {
      display: flex;
      flex-direction: column;
      gap: 4px;

      h1 {
        margin: 0;
        font-size: 24px;
        font-weight: 600;
        color: var(--primary-color);
      }
    }

    .driver-status {
      display: flex;
      align-items: center;
      gap: 8px;
    }
  }

  .header-actions {
    display: flex;
    gap: 12px;

    button {
      display: flex;
      align-items: center;
      gap: 8px;
    }
  }
}

/* Tab Navigation */
.tab-navigation {
  padding: 0 24px;
  display: flex;
  gap: 32px;
  border-bottom: 1px solid rgba(0, 0, 0, 0.12);

  button {
    padding: 16px 8px;
    background: none;
    border: none;
    color: rgba(0, 0, 0, 0.6);
    font-weight: 500;
    cursor: pointer;
    position: relative;
    transition: color 0.2s ease;

    &:hover {
      color: rgba(0, 0, 0, 0.87);
    }

    &.active {
      color: var(--primary-color);

      &::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 2px;
        background-color: var(--primary-color);
      }
    }
  }
}

/* Content Wrapper */
.content-wrapper {
  padding: 24px;
}

/* Details Tab */
.details-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 24px;
  margin-bottom: 24px;
}

.details-section,
.profile-section,
.jobs-section,
.permissions-section,
.notes-section {
  padding: 24px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
  background-color: white;

  h2 {
    margin-top: 0;
    margin-bottom: 24px;
    font-size: 18px;
    color: var(--primary-color);
    font-weight: 600;
  }
}

/* Information Grid */
.info-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 16px;

  .info-item {
    display: flex;
    flex-direction: column;
    gap: 4px;

    &.full-width {
      grid-column: 1 / -1;
    }

    label {
      font-size: 14px;
      color: rgba(0, 0, 0, 0.6);
      font-weight: 500;
    }

    a {
      color: var(--primary-color);
      text-decoration: none;

      &:hover {
        text-decoration: underline;
      }
    }
  }
}

/* Status Chips */
.status-chip,
.role-chip {
  display: inline-flex;
  padding: 6px 12px;
  border-radius: 16px;
  font-size: 14px;
  font-weight: 500;
  text-transform: capitalize;

  &.small {
    padding: 4px 8px;
    font-size: 12px;
  }
}

.status-chip {
  &.status-green {
    background-color: rgba(76, 175, 80, 0.12);
    color: #4caf50;
  }

  &.status-gray {
    background-color: rgba(97, 97, 97, 0.12);
    color: #616161;
  }

  &.status-orange {
    background-color: rgba(255, 152, 0, 0.12);
    color: #ff9800;
  }

  &.status-info {
    background-color: rgba(33, 150, 243, 0.12);
    color: #2196f3;
  }

  &.status-success {
    background-color: rgba(76, 175, 80, 0.12);
    color: #4caf50;
  }
}

.role-chip {
  &.role-admin {
    background-color: rgba(156, 39, 176, 0.12);
    color: #9c27b0;
  }

  &.role-manager {
    background-color: rgba(63, 81, 181, 0.12);
    color: #3f51b5;
  }

  &.role-dispatcher {
    background-color: rgba(0, 150, 136, 0.12);
    color: #009688;
  }

  &.role-driver {
    background-color: rgba(33, 150, 243, 0.12);
    color: #2196f3;
  }

  &.role-user {
    background-color: rgba(97, 97, 97, 0.12);
    color: #616161;
  }
}

/* Type classes */
.type-blue {
  background-color: rgba(25, 118, 210, 0.12);
  color: #1976d2;
}

.type-purple {
  background-color: rgba(156, 39, 176, 0.12);
  color: #9c27b0;
}

.type-orange {
  background-color: rgba(245, 124, 0, 0.12);
  color: #f57c00;
}

/* Stats Section */
.stats-section {
  .stats-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 16px;

    .stat-item {
      display: flex;
      align-items: center;
      padding: 16px;
      border-radius: 8px;
      background-color: #f8f9fa;
      gap: 16px;

      .stat-icon {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 48px;
        height: 48px;
        border-radius: 50%;
        background-color: rgba(var(--primary-color-rgb), 0.12);
        color: var(--primary-color);

        mat-icon {
          font-size: 24px;
          width: 24px;
          height: 24px;
        }
      }

      .stat-content {
        display: flex;
        flex-direction: column;

        .stat-value {
          font-size: 24px;
          font-weight: 600;
          color: rgba(0, 0, 0, 0.87);
        }

        .stat-label {
          font-size: 14px;
          color: rgba(0, 0, 0, 0.6);
        }
      }
    }
  }
}

/* Profile Section */
.profile-section {
  .profile-content {
    .profile-header {
      display: flex;
      gap: 24px;
      margin-bottom: 24px;

      .profile-avatar {
        width: 80px;
        height: 80px;
        border-radius: 50%;
        background-color: var(--primary-color);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 32px;
        font-weight: 500;
      }

      .profile-details {
        flex: 1;

        h3 {
          margin: 0 0 4px;
          font-size: 20px;
          font-weight: 600;
          color: rgba(0, 0, 0, 0.87);
        }

        .profile-company {
          margin: 0 0 16px;
          color: rgba(0, 0, 0, 0.6);
          font-size: 16px;
        }

        .contact-buttons {
          display: flex;
          gap: 12px;
          flex-wrap: wrap;

          .contact-button {
            display: flex;
            align-items: center;
            gap: 8px;
          }
        }
      }
    }

    .profile-section-divider {
      height: 1px;
      background-color: rgba(0, 0, 0, 0.12);
      margin-bottom: 24px;
    }

    .profile-info {
      .info-row {
        display: flex;
        margin-bottom: 16px;

        &:last-child {
          margin-bottom: 0;
        }

        .info-label {
          flex: 0 0 200px;
          font-weight: 500;
          color: rgba(0, 0, 0, 0.6);
        }

        .info-value {
          flex: 1;
          color: rgba(0, 0, 0, 0.87);
        }
      }
    }
  }
}

/* Jobs Section */
.jobs-section {
  .section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 24px;

    h2 {
      margin: 0;
    }
  }

  .table-container {
    position: relative;
    min-height: 200px;
    max-height: 500px;
    overflow: auto;

    table {
      width: 100%;
    }

    .mat-mdc-header-cell {
      background-color: #f8f9fa;
      font-weight: 500;
      color: rgba(0, 0, 0, 0.6);
      font-size: 12px;
      text-transform: uppercase;
      white-space: nowrap;
    }

    .mat-mdc-cell {
      font-size: 14px;
    }

    .job-row {
      height: 48px;
      cursor: pointer;
      transition: background-color 0.2s;

      &:hover {
        background-color: #f5f5f5;
      }
    }

    .empty-state {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      width: 100%;
      padding: 24px;
      box-sizing: border-box;

      mat-icon {
        font-size: 48px;
        width: 48px;
        height: 48px;
        color: rgba(0, 0, 0, 0.38);
        margin-bottom: 16px;
      }

      h3 {
        margin: 0 0 8px;
        font-size: 16px;
        color: rgba(0, 0, 0, 0.87);
      }

      p {
        margin: 0 0 24px;
        color: rgba(0, 0, 0, 0.6);
        font-size: 14px;
      }
    }
  }
}

/* Permissions Section */
.permissions-section {
  .section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 24px;

    h2 {
      margin: 0;
    }
  }

  .permissions-content {
    .role-summary {
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.12);

      h3 {
        margin: 0 0 8px;
        font-size: 18px;
        font-weight: 500;
        color: rgba(0, 0, 0, 0.87);
      }

      .role-description {
        margin: 0;
        color: rgba(0, 0, 0, 0.6);
        font-size: 14px;
        line-height: 1.5;
      }
    }

    .permissions-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 24px;

      .permissions-category {
        background-color: #f9f9f9;
        border-radius: 8px;
        padding: 16px;

        h3 {
          font-size: 16px;
          font-weight: 500;
          color: var(--primary-color);
          margin: 0 0 12px;
          padding-bottom: 8px;
          border-bottom: 1px solid rgba(0, 0, 0, 0.08);
        }

        .permission-group {
          display: grid;
          grid-template-columns: repeat(1, 1fr);
          gap: 16px;
        }
      }

      .permission-item {
        padding: 16px;
        border-radius: 8px;
        background-color: white;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        transition: transform 0.2s ease, box-shadow 0.2s ease;

        &:hover {
          transform: translateY(-2px);
          box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
        }

        .permission-header {
          display: flex;
          align-items: center;
          gap: 8px;
          margin-bottom: 12px;

          mat-icon {
            color: var(--primary-color);
          }

          .permission-name {
            font-weight: 500;
            color: rgba(0, 0, 0, 0.87);
          }
        }

        .permission-status {
          display: flex;
          align-items: center;
          gap: 8px;
          margin-bottom: 8px;
          font-size: 14px;

          &.permission-granted {
            color: #4caf50;
          }

          &.permission-denied {
            color: #f44336;
          }
        }

        .permission-description {
          margin: 0;
          font-size: 13px;
          color: rgba(0, 0, 0, 0.6);
          line-height: 1.4;
        }
      }
    }
  }
}

/* Notes Section */
.notes-section {
  .section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 24px;

    h2 {
      margin: 0;
    }
  }

  .notes-timeline {
    display: flex;
    flex-direction: column;
    gap: 16px;

    .note-item {
      padding: 16px;
      border-radius: 8px;
      background-color: #f8f9fa;
      border-left: 4px solid var(--primary-color);

      .note-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;

        .note-author {
          display: flex;
          align-items: center;
          gap: 12px;

          .author-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: var(--primary-color);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 500;
          }

          .author-details {
            display: flex;
            flex-direction: column;

            .author-name {
              font-weight: 500;
              font-size: 14px;
              color: rgba(0, 0, 0, 0.87);
            }

            .note-date {
              font-size: 12px;
              color: rgba(0, 0, 0, 0.6);
            }
          }
        }
      }

      .note-content {
        p {
          margin: 0;
          font-size: 14px;
          line-height: 1.5;
          color: rgba(0, 0, 0, 0.87);
          white-space: pre-line;
        }
      }
    }
  }

  .empty-notes {
    text-align: center;
    padding: 48px 24px;

    mat-icon {
      font-size: 48px;
      width: 48px;
      height: 48px;
      color: rgba(0, 0, 0, 0.38);
      margin-bottom: 16px;
    }

    h3 {
      margin: 0 0 8px;
      font-size: 16px;
      color: rgba(0, 0, 0, 0.87);
    }

    p {
      margin: 0 0 24px;
      color: rgba(0, 0, 0, 0.6);
      font-size: 14px;
    }
  }
}

/* Dialog Styling */
::ng-deep {
  .permissions-info {
    margin-top: 24px;

    h3 {
      font-size: 16px;
      font-weight: 500;
      margin: 0 0 16px;
    }

    .role-permissions-description {
      margin-top: 16px;

      .role-description {
        display: flex;
        gap: 16px;
        padding: 16px;
        background-color: #f5f5f5;
        border-radius: 8px;
        margin-bottom: 16px;

        mat-icon {
          font-size: 24px;
          color: var(--primary-color);
        }

        h4 {
          margin: 0 0 8px;
          font-size: 16px;
          font-weight: 500;
        }

        p {
          margin: 0;
          font-size: 14px;
          color: rgba(0, 0, 0, 0.7);
          line-height: 1.5;
        }
      }
    }
  }

  .permissions-checkboxes {
    margin-top: 16px;

    h3 {
      margin: 0 0 4px;
      font-size: 16px;
      font-weight: 500;
      color: rgba(0, 0, 0, 0.87);
    }

    .permissions-hint {
      margin: 0 0 16px;
      font-size: 14px;
      color: rgba(0, 0, 0, 0.6);
    }

    .checkbox-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
    }
  }

  .full-width {
    width: 100%;
  }
}

/* Responsive Design */
@media screen and (max-width: 1200px) {
  .details-grid {
    grid-template-columns: 1fr;
  }

  .stats-section .stats-grid {
    grid-template-columns: 1fr 1fr;
  }

  .permissions-section .permissions-grid {
    grid-template-columns: 1fr;
  }
}

@media screen and (max-width: 992px) {
  .profile-section .profile-content .profile-header {
    flex-direction: column;
    align-items: center;
    text-align: center;

    .profile-details .contact-buttons {
      justify-content: center;
    }
  }

  .permissions-section .permissions-grid {
    grid-template-columns: 1fr;
  }

  .stats-section .stats-grid {
    grid-template-columns: 1fr;
  }

  .permissions-section .permissions-grid .permissions-category .permission-group {
    grid-template-columns: 1fr;
  }
}

@media screen and (max-width: 768px) {
  :host {
    margin-left: 60px; /* Collapsed sidebar width */
    padding-top: 80px; /* Reduced topbar padding for smaller screens */
    padding: 16px;
  }

  .header-wrapper {
    flex-direction: column;
    gap: 16px;
    align-items: flex-start;

    .header-actions {
      width: 100%;
      justify-content: flex-end;
    }
  }

  .tab-navigation {
    overflow-x: auto;
    padding-bottom: 2px;
    width: calc(100% + 48px);
    margin-left: -24px;
    padding-left: 24px;

    button {
      white-space: nowrap;
    }
  }

  .profile-section .profile-content .profile-info .info-row {
    flex-direction: column;
    gap: 4px;

    .info-label {
      flex: none;
    }
  }

  .permissions-checkboxes .checkbox-grid {
    grid-template-columns: 1fr;
  }
}

@media screen and (max-width: 576px) {
  :host {
    padding: 8px;
    padding-top: 72px; /* Further reduced for mobile */
  }

  .header-wrapper {
    padding: 16px;
  }

  .content-wrapper {
    padding: 16px;
  }

  .header-actions {
    flex-direction: column;
    width: 100%;

    button {
      width: 100%;
    }
  }

  .profile-section .profile-content .profile-header .profile-details .contact-buttons {
    flex-direction: column;

    .contact-button {
      width: 100%;
    }
  }

  .mat-column-collection,
  .mat-column-delivery,
  .mat-column-date {
    display: none;
  }
}

/* Print Styles */
@media print {
  :host {
    padding: 0;
    background: white;
    margin-left: 0; /* No sidebar in print */
    padding-top: 0; /* No topbar in print */
  }

  .mat-mdc-card {
    box-shadow: none !important;
  }

  .header-actions,
  .tab-navigation {
    display: none !important;
  }

  .content-wrapper {
    padding: 16px;
  }

  .details-section,
  .profile-section,
  .jobs-section,
  .permissions-section,
  .notes-section {
    break-inside: avoid;
    box-shadow: none !important;
    border: 1px solid #ddd;
  }
}


--- ./src/app/pages/auth/auth.module.ts ---
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule, Routes } from '@angular/router';
import { ReactiveFormsModule, FormsModule } from '@angular/forms';

// Material Modules
import { MaterialModule } from '../../material.module';

// Components
import { AuthLayoutComponent } from './auth-layout/auth-layout.component';
import { SignInComponent } from './sign-in/sign-in.component';
import { SignUpComponent } from './sign-up/sign-up.component';
import { ForgotPasswordComponent } from './forgot-password/forgot-password.component';

// Guards
import { GuestGuard } from '../../guards/guest.guard';

const routes: Routes = [
  {
    path: '',
    component: AuthLayoutComponent,
    children: [
      {
        path: '',
        redirectTo: 'sign-in',
        pathMatch: 'full',
      },
      {
        path: 'sign-in',
        component: SignInComponent,
        canActivate: [GuestGuard],
      },
      {
        path: 'sign-up',
        component: SignUpComponent,
        canActivate: [GuestGuard],
      },
      {
        path: 'forgot-password',
        component: ForgotPasswordComponent,
        canActivate: [GuestGuard],
      },
    ],
  },
];

@NgModule({
  declarations: [
    AuthLayoutComponent,
    SignInComponent,
    SignUpComponent,
    ForgotPasswordComponent,
  ],
  imports: [
    CommonModule,
    ReactiveFormsModule,
    FormsModule,
    MaterialModule,
    RouterModule.forChild(routes),
  ],
  exports: [RouterModule],
})
export class AuthModule {}


--- ./src/app/pages/auth/sign-up/sign-up.component.ts ---
import { Component, OnInit } from '@angular/core';
import {
  FormBuilder,
  FormGroup,
  Validators,
  AbstractControl,
  ValidationErrors,
} from '@angular/forms';
import { Router } from '@angular/router';
import { MatSnackBar } from '@angular/material/snack-bar';
import { AuthService } from '../../../services/auth.service';
import { NotificationService } from '../../../services/notification.service';

@Component({
  selector: 'app-sign-up',
  templateUrl: './sign-up.component.html',
  styleUrls: ['./sign-up.component.scss'],
  standalone: false,
})
export class SignUpComponent implements OnInit {
  signUpForm: FormGroup;
  loading = false;
  hidePassword = true;
  hideConfirmPassword = true;

  constructor(
    private fb: FormBuilder,
    private authService: AuthService,
    private router: Router,
    private snackBar: MatSnackBar,
    private notificationService: NotificationService
  ) {
    this.signUpForm = this.fb.group(
      {
        firstName: ['', [Validators.required]],
        lastName: ['', [Validators.required]],
        email: ['', [Validators.required, Validators.email]],
        password: ['', [Validators.required, Validators.minLength(6)]],
        confirmPassword: ['', [Validators.required]],
        acceptTerms: [false, [Validators.requiredTrue]],
      },
      {
        validators: this.passwordMatchValidator,
      }
    );
  }

  ngOnInit(): void {
    // Check if already logged in
    this.authService.user$.subscribe((user) => {
      if (user) {
        this.router.navigate(['/dashboard']);
      }
    });
  }

  passwordMatchValidator(control: AbstractControl): ValidationErrors | null {
    const password = control.get('password');
    const confirmPassword = control.get('confirmPassword');

    if (
      password &&
      confirmPassword &&
      password.value !== confirmPassword.value
    ) {
      confirmPassword.setErrors({ passwordMismatch: true });
      return { passwordMismatch: true };
    }

    return null;
  }

  onSubmit(): void {
    if (this.signUpForm.invalid) {
      return;
    }

    this.loading = true;
    const { firstName, lastName, email, password } = this.signUpForm.value;

    // Extend the signUp method to handle user profile creation
    this.authService
      .signUp(email, password, { firstName, lastName })
      .subscribe({
        next: () => {
          this.loading = false;
          this.notificationService.addNotification({
            type: 'success',
            title: 'Account Created',
            message: 'Your account has been successfully created',
          });
          this.router.navigate(['/dashboard']);
        },
        error: (error) => {
          this.loading = false;
          let errorMessage = 'Sign up failed. Please try again.';

          // Map Firebase error codes to user-friendly messages
          if (error.code === 'auth/email-already-in-use') {
            errorMessage =
              'This email is already registered. Please sign in instead.';
          } else if (error.code === 'auth/invalid-email') {
            errorMessage = 'Please provide a valid email address.';
          } else if (error.code === 'auth/weak-password') {
            errorMessage =
              'Your password is too weak. Please choose a stronger password.';
          }

          this.snackBar.open(errorMessage, 'Dismiss', {
            duration: 5000,
            panelClass: ['error-snackbar'],
          });
        },
      });
  }

  navigateToSignIn(): void {
    this.router.navigate(['/auth/sign-in']);
  }
}


--- ./src/app/pages/auth/sign-up/sign-up.component.scss ---
/* sign-up.component.scss */
.sign-up-container {
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%;
}

.sign-up-card {
  width: 500px;
  max-width: 90%;
  padding: 32px;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
  display: flex;
  flex-direction: column;
  align-items: center;

  /* Animation */
  animation: fadeInUp 0.4s ease-out;
}

.logo-container {
  margin-bottom: 24px;
  text-align: center;
}

.logo {
  max-width: 180px;
  height: auto;
}

.sign-up-title {
  font-size: 28px;
  font-weight: 700;
  color: var(--primary-color);
  margin: 0 0 8px 0;
}

.sign-up-subtitle {
  color: var(--text-secondary);
  margin-bottom: 32px;
  text-align: center;
}

.sign-up-form {
  width: 100%;
}

.name-fields {
  display: flex;
  gap: 16px;
}

.form-field {
  width: 100%;
  margin-bottom: 20px;
}

.terms-checkbox {
  margin-bottom: 24px;
}

.terms-checkbox a {
  color: var(--secondary-color);
  text-decoration: none;
}

.terms-checkbox a:hover {
  text-decoration: underline;
}

.terms-checkbox mat-error {
  margin-top: 4px;
  display: block;
}

.sign-up-button {
  width: 100%;
  padding: 10px 0;
  margin-bottom: 24px;
  position: relative;
  transition: all 0.3s ease;
}

.sign-up-button:disabled {
  background-color: rgba(75, 62, 33, 0.5);
}

.sign-up-button mat-spinner {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.sign-in-prompt {
  text-align: center;
  font-size: 14px;
  color: var(--text-secondary);
}

.sign-in-link {
  color: var(--secondary-color);
  margin-left: 4px;
  font-weight: 500;
  cursor: pointer;
  transition: color 0.2s;
}

.sign-in-link:hover {
  color: var(--tertiary-color);
  text-decoration: underline;
}

/* Dark theme support */
:host-context(.dark-theme) {
  .sign-up-card {
    background-color: #333;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
  }

  .sign-up-title {
    color: #e0e0e0;
  }

  .sign-up-subtitle {
    color: #aaa;
  }

  .terms-checkbox {
    color: #ccc;
  }
}

@media (max-width: 768px) {
  .sign-up-card {
    padding: 24px;
    width: 100%;
    max-width: 95%;
  }

  .name-fields {
    flex-direction: column;
    gap: 0;
  }
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Material form field customizations */
:host ::ng-deep {
  .mat-mdc-form-field-subscript-wrapper {
    height: 20px !important;
  }

  .mat-mdc-text-field-wrapper {
    background-color: #f7f7f7;
    transition: background-color 0.2s;
  }

  .mat-mdc-form-field.mat-focused .mat-mdc-text-field-wrapper {
    background-color: #fff;
  }

  .mat-mdc-form-field-icon-prefix > .mat-icon {
    color: var(--text-secondary);
  }

  .mat-mdc-form-field.mat-focused .mat-mdc-form-field-icon-prefix > .mat-icon {
    color: var(--primary-color);
  }

  .mat-mdc-checkbox .mdc-checkbox .mdc-checkbox__native-control:checked ~ .mdc-checkbox__background {
    background-color: var(--secondary-color) !important;
    border-color: var(--secondary-color) !important;
  }

  .mat-mdc-button.mat-primary {
    background-color: var(--primary-color);
  }

  /* Dark theme adjustments */
  :host-context(.dark-theme) & {
    .mat-mdc-text-field-wrapper {
      background-color: #444;
    }

    .mat-mdc-form-field.mat-focused .mat-mdc-text-field-wrapper {
      background-color: #555;
    }

    mat-label,
    input,
    .mat-mdc-form-field-icon-prefix > .mat-icon {
      color: #ddd !important;
    }

    .mat-mdc-checkbox .mdc-checkbox__native-control:enabled:not(:checked):not(:indeterminate):not([data-indeterminate='true']) ~ .mdc-checkbox__background {
      border-color: #aaa !important;
    }
  }
}


--- ./src/app/pages/auth/sign-up/sign-up.component.html ---
<div class="sign-up-container">
  <div class="sign-up-card">
    <div class="logo-container">
      <img src="assets/logo/logo.png" alt="Company Logo" class="logo" />
    </div>

    <h1 class="sign-up-title">Create Account</h1>
    <p class="sign-up-subtitle">Fill in your details to create a new account</p>

    <form [formGroup]="signUpForm" (ngSubmit)="onSubmit()" class="sign-up-form">
      <div class="name-fields">
        <mat-form-field appearance="outline" class="form-field">
          <mat-label>First Name</mat-label>
          <input
            matInput
            formControlName="firstName"
            placeholder="Enter your first name"
          />
          <mat-icon matPrefix>person</mat-icon>
          <mat-error *ngIf="signUpForm.get('firstName')?.hasError('required')">
            First name is required
          </mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" class="form-field">
          <mat-label>Last Name</mat-label>
          <input
            matInput
            formControlName="lastName"
            placeholder="Enter your last name"
          />
          <mat-icon matPrefix>person</mat-icon>
          <mat-error *ngIf="signUpForm.get('lastName')?.hasError('required')">
            Last name is required
          </mat-error>
        </mat-form-field>
      </div>

      <mat-form-field appearance="outline" class="form-field">
        <mat-label>Email</mat-label>
        <input
          matInput
          formControlName="email"
          type="email"
          placeholder="Enter your email"
        />
        <mat-icon matPrefix>email</mat-icon>
        <mat-error *ngIf="signUpForm.get('email')?.hasError('required')">
          Email is required
        </mat-error>
        <mat-error *ngIf="signUpForm.get('email')?.hasError('email')">
          Please enter a valid email address
        </mat-error>
      </mat-form-field>

      <mat-form-field appearance="outline" class="form-field">
        <mat-label>Password</mat-label>
        <input
          matInput
          formControlName="password"
          [type]="hidePassword ? 'password' : 'text'"
          placeholder="Create a password"
        />
        <mat-icon matPrefix>lock</mat-icon>
        <button
          mat-icon-button
          matSuffix
          type="button"
          (click)="hidePassword = !hidePassword"
        >
          <mat-icon>{{
            hidePassword ? "visibility_off" : "visibility"
          }}</mat-icon>
        </button>
        <mat-error *ngIf="signUpForm.get('password')?.hasError('required')">
          Password is required
        </mat-error>
        <mat-error *ngIf="signUpForm.get('password')?.hasError('minlength')">
          Password must be at least 6 characters
        </mat-error>
      </mat-form-field>

      <mat-form-field appearance="outline" class="form-field">
        <mat-label>Confirm Password</mat-label>
        <input
          matInput
          formControlName="confirmPassword"
          [type]="hideConfirmPassword ? 'password' : 'text'"
          placeholder="Confirm your password"
        />
        <mat-icon matPrefix>lock</mat-icon>
        <button
          mat-icon-button
          matSuffix
          type="button"
          (click)="hideConfirmPassword = !hideConfirmPassword"
        >
          <mat-icon>{{
            hideConfirmPassword ? "visibility_off" : "visibility"
          }}</mat-icon>
        </button>
        <mat-error
          *ngIf="signUpForm.get('confirmPassword')?.hasError('required')"
        >
          Please confirm your password
        </mat-error>
        <mat-error
          *ngIf="
            signUpForm.get('confirmPassword')?.hasError('passwordMismatch')
          "
        >
          Passwords do not match
        </mat-error>
      </mat-form-field>

      <div class="terms-checkbox">
        <mat-checkbox formControlName="acceptTerms" color="primary">
          I agree to the <a href="#" target="_blank">Terms of Service</a> and
          <a href="#" target="_blank">Privacy Policy</a>
        </mat-checkbox>
        <mat-error
          *ngIf="
            signUpForm.get('acceptTerms')?.hasError('required') &&
            signUpForm.get('acceptTerms')?.touched
          "
        >
          You must accept the terms and conditions
        </mat-error>
      </div>

      <button
        mat-flat-button
        color="primary"
        type="submit"
        class="sign-up-button"
        [disabled]="signUpForm.invalid || loading"
      >
        <mat-spinner diameter="20" *ngIf="loading"></mat-spinner>
        <span *ngIf="!loading">Create Account</span>
      </button>

      <div class="sign-in-prompt">
        <span>Already have an account?</span>
        <a (click)="navigateToSignIn()" class="sign-in-link">Sign In</a>
      </div>
    </form>
  </div>
</div>


--- ./src/app/pages/auth/forgot-password/forgot-password.component.ts ---
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Router } from '@angular/router';
import { MatSnackBar } from '@angular/material/snack-bar';
import { AuthService } from '../../../services/auth.service';

@Component({
  selector: 'app-forgot-password',
  templateUrl: './forgot-password.component.html',
  styleUrls: ['./forgot-password.component.scss'],
  standalone: false,
})
export class ForgotPasswordComponent implements OnInit {
  forgotPasswordForm: FormGroup;
  loading = false;
  emailSent = false;

  constructor(
    private fb: FormBuilder,
    private authService: AuthService,
    private router: Router,
    private snackBar: MatSnackBar
  ) {
    this.forgotPasswordForm = this.fb.group({
      email: ['', [Validators.required, Validators.email]],
    });
  }

  ngOnInit(): void {
    // Check if already logged in
    this.authService.user$.subscribe((user) => {
      if (user) {
        this.router.navigate(['/dashboard']);
      }
    });
  }

  onSubmit(): void {
    if (this.forgotPasswordForm.invalid) {
      return;
    }

    this.loading = true;
    const email = this.forgotPasswordForm.value.email;

    this.authService.resetPassword(email).subscribe({
      next: () => {
        this.loading = false;
        this.emailSent = true;
      },
      error: (error) => {
        this.loading = false;
        let errorMessage =
          'Failed to send password reset email. Please try again.';

        // Map Firebase error codes to user-friendly messages
        if (error.code === 'auth/user-not-found') {
          errorMessage = 'No account found with this email address.';
        } else if (error.code === 'auth/invalid-email') {
          errorMessage = 'Please provide a valid email address.';
        }

        this.snackBar.open(errorMessage, 'Dismiss', {
          duration: 5000,
          panelClass: ['error-snackbar'],
        });
      },
    });
  }

  navigateToSignIn(): void {
    this.router.navigate(['/auth/sign-in']);
  }
}


--- ./src/app/pages/auth/forgot-password/forgot-password.component.html ---
<div class="forgot-password-container">
  <div class="forgot-password-card">
    <div class="logo-container">
      <img src="assets/logo/logo.png" alt="Company Logo" class="logo" />
    </div>

    <h1 class="forgot-password-title">Reset Password</h1>

    <div *ngIf="!emailSent" class="reset-form-container">
      <p class="forgot-password-subtitle">
        Enter your email address and we'll send you a link to reset your
        password.
      </p>

      <form
        [formGroup]="forgotPasswordForm"
        (ngSubmit)="onSubmit()"
        class="forgot-password-form"
      >
        <mat-form-field appearance="outline" class="form-field">
          <mat-label>Email</mat-label>
          <input
            matInput
            formControlName="email"
            type="email"
            placeholder="Enter your email"
          />
          <mat-icon matPrefix>email</mat-icon>
          <mat-error
            *ngIf="forgotPasswordForm.get('email')?.hasError('required')"
          >
            Email is required
          </mat-error>
          <mat-error *ngIf="forgotPasswordForm.get('email')?.hasError('email')">
            Please enter a valid email address
          </mat-error>
        </mat-form-field>

        <button
          mat-flat-button
          color="primary"
          type="submit"
          class="reset-button"
          [disabled]="forgotPasswordForm.invalid || loading"
        >
          <mat-spinner diameter="20" *ngIf="loading"></mat-spinner>
          <span *ngIf="!loading">Send Reset Link</span>
        </button>
      </form>
    </div>

    <div *ngIf="emailSent" class="success-container">
      <div class="success-icon">
        <mat-icon>check_circle</mat-icon>
      </div>
      <h2 class="success-title">Check Your Email</h2>
      <p class="success-message">
        We've sent a password reset link to your email address. Please check
        your inbox and follow the instructions to reset your password.
      </p>
      <p class="email-note">
        If you don't see the email, check your spam folder or try again.
      </p>
      <button
        mat-flat-button
        color="primary"
        (click)="navigateToSignIn()"
        class="back-button"
      >
        Back to Sign In
      </button>
    </div>

    <div class="back-link" *ngIf="!emailSent">
      <a (click)="navigateToSignIn()">
        <mat-icon>arrow_back</mat-icon>
        Back to Sign In
      </a>
    </div>
  </div>
</div>


--- ./src/app/pages/auth/forgot-password/forgot-password.component.scss ---
/* forgot-password.component.scss */
.forgot-password-container {
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%;
}

.forgot-password-card {
  width: 450px;
  max-width: 90%;
  padding: 32px;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
  display: flex;
  flex-direction: column;
  align-items: center;

  /* Animation */
  animation: fadeInUp 0.4s ease-out;
}

.logo-container {
  margin-bottom: 24px;
  text-align: center;
}

.logo {
  max-width: 180px;
  height: auto;
}

.forgot-password-title {
  font-size: 28px;
  font-weight: 700;
  color: var(--primary-color);
  margin: 0 0 8px 0;
}

.forgot-password-subtitle {
  color: var(--text-secondary);
  margin-bottom: 32px;
  text-align: center;
}

.reset-form-container {
  width: 100%;
}

.forgot-password-form {
  width: 100%;
}

.form-field {
  width: 100%;
  margin-bottom: 20px;
}

.reset-button {
  width: 100%;
  padding: 10px 0;
  margin-bottom: 24px;
  position: relative;
  transition: all 0.3s ease;
}

.reset-button:disabled {
  background-color: rgba(75, 62, 33, 0.5);
}

.reset-button mat-spinner {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.success-container {
  text-align: center;
  padding: 24px 16px;
  width: 100%;
}

.success-icon {
  display: flex;
  justify-content: center;
  margin-bottom: 16px;
}

.success-icon mat-icon {
  font-size: 48px;
  width: 48px;
  height: 48px;
  color: #4caf50;
}

.success-title {
  font-size: 20px;
  font-weight: 600;
  margin-bottom: 16px;
  color: var(--primary-color);
}

.success-message {
  margin-bottom: 16px;
  color: var(--text-secondary);
}

.email-note {
  margin-bottom: 24px;
  font-size: 14px;
  color: var(--text-secondary);
  font-style: italic;
}

.back-button {
  min-width: 150px;
}

.back-link {
  margin-top: 24px;
  text-align: center;
}

.back-link a {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  color: var(--secondary-color);
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  transition: color 0.2s;
}

.back-link a:hover {
  color: var(--tertiary-color);
  text-decoration: underline;
}

/* Dark theme support */
:host-context(.dark-theme) {
  .forgot-password-card {
    background-color: #333;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
  }

  .forgot-password-title {
    color: #e0e0e0;
  }

  .forgot-password-subtitle,
  .success-message,
  .email-note {
    color: #aaa;
  }

  .success-title {
    color: #e0e0e0;
  }
}

@media (max-width: 768px) {
  .forgot-password-card {
    padding: 24px;
    width: 100%;
    max-width: 95%;
  }
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Material form field customizations */
:host ::ng-deep {
  .mat-mdc-form-field-subscript-wrapper {
    height: 20px !important;
  }

  .mat-mdc-text-field-wrapper {
    background-color: #f7f7f7;
    transition: background-color 0.2s;
  }

  .mat-mdc-form-field.mat-focused .mat-mdc-text-field-wrapper {
    background-color: #fff;
  }

  .mat-mdc-form-field-icon-prefix > .mat-icon,
  .mat-mdc-form-field-icon-suffix > .mat-icon {
    color: var(--text-secondary);
  }

  .mat-mdc-form-field.mat-focused .mat-mdc-form-field-icon-prefix > .mat-icon {
    color: var(--primary-color);
  }

  .mat-mdc-button.mat-primary {
    background-color: var(--primary-color);
  }

  /* Dark theme adjustments */
  :host-context(.dark-theme) & {
    .mat-mdc-text-field-wrapper {
      background-color: #444;
    }

    .mat-mdc-form-field.mat-focused .mat-mdc-text-field-wrapper {
      background-color: #555;
    }

    mat-label,
    input,
    .mat-mdc-form-field-icon-prefix > .mat-icon {
      color: #ddd !important;
    }
  }
}


--- ./src/app/pages/auth/auth-layout/auth-layout.component.html ---
<div class="auth-layout">
  <div class="auth-content">
    <!-- Router outlet for auth pages -->
    <router-outlet></router-outlet>
  </div>

  <div class="auth-background">
    <div class="background-overlay"></div>
  </div>

  <footer class="auth-footer">
    <p>© {{ currentYear }} Logistics Company. All rights reserved.</p>
  </footer>
</div>


--- ./src/app/pages/auth/auth-layout/auth-layout.component.scss ---
/* auth-layout.component.scss */
.auth-layout {
  min-height: 100vh;
  width: 100%;
  display: flex;
  flex-direction: column;
  position: relative;
  overflow: hidden;
  background-color: var(--background-color);
}

.auth-content {
  flex: 1;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1;
  padding: 24px;
  width: 100%;
}

.auth-background {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 0;
  background-image: url('/assets/images/auth-background.jpg');
  background-size: cover;
  background-position: center;
  filter: blur(2px);
}

.background-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, rgba(75, 62, 33, 0.7) 0%, rgba(158, 117, 32, 0.7) 100%);
}

.auth-footer {
  text-align: center;
  padding: 16px;
  color: #fff;
  background-color: rgba(0, 0, 0, 0.2);
  position: relative;
  z-index: 1;
}

/* Dark theme support */
:host-context(.dark-theme) {
  .auth-background {
    filter: brightness(0.6) blur(2px);
  }

  .background-overlay {
    background: linear-gradient(135deg, rgba(50, 40, 20, 0.8) 0%, rgba(100, 80, 20, 0.8) 100%);
  }
}

@media (max-width: 768px) {
  .auth-content {
    padding: 16px 8px;
    width: 100%;
  }
}


--- ./src/app/pages/auth/auth-layout/auth-layout.component.ts ---
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-auth-layout',
  templateUrl: './auth-layout.component.html',
  styleUrls: ['./auth-layout.component.scss'],
  standalone: false,
})
export class AuthLayoutComponent implements OnInit {
  currentYear: number = new Date().getFullYear();

  constructor() {}

  ngOnInit(): void {
    // Check if dark theme is enabled
    const storedPreferences = localStorage.getItem('userPreferences');
    if (storedPreferences) {
      const { isDarkTheme } = JSON.parse(storedPreferences);
      if (isDarkTheme) {
        document.body.classList.add('dark-theme');
      }
    }
  }
}


--- ./src/app/pages/auth/sign-in/sign-in.component.ts ---
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Router, ActivatedRoute } from '@angular/router';
import { MatSnackBar } from '@angular/material/snack-bar';
import { AuthService } from '../../../services/auth.service';
import { NotificationService } from '../../../services/notification.service';

@Component({
  selector: 'app-sign-in',
  templateUrl: './sign-in.component.html',
  styleUrls: ['./sign-in.component.scss'],
  standalone: false,
})
export class SignInComponent implements OnInit {
  signInForm: FormGroup;
  loading = false;
  hidePassword = true;
  returnUrl: string = '/dashboard';

  constructor(
    private fb: FormBuilder,
    private authService: AuthService,
    private router: Router,
    private route: ActivatedRoute,
    private snackBar: MatSnackBar,
    private notificationService: NotificationService
  ) {
    this.signInForm = this.fb.group({
      email: ['', [Validators.required, Validators.email]],
      password: ['', [Validators.required, Validators.minLength(6)]],
      rememberMe: [false],
    });
  }

  ngOnInit(): void {
    // Get return url from route parameters or default to '/dashboard'
    this.returnUrl =
      this.route.snapshot.queryParams['returnUrl'] || '/dashboard';

    // Check if already logged in
    this.authService.isAuthenticated().subscribe((isAuth) => {
      if (isAuth) {
        this.router.navigate([this.returnUrl]);
      }
    });

    // Check for stored email if remember me was previously checked
    const storedEmail = localStorage.getItem('rememberedEmail');
    if (storedEmail) {
      this.signInForm.patchValue({ email: storedEmail, rememberMe: true });
    }
  }

  onSubmit(): void {
    if (this.signInForm.invalid) {
      return;
    }

    this.loading = true;
    const { email, password, rememberMe } = this.signInForm.value;

    // Handle remember me functionality
    if (rememberMe) {
      localStorage.setItem('rememberedEmail', email);
    } else {
      localStorage.removeItem('rememberedEmail');
    }

    this.authService.signIn(email, password).subscribe({
      next: () => {
        this.loading = false;
        this.notificationService.addNotification({
          type: 'success',
          title: 'Welcome back',
          message: 'You have successfully signed in',
        });
        this.router.navigateByUrl(this.returnUrl);
      },
      error: (error) => {
        this.loading = false;
        let errorMessage = 'Sign in failed. Please check your credentials.';

        // Map Firebase error codes to user-friendly messages
        if (
          error.code === 'auth/user-not-found' ||
          error.code === 'auth/wrong-password'
        ) {
          errorMessage = 'Invalid email or password.';
        } else if (error.code === 'auth/user-disabled') {
          errorMessage = 'This account has been disabled.';
        } else if (error.code === 'auth/too-many-requests') {
          errorMessage = 'Too many failed attempts. Please try again later.';
        }

        this.snackBar.open(errorMessage, 'Dismiss', {
          duration: 5000,
          panelClass: ['error-snackbar'],
        });
      },
    });
  }

  navigateToForgotPassword(): void {
    this.router.navigate(['/auth/forgot-password']);
  }

  navigateToSignUp(): void {
    this.router.navigate(['/auth/sign-up']);
  }
}


--- ./src/app/pages/auth/sign-in/sign-in.component.scss ---
/* sign-in.component.scss */
.sign-in-container {
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%;
}

.sign-in-card {
  width: 450px;
  max-width: 90%;
  padding: 32px;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
  display: flex;
  flex-direction: column;
  align-items: center;

  /* Animation */
  animation: fadeInUp 0.4s ease-out;
}

.logo-container {
  margin-bottom: 24px;
  text-align: center;
}

.logo {
  max-width: 180px;
  height: auto;
}

.sign-in-title {
  font-size: 28px;
  font-weight: 700;
  color: var(--primary-color);
  margin: 0 0 8px 0;
}

.sign-in-subtitle {
  color: var(--text-secondary);
  margin-bottom: 32px;
  text-align: center;
}

.sign-in-form {
  width: 100%;
}

.form-field {
  width: 100%;
  margin-bottom: 20px;
}

.form-options {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
  flex-wrap: wrap;
}

.forgot-password {
  color: var(--secondary-color);
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  text-decoration: none;
  transition: color 0.2s;
}

.forgot-password:hover {
  color: var(--tertiary-color);
  text-decoration: underline;
}

.sign-in-button {
  width: 100%;
  padding: 10px 0;
  margin-bottom: 24px;
  position: relative;
  transition: all 0.3s ease;
}

.sign-in-button:disabled {
  background-color: rgba(75, 62, 33, 0.5);
}

.sign-in-button mat-spinner {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.sign-up-prompt {
  text-align: center;
  font-size: 14px;
  color: var(--text-secondary);
}

.sign-up-link {
  color: var(--secondary-color);
  margin-left: 4px;
  font-weight: 500;
  cursor: pointer;
  transition: color 0.2s;
}

.sign-up-link:hover {
  color: var(--tertiary-color);
  text-decoration: underline;
}

/* Dark theme support */
:host-context(.dark-theme) {
  .sign-in-card {
    background-color: #333;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
  }

  .sign-in-title {
    color: #e0e0e0;
  }

  .sign-in-subtitle {
    color: #aaa;
  }
}

@media (max-width: 768px) {
  .sign-in-card {
    padding: 24px;
    width: 100%;
    max-width: 95%;
  }
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Material form field customizations */
:host ::ng-deep {
  .mat-mdc-form-field-subscript-wrapper {
    height: 20px !important;
  }

  .mat-mdc-text-field-wrapper {
    background-color: #f7f7f7;
    transition: background-color 0.2s;
  }

  .mat-mdc-form-field.mat-focused .mat-mdc-text-field-wrapper {
    background-color: #fff;
  }

  .mat-mdc-form-field-icon-prefix > .mat-icon {
    color: var(--text-secondary);
  }

  .mat-mdc-form-field.mat-focused .mat-mdc-form-field-icon-prefix > .mat-icon {
    color: var(--primary-color);
  }

  .mat-mdc-checkbox .mdc-checkbox .mdc-checkbox__native-control:checked ~ .mdc-checkbox__background {
    background-color: var(--secondary-color) !important;
    border-color: var(--secondary-color) !important;
  }

  .mat-mdc-button.mat-primary {
    background-color: var(--primary-color);
  }

  /* Dark theme adjustments */
  :host-context(.dark-theme) & {
    .mat-mdc-text-field-wrapper {
      background-color: #444;
    }

    .mat-mdc-form-field.mat-focused .mat-mdc-text-field-wrapper {
      background-color: #555;
    }

    mat-label,
    input,
    .mat-mdc-form-field-icon-prefix > .mat-icon {
      color: #ddd !important;
    }
  }
}


--- ./src/app/pages/auth/sign-in/sign-in.component.html ---
<div class="sign-in-container">
  <div class="sign-in-card">
    <div class="logo-container">
      <img src="assets/logo/logo.png" alt="Company Logo" class="logo" />
    </div>

    <h1 class="sign-in-title">Sign In</h1>
    <p class="sign-in-subtitle">Welcome back! Please sign in to continue.</p>

    <form [formGroup]="signInForm" (ngSubmit)="onSubmit()" class="sign-in-form">
      <mat-form-field appearance="outline" class="form-field">
        <mat-label>Email</mat-label>
        <input
          matInput
          formControlName="email"
          type="email"
          placeholder="Enter your email"
        />
        <mat-icon matPrefix>email</mat-icon>
        <mat-error *ngIf="signInForm.get('email')?.hasError('required')">
          Email is required
        </mat-error>
        <mat-error *ngIf="signInForm.get('email')?.hasError('email')">
          Please enter a valid email address
        </mat-error>
      </mat-form-field>

      <mat-form-field appearance="outline" class="form-field">
        <mat-label>Password</mat-label>
        <input
          matInput
          formControlName="password"
          [type]="hidePassword ? 'password' : 'text'"
          placeholder="Enter your password"
        />
        <mat-icon matPrefix>lock</mat-icon>
        <button
          mat-icon-button
          matSuffix
          type="button"
          (click)="hidePassword = !hidePassword"
        >
          <mat-icon>{{
            hidePassword ? "visibility_off" : "visibility"
          }}</mat-icon>
        </button>
        <mat-error *ngIf="signInForm.get('password')?.hasError('required')">
          Password is required
        </mat-error>
        <mat-error *ngIf="signInForm.get('password')?.hasError('minlength')">
          Password must be at least 6 characters
        </mat-error>
      </mat-form-field>

      <div class="form-options">
        <mat-checkbox formControlName="rememberMe" color="primary"
          >Remember me</mat-checkbox
        >
        <a (click)="navigateToForgotPassword()" class="forgot-password"
          >Forgot password?</a
        >
      </div>

      <button
        mat-flat-button
        color="primary"
        type="submit"
        class="sign-in-button"
        [disabled]="signInForm.invalid || loading"
      >
        <mat-spinner diameter="20" *ngIf="loading"></mat-spinner>
        <span *ngIf="!loading">Sign In</span>
      </button>

      <div class="sign-up-prompt">
        <span>Don't have an account?</span>
        <a (click)="navigateToSignUp()" class="sign-up-link">Sign Up</a>
      </div>
    </form>
  </div>
</div>


--- ./src/app/pages/expenses/expense-create/expense-create.component.html ---
<mat-card class="expense-create-card">
  <div class="card-header">
    <h1>Create Invoice</h1>
    <p class="subtitle" *ngIf="!isLoading">Fill in the details below to create a new invoice</p>
  </div>

  <mat-spinner *ngIf="isLoading" diameter="40" class="loading-spinner"></mat-spinner>

  <div *ngIf="errorMessage" class="error-container">
    <mat-icon>error_outline</mat-icon>
    <span>{{ errorMessage }}</span>
  </div>

  <form [formGroup]="expenseForm" (ngSubmit)="onSubmit()" *ngIf="!isLoading">
    <!-- Job Selection -->
    <div class="form-section">
      <h2>Job Details</h2>

      <mat-form-field appearance="outline" class="full-width">
        <mat-label>Select Job</mat-label>
        <mat-select formControlName="jobId">
          <mat-option *ngFor="let job of availableJobs" [value]="job.id"> {{ job.make }} {{ job.model }} ({{ job.registration }}) - {{ job.status }} </mat-option>
        </mat-select>
        <mat-error *ngIf="expenseForm.get('jobId')?.hasError('required')"> Please select a job </mat-error>
      </mat-form-field>

      <!-- Job Details Card -->
      <div class="job-details-card" *ngIf="job && !jobLoading">
        <div class="job-header">
          <h3>Selected Job Information</h3>
          <span class="status-chip" [ngClass]="'status-' + job.status">
            {{ job.status }}
          </span>
        </div>

        <div class="job-details-grid">
          <div class="job-detail-item">
            <span class="label">Vehicle:</span>
            <span class="value">{{ job.make }} {{ job.model }}</span>
          </div>
          <div class="job-detail-item">
            <span class="label">Registration:</span>
            <span class="value">{{ job.registration }}</span>
          </div>
          <div class="job-detail-item" *ngIf="job.collectionAddress">
            <span class="label">Collection:</span>
            <span class="value">{{ job.collectionAddress }}</span>
          </div>
          <div class="job-detail-item" *ngIf="job.deliveryAddress">
            <span class="label">Delivery:</span>
            <span class="value">{{ job.deliveryAddress }}</span>
          </div>
          <div class="job-detail-item" *ngIf="customer">
            <span class="label">Customer:</span>
            <span class="value">{{ customer.name }}</span>
          </div>
        </div>
      </div>

      <div class="loading-container" *ngIf="jobLoading">
        <mat-spinner diameter="30"></mat-spinner>
        <span>Loading job details...</span>
      </div>
    </div>

    <!-- Invoice Details -->
    <div class="form-section">
      <h2>Invoice Details</h2>

      <mat-form-field appearance="outline" class="full-width">
        <mat-label>Description</mat-label>
        <input matInput formControlName="description" placeholder="e.g. Vehicle Transport Service" />
        <mat-error *ngIf="expenseForm.get('description')?.hasError('required')"> Description is required </mat-error>
      </mat-form-field>

      <div class="form-row">
        <mat-form-field appearance="outline">
          <mat-label>Amount (£)</mat-label>
          <input matInput type="number" formControlName="amount" min="0.01" step="0.01" />
          <span matPrefix>£&nbsp;</span>
          <mat-error *ngIf="expenseForm.get('amount')?.hasError('required')"> Amount is required </mat-error>
          <mat-error *ngIf="expenseForm.get('amount')?.hasError('min')"> Amount must be greater than 0 </mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline">
          <mat-label>Date</mat-label>
          <input matInput [matDatepicker]="picker" formControlName="date" />
          <mat-datepicker-toggle matSuffix [for]="picker"></mat-datepicker-toggle>
          <mat-datepicker #picker></mat-datepicker>
          <mat-error *ngIf="expenseForm.get('date')?.hasError('required')"> Date is required </mat-error>
        </mat-form-field>
      </div>

      <div class="form-row checkbox-row">
        <mat-checkbox formControlName="isChargeable" color="primary"> Chargeable to customer </mat-checkbox>
      </div>

      <mat-form-field appearance="outline" class="full-width">
        <mat-label>Notes (Optional)</mat-label>
        <textarea matInput formControlName="notes" rows="3" placeholder="Add any additional information here"></textarea>
      </mat-form-field>
    </div>

    <!-- Receipt Upload -->
    <div class="form-section">
      <h2>Attach Receipt (Optional)</h2>

      <div class="file-upload-container">
        <button type="button" mat-stroked-button (click)="fileInput.click()">
          <mat-icon>cloud_upload</mat-icon>
          Upload Receipt
        </button>
        <input hidden type="file" #fileInput (change)="uploadReceipt($event)" accept=".jpg,.jpeg,.png,.pdf" />

        <span class="file-name" *ngIf="expenseForm.get('receiptUrl')?.value">
          Receipt uploaded
          <mat-icon class="success-icon">check_circle</mat-icon>
        </span>
      </div>

      <div class="receipt-preview" *ngIf="expenseForm.get('receiptUrl')?.value">
        <img [src]="expenseForm.get('receiptUrl')?.value" alt="Receipt preview" />
      </div>
    </div>

    <!-- Form Actions -->
    <div class="form-actions">
      <button type="button" mat-stroked-button (click)="cancelCreate()">Cancel</button>
      <button type="submit" mat-flat-button color="primary" [disabled]="expenseForm.invalid || isSubmitting">
        <mat-spinner diameter="20" *ngIf="isSubmitting"></mat-spinner>
        <span *ngIf="!isSubmitting">Create Invoice</span>
      </button>
    </div>
  </form>
</mat-card>


--- ./src/app/pages/expenses/expense-create/expense-create.component.ts ---
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { MatSnackBar } from '@angular/material/snack-bar';
import { ActivatedRoute, Router } from '@angular/router';
import { Observable, combineLatest, forkJoin, of } from 'rxjs';
import { catchError, finalize, map, switchMap, tap } from 'rxjs/operators';

import { Customer } from '../../../interfaces/customer.interface';
import { Job } from '../../../interfaces/job.interface';
import { CustomerService } from '../../../services/customer.service';
import { ExpenseService } from '../../../services/expense.service';
import { JobService } from '../../../services/job.service';
import { AuthService } from '../../../services/auth.service';
import { Expense, ExpenseStatus } from '../../../shared/models/expense.model';

@Component({
  selector: 'app-expense-create',
  templateUrl: './expense-create.component.html',
  styleUrls: ['./expense-create.component.scss'],
  standalone: false,
})
export class ExpenseCreateComponent implements OnInit {
  expenseForm: FormGroup;
  isSubmitting = false;
  isLoading = true;
  jobId: string | null = null;
  job: Job | null = null;
  customer: Customer | null = null;
  errorMessage: string | null = null;
  jobLoading = false;
  availableJobs: Job[] = [];

  currentUserId: string | null = null;
  currentUserName: string = '';

  constructor(
    private fb: FormBuilder,
    private expenseService: ExpenseService,
    private jobService: JobService,
    private customerService: CustomerService,
    private authService: AuthService,
    private router: Router,
    private route: ActivatedRoute,
    private snackBar: MatSnackBar
  ) {
    this.expenseForm = this.fb.group({
      jobId: [''],
      description: ['', Validators.required],
      amount: ['', [Validators.required, Validators.min(0.01)]],
      date: [new Date(), Validators.required],
      notes: [''],
      isChargeable: [true],
      receiptUrl: [''],
    });
  }

  ngOnInit(): void {
    // Get current user info
    this.authService.getUserProfile().subscribe((profile) => {
      if (profile) {
        this.currentUserId = profile.id;
        this.currentUserName = profile.name;
      }
    });

    // Check if jobId was passed via route parameter
    this.route.paramMap.subscribe((params) => {
      this.jobId = params.get('jobId');

      if (this.jobId) {
        this.expenseForm.patchValue({ jobId: this.jobId });
        this.loadJobDetails(this.jobId);
      } else {
        this.loadAvailableJobs();
        this.isLoading = false;
      }
    });

    // Watch for jobId changes in the form
    this.expenseForm.get('jobId')?.valueChanges.subscribe((jobId) => {
      if (jobId && jobId !== this.jobId) {
        this.loadJobDetails(jobId);
      }
    });
  }

  loadJobDetails(jobId: string): void {
    this.jobLoading = true;
    this.errorMessage = null;

    this.jobService
      .getJobById(jobId)
      .pipe(
        tap((job) => {
          this.job = job;
          if (job && job.customerId) {
            // If job has a customer ID, load the customer details
            return this.customerService.getCustomerById(job.customerId);
          }
          return of(null);
        }),
        switchMap((customerObs) => {
          if (customerObs instanceof Observable) {
            return customerObs;
          }
          return of(null);
        }),
        finalize(() => {
          this.jobLoading = false;
          this.isLoading = false;
        })
      )
      .subscribe({
        next: (customer: Customer | null) => {
          this.customer = customer;

          // Pre-populate form with job details
          if (this.job) {
            const description = `Invoice for ${this.job.make || ''} ${this.job.model || ''} ${this.job.registration ? '(' + this.job.registration + ')' : ''}`;
            this.expenseForm.patchValue({
              description: description,
            });
          }
        },
        error: (error) => {
          this.errorMessage = 'Failed to load job details. Please try again.';
          console.error('Error loading job details:', error);
        },
      });
  }

  loadAvailableJobs(): void {
    this.isLoading = true;
    this.jobService
      .getDriverJobs()
      .pipe(
        // Filter to only include completed and delivered jobs
        map((jobs) => jobs.filter((job) => job.status === 'completed' || job.status === 'delivered')),
        finalize(() => {
          this.isLoading = false;
        })
      )
      .subscribe({
        next: (jobs) => {
          this.availableJobs = jobs;
        },
        error: (error) => {
          console.error('Error loading available jobs:', error);
          this.showErrorMessage('Failed to load available jobs. Please try again.');
        },
      });
  }

  onSubmit(): void {
    if (this.expenseForm.invalid) {
      return;
    }

    this.isSubmitting = true;
    const formValue = this.expenseForm.value;

    // Create expense object
    const expense: Omit<Expense, 'id' | 'status'> = {
      jobId: formValue.jobId || undefined,
      driverId: this.currentUserId || '',
      driverName: this.currentUserName,
      description: formValue.description,
      amount: parseFloat(formValue.amount),
      date: formValue.date,
      receiptUrl: formValue.receiptUrl || undefined,
      isChargeable: formValue.isChargeable,
      notes: formValue.notes || undefined,
    };

    this.expenseService
      .createExpense(expense)
      .pipe(
        finalize(() => {
          this.isSubmitting = false;
        })
      )
      .subscribe({
        next: (createdExpense) => {
          this.showSuccessMessage('Invoice created successfully');
          this.router.navigate(['/expenses']);
        },
        error: (error) => {
          console.error('Error creating expense:', error);
          this.showErrorMessage('Failed to create invoice. Please try again.');
        },
      });
  }

  uploadReceipt(event: Event): void {
    const input = event.target as HTMLInputElement;
    if (input.files && input.files.length) {
      const file = input.files[0];
      // Here you would typically upload the file to storage
      // For demo purposes, we'll just store a placeholder URL
      this.expenseForm.patchValue({
        receiptUrl: 'assets/images/receipt-placeholder.jpg',
      });
    }
  }

  cancelCreate(): void {
    this.router.navigate(['/expenses']);
  }

  private showSuccessMessage(message: string): void {
    this.snackBar.open(message, 'Close', {
      duration: 3000,
      horizontalPosition: 'end',
      verticalPosition: 'top',
      panelClass: ['success-snackbar'],
    });
  }

  private showErrorMessage(message: string): void {
    this.snackBar.open(message, 'Close', {
      duration: 5000,
      horizontalPosition: 'end',
      verticalPosition: 'top',
      panelClass: ['error-snackbar'],
    });
  }
}


--- ./src/app/pages/expenses/expense-create/expense-create.component.scss ---
.expense-create-card {
  max-width: 900px;
  margin: 24px auto;
  padding: 24px;
}

/* Account for sidebar and topbar */
@media (min-width: 1200px) {
  .expense-create-card {
    margin-top: 88px; /* 64px topbar + 24px margin */
    margin-bottom: 24px;
    margin-left: auto;
    margin-right: auto;
    /* Account for the sidebar by setting the card with the right offset */
    position: relative;
    left: 125px; /* Half the sidebar width to keep it centered in the remaining space */
  }
}

@media (min-width: 768px) and (max-width: 1199px) {
  .expense-create-card {
    margin-top: 88px; /* 64px topbar + 24px margin */
    margin-bottom: 24px;
    margin-left: auto;
    margin-right: auto;
    /* Account for collapsed sidebar */
    position: relative;
    left: 30px; /* Half the collapsed sidebar width */
  }
}

@media (max-width: 767px) {
  .expense-create-card {
    margin: 80px 16px 16px; /* Top includes topbar height */
    padding: 16px;
    max-width: unset;
  }
}

.card-header {
  margin-bottom: 24px;

  h1 {
    margin-bottom: 8px;
  }

  .subtitle {
    color: var(--text-secondary);
    margin: 0;
  }
}

.loading-spinner {
  margin: 48px auto;
}

.error-container {
  display: flex;
  align-items: center;
  background-color: rgba(244, 67, 54, 0.1);
  color: #f44336;
  padding: 16px;
  border-radius: 4px;
  margin-bottom: 24px;

  mat-icon {
    margin-right: 12px;
  }
}

.form-section {
  margin-bottom: 32px;

  h2 {
    font-size: 18px;
    margin-bottom: 16px;
    color: var(--primary-color);
    font-weight: 500;
  }
}

.form-row {
  display: flex;
  gap: 16px;

  mat-form-field {
    flex: 1;
  }
}

.checkbox-row {
  padding: 8px 0 16px;
}

.full-width {
  width: 100%;
}

.job-details-card {
  background-color: rgba(0, 0, 0, 0.02);
  border-radius: 4px;
  padding: 16px;
  margin-top: 16px;
  border: 1px solid rgba(0, 0, 0, 0.08);

  .job-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;

    h3 {
      margin: 0;
      font-size: 16px;
      font-weight: 500;
    }

    .status-chip {
      padding: 4px 12px;
      border-radius: 16px;
      font-size: 12px;
      font-weight: 500;
      text-transform: uppercase;
    }
  }

  .job-details-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 12px;

    .job-detail-item {
      display: flex;
      flex-direction: column;

      .label {
        font-size: 12px;
        color: var(--text-secondary);
        margin-bottom: 4px;
      }

      .value {
        font-size: 14px;
        font-weight: 500;
      }
    }
  }
}

.loading-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 24px 0;

  span {
    margin-top: 12px;
    font-size: 14px;
    color: var(--text-secondary);
  }
}

.file-upload-container {
  display: flex;
  align-items: center;
  gap: 16px;
  margin-bottom: 16px;

  .file-name {
    display: flex;
    align-items: center;
    color: var(--text-secondary);

    .success-icon {
      color: #4caf50;
      margin-left: 8px;
    }
  }
}

.receipt-preview {
  max-width: 300px;
  margin-top: 16px;
  border: 1px solid rgba(0, 0, 0, 0.12);
  border-radius: 4px;
  overflow: hidden;

  img {
    width: 100%;
    height: auto;
    display: block;
  }
}

.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: 16px;
  margin-top: 24px;

  button {
    min-width: 120px;
  }
}

// Status colors
.status-collected {
  background-color: rgba(33, 150, 243, 0.12);
  color: #2196f3;
}

.status-delivered,
.status-completed {
  background-color: rgba(76, 175, 80, 0.12);
  color: #4caf50;
}

/* Responsive styles */
@media (max-width: 768px) {
  .form-row {
    flex-direction: column;
    gap: 0;
  }

  .job-details-grid {
    grid-template-columns: 1fr;
  }
}


--- ./src/app/pages/expenses/expense-list/expense-list.component.html ---
<mat-card class="expenses-card">
  <!-- Header -->
  <div class="header-wrapper">
    <div class="header-title">
      <h1>Invoices</h1>
      <p class="subtitle">{{ filteredExpenses.length }} total invoices</p>
    </div>
  </div>

  <!-- Filters and Actions Bar -->
  <div class="filters-actions-wrapper">
    <div class="filters-section">
      <mat-form-field appearance="outline" class="search-field">
        <mat-label>Search invoices</mat-label>
        <input matInput (keyup)="applyFilter($event)" placeholder="Search by description, job or driver" />
        <mat-icon matSuffix>search</mat-icon>
      </mat-form-field>

      <div class="filters-group">
        <mat-form-field appearance="outline">
          <mat-label>Status</mat-label>
          <mat-select [(value)]="filters.status" (selectionChange)="applyFilters()">
            <mat-option value="All">All</mat-option>
            <mat-option *ngFor="let status of statusOptions" [value]="status">
              {{ status }}
            </mat-option>
          </mat-select>
        </mat-form-field>

        <mat-form-field appearance="outline">
          <mat-label>Driver</mat-label>
          <mat-select [(value)]="filters.driver" (selectionChange)="applyFilters()">
            <mat-option value="All">All</mat-option>
            <mat-option *ngFor="let driver of drivers" [value]="driver.id">
              {{ driver.name }}
            </mat-option>
          </mat-select>
        </mat-form-field>

        <mat-form-field appearance="outline">
          <mat-label>Chargeable</mat-label>
          <mat-select [(value)]="filters.chargeable" (selectionChange)="applyFilters()">
            <mat-option value="All">All</mat-option>
            <mat-option [value]="true">Chargeable</mat-option>
            <mat-option [value]="false">Non-Chargeable</mat-option>
          </mat-select>
        </mat-form-field>

        <mat-form-field appearance="outline">
          <mat-label>Payment Status</mat-label>
          <mat-select [(value)]="filters.paidStatus" (selectionChange)="applyFilters()">
            <mat-option value="All">All</mat-option>
            <mat-option value="Paid">Paid</mat-option>
            <mat-option value="Unpaid">Unpaid</mat-option>
          </mat-select>
        </mat-form-field>

        <div class="date-range-group">
          <mat-form-field appearance="outline">
            <mat-label>Start Date</mat-label>
            <input matInput [matDatepicker]="startPicker" [(ngModel)]="filters.dateRange.start" (dateChange)="applyFilters()" />
            <mat-datepicker-toggle matSuffix [for]="startPicker"></mat-datepicker-toggle>
            <mat-datepicker #startPicker></mat-datepicker>
          </mat-form-field>

          <mat-form-field appearance="outline">
            <mat-label>End Date</mat-label>
            <input matInput [matDatepicker]="endPicker" [(ngModel)]="filters.dateRange.end" (dateChange)="applyFilters()" />
            <mat-datepicker-toggle matSuffix [for]="endPicker"></mat-datepicker-toggle>
            <mat-datepicker #endPicker></mat-datepicker>
          </mat-form-field>
        </div>
      </div>
    </div>

    <div class="actions-group">
      <!-- Bulk Approval Button (only visible to managers) -->
      <button
        *ngIf="isManager && getBulkApprovalCount() > 0"
        mat-stroked-button
        color="primary"
        (click)="bulkApproveExpenses()"
        matTooltip="Approve all pending invoices"
        class="bulk-approve-button">
        <mat-icon>done_all</mat-icon>
        Approve {{ getBulkApprovalCount() }} Invoices
      </button>

      <button mat-flat-button color="primary" (click)="createNewExpense()" class="create-button">
        <mat-icon>add</mat-icon>
        New Invoice
      </button>
    </div>
  </div>

  <!-- Table Container -->
  <div class="table-container">
    <!-- Loading Overlay -->
    <div class="loading-overlay" *ngIf="isLoading">
      <mat-spinner diameter="40"></mat-spinner>
      <span>Loading invoices...</span>
    </div>

    <!-- Table -->
    <table mat-table [dataSource]="dataSource" matSort [class.loading]="isLoading">
      <!-- ID Column -->
      <ng-container matColumnDef="id">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>ID</th>
        <td mat-cell *matCellDef="let expense">{{ expense.id }}</td>
      </ng-container>

      <!-- Description Column -->
      <ng-container matColumnDef="description">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Description</th>
        <td mat-cell *matCellDef="let expense">{{ expense.description }}</td>
      </ng-container>

      <!-- Amount Column -->
      <ng-container matColumnDef="amount">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Amount</th>
        <td mat-cell *matCellDef="let expense">
          {{ formatCurrency(expense.amount) }}
        </td>
      </ng-container>

      <!-- Date Column -->
      <ng-container matColumnDef="date">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Date</th>
        <td mat-cell *matCellDef="let expense">{{ expense.date | date }}</td>
      </ng-container>

      <!-- Job ID Column -->
      <ng-container matColumnDef="jobId">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Job</th>
        <td mat-cell *matCellDef="let expense">
          <a *ngIf="expense.jobId" [routerLink]="['/jobs', expense.jobId]" (click)="$event.stopPropagation()">
            {{ expense.jobId }}
          </a>
          <span *ngIf="!expense.jobId">N/A</span>
        </td>
      </ng-container>

      <!-- Driver Column -->
      <ng-container matColumnDef="driver">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Driver</th>
        <td mat-cell *matCellDef="let expense">{{ expense.driverName }}</td>
      </ng-container>

      <!-- Status Column -->
      <ng-container matColumnDef="status">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Status</th>
        <td mat-cell *matCellDef="let expense">
          <span class="status-chip" [ngClass]="getStatusClass(expense.status)">
            {{ expense.status }}
          </span>
        </td>
      </ng-container>

      <!-- Paid Status Column -->
      <ng-container matColumnDef="paidStatus">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Payment</th>
        <td mat-cell *matCellDef="let expense">
          <div class="payment-status-container">
            <span class="status-chip" [ngClass]="getPaidStatusClass(expense.isPaid)">
              {{ getPaidStatusText(expense.isPaid) }}
            </span>
            <button
              *ngIf="isManager && expense.status === 'Approved'"
              mat-icon-button
              [matMenuTriggerFor]="paidMenu"
              (click)="$event.stopPropagation()"
              class="payment-menu-button">
              <mat-icon>more_vert</mat-icon>
            </button>
            <mat-menu #paidMenu="matMenu">
              <button mat-menu-item (click)="updatePaidStatus(expense, true)" [disabled]="expense.isPaid">
                <mat-icon>payment</mat-icon>
                <span>Mark as Paid</span>
              </button>
              <button mat-menu-item (click)="updatePaidStatus(expense, false)" [disabled]="!expense.isPaid">
                <mat-icon>money_off</mat-icon>
                <span>Mark as Unpaid</span>
              </button>
              <button mat-menu-item (click)="printInvoice(expense)">
                <mat-icon>print</mat-icon>
                <span>Print Invoice</span>
              </button>
            </mat-menu>
          </div>
        </td>
      </ng-container>

      <!-- Chargeable Column -->
      <ng-container matColumnDef="chargeable">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Chargeable</th>
        <td mat-cell *matCellDef="let expense">
          <mat-checkbox
            [checked]="expense.isChargeable"
            [disabled]="expense.status !== 'Approved' || !isManager"
            (change)="updateChargeable(expense, $event)"
            (click)="$event.stopPropagation()"></mat-checkbox>
        </td>
      </ng-container>

      <!-- Actions Column -->
      <ng-container matColumnDef="actions">
        <th mat-header-cell *matHeaderCellDef></th>
        <td mat-cell *matCellDef="let expense">
          <div class="action-buttons">
            <button
              mat-icon-button
              *ngIf="expense.status === 'Pending' && isManager"
              color="primary"
              matTooltip="Approve"
              (click)="approveExpense(expense); $event.stopPropagation()">
              <mat-icon>check_circle</mat-icon>
            </button>
            <button
              mat-icon-button
              *ngIf="expense.status === 'Pending' && isManager"
              color="warn"
              matTooltip="Reject"
              (click)="rejectExpense(expense); $event.stopPropagation()">
              <mat-icon>cancel</mat-icon>
            </button>
            <button
              mat-icon-button
              *ngIf="expense.status === 'Approved'"
              color="accent"
              matTooltip="Print Invoice"
              (click)="printInvoice(expense); $event.stopPropagation()">
              <mat-icon>print</mat-icon>
            </button>
            <button mat-icon-button matTooltip="View Details" (click)="viewExpenseDetails(expense); $event.stopPropagation()">
              <mat-icon>visibility</mat-icon>
            </button>
          </div>
        </td>
      </ng-container>

      <!-- Header and Data Rows -->
      <tr mat-header-row *matHeaderRowDef="displayedColumns; sticky: true"></tr>
      <tr mat-row *matRowDef="let row; columns: displayedColumns" (click)="viewExpenseDetails(row)" class="expense-row"></tr>
    </table>

    <!-- Empty State -->
    <div class="empty-state" *ngIf="!isLoading && filteredExpenses.length === 0">
      <mat-icon class="empty-icon">receipt_long</mat-icon>
      <h3>No invoices found</h3>
      <p>Try adjusting your filters or create a new invoice</p>
      <button mat-flat-button color="primary" (click)="createNewExpense()">
        <mat-icon>add</mat-icon>
        New Invoice
      </button>
    </div>
  </div>

  <!-- Paginator -->
  <mat-paginator [length]="filteredExpenses.length" [pageSize]="25" [pageSizeOptions]="[10, 25, 50, 100]" showFirstLastButtons> </mat-paginator>
</mat-card>

<!-- Expense Detail Dialog -->
<ng-template #expenseDetailDialog>
  <div class="expense-detail-dialog">
    <h2 mat-dialog-title>Invoice Details</h2>
    <mat-dialog-content *ngIf="selectedExpense">
      <div class="expense-info-grid">
        <div class="expense-info-item">
          <span class="label">ID</span>
          <span class="value">{{ selectedExpense.id }}</span>
        </div>
        <div class="expense-info-item">
          <span class="label">Description</span>
          <span class="value">{{ selectedExpense.description }}</span>
        </div>
        <div class="expense-info-item">
          <span class="label">Amount</span>
          <span class="value">{{ formatCurrency(selectedExpense.amount) }}</span>
        </div>
        <div class="expense-info-item">
          <span class="label">Date</span>
          <span class="value">{{ selectedExpense.date | date : 'medium' }}</span>
        </div>
        <div class="expense-info-item">
          <span class="label">Driver</span>
          <span class="value">{{ selectedExpense.driverName }}</span>
        </div>
        <div class="expense-info-item">
          <span class="label">Job</span>
          <span class="value">
            <a *ngIf="selectedExpense.jobId" [routerLink]="['/jobs', selectedExpense.jobId]" (click)="closeDialog()">
              {{ selectedExpense.jobId }}
            </a>
            <span *ngIf="!selectedExpense.jobId">N/A</span>
          </span>
        </div>
        <div class="expense-info-item">
          <span class="label">Status</span>
          <span class="value status-chip" [ngClass]="getStatusClass(selectedExpense.status)">
            {{ selectedExpense.status }}
          </span>
        </div>
        <div class="expense-info-item">
          <span class="label">Payment Status</span>
          <span class="value status-chip" [ngClass]="getPaidStatusClass(selectedExpense.isPaid)">
            {{ getPaidStatusText(selectedExpense.isPaid) }}
          </span>
        </div>
        <div class="expense-info-item">
          <span class="label">Chargeable</span>
          <span class="value">{{ selectedExpense.isChargeable ? 'Yes' : 'No' }}</span>
        </div>
        <div class="expense-info-item" *ngIf="selectedExpense.paidDate">
          <span class="label">Payment Date</span>
          <span class="value">{{ selectedExpense.paidDate | date : 'medium' }}</span>
        </div>
        <div class="expense-info-item full-width" *ngIf="selectedExpense.notes">
          <span class="label">Notes</span>
          <div class="value notes-content">{{ selectedExpense.notes }}</div>
        </div>
        <div class="expense-info-item full-width" *ngIf="selectedExpense.receiptUrl">
          <span class="label">Receipt</span>
          <div class="receipt-image">
            <img [src]="selectedExpense.receiptUrl" alt="Receipt" />
          </div>
        </div>
        <div class="expense-info-item full-width" *ngIf="selectedExpense.approvedBy">
          <span class="label">Approved By</span>
          <span class="value">{{ selectedExpense.approvedBy }} on {{ selectedExpense.approvedDate | date : 'medium' }}</span>
        </div>
      </div>
    </mat-dialog-content>
    <mat-dialog-actions align="end">
      <button mat-button mat-dialog-close>Close</button>
      <button mat-raised-button color="primary" *ngIf="selectedExpense?.status === 'Pending' && isManager" (click)="approveExpense(selectedExpense!)">Approve</button>
      <button mat-raised-button color="warn" *ngIf="selectedExpense?.status === 'Pending' && isManager" (click)="rejectExpense(selectedExpense!)">Reject</button>
      <button mat-raised-button color="accent" *ngIf="selectedExpense?.status === 'Approved'" (click)="printInvoice(selectedExpense!); closeDialog()">
        Print Invoice
      </button>
    </mat-dialog-actions>
  </div>
</ng-template>

<!-- Rejection Dialog -->
<ng-template #rejectDialog>
  <div class="rejection-dialog">
    <h2 mat-dialog-title>Reject Invoice</h2>
    <mat-dialog-content>
      <form [formGroup]="rejectionForm">
        <p>Please provide a reason for rejecting this invoice:</p>
        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Rejection Reason</mat-label>
          <textarea matInput formControlName="reason" rows="3" placeholder="Enter reason for rejection"></textarea>
          <mat-error *ngIf="rejectionForm.get('reason')?.hasError('required')"> A reason is required for rejecting the invoice </mat-error>
        </mat-form-field>
      </form>
    </mat-dialog-content>
    <mat-dialog-actions align="end">
      <button mat-button mat-dialog-close>Cancel</button>
      <button mat-raised-button color="warn" [disabled]="rejectionForm.invalid" (click)="confirmReject()">Reject Invoice</button>
    </mat-dialog-actions>
  </div>
</ng-template>

<!-- Print Invoice Dialog -->
<ng-template #printInvoiceDialog>
  <div class="print-invoice-dialog">
    <h2 mat-dialog-title>Print Invoice</h2>
    <mat-dialog-content>
      <div class="print-preview-container">
        <div *ngIf="isPrintingInvoice" class="print-loading">
          <mat-spinner diameter="30"></mat-spinner>
          <p>Preparing invoice for printing...</p>
        </div>

        <div id="printableInvoice" class="invoice-container">
          <!-- Invoice Header -->
          <div class="invoice-header">
            <div class="company-logo">
              <img src="assets/logo/logo.png" alt="NI Vehicle Logistics Logo" class="logo" />
            </div>
            <div class="company-details">
              <h2 class="company-name">{{ companyDetails.name }}</h2>
              <p>{{ companyDetails.address }}</p>
              <p>{{ companyDetails.city }}, {{ companyDetails.postcode }}</p>
              <p>{{ companyDetails.country }}</p>
              <p>Company No: {{ companyDetails.companyNumber }}</p>
            </div>
          </div>

          <!-- Invoice Title -->
          <div class="invoice-title">
            <h1>INVOICE</h1>
          </div>

          <!-- Invoice Meta -->
          <div class="invoice-meta">
            <div class="invoice-meta-row">
              <div class="invoice-meta-left">
                <div class="invoice-meta-item">
                  <strong>Invoice Number:</strong>
                  <span>{{ getInvoiceNumber(selectedExpense!) }}</span>
                </div>
                <div class="invoice-meta-item">
                  <strong>Invoice Date:</strong>
                  <span>{{ selectedExpense?.date | date : 'mediumDate' }}</span>
                </div>
                <div class="invoice-meta-item">
                  <strong>Due Date:</strong>
                  <span>{{ (selectedExpense?.date | date : 'yyyy-MM-dd') ? (selectedExpense?.date | date : 'yyyy-MM-dd+30d' | date : 'mediumDate') : '' }}</span>
                </div>
              </div>
              <div class="invoice-meta-right">
                <div class="invoice-meta-item">
                  <strong>Job Reference:</strong>
                  <span>{{ selectedExpense?.jobId || 'N/A' }}</span>
                </div>
                <div class="invoice-meta-item">
                  <strong>Status:</strong>
                  <span [ngClass]="{ 'paid-status': selectedExpense?.isPaid }">
                    {{ selectedExpense?.isPaid ? 'PAID' : 'UNPAID' }}
                  </span>
                </div>
              </div>
            </div>
          </div>

          <!-- Invoice Table -->
          <table class="invoice-table">
            <thead>
              <tr>
                <th>Description</th>
                <th>Quantity</th>
                <th>Unit Price</th>
                <th>Amount</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>{{ selectedExpense?.description }}</td>
                <td>1</td>
                <td>{{ formatCurrency(selectedExpense?.amount || 0) }}</td>
                <td>{{ formatCurrency(selectedExpense?.amount || 0) }}</td>
              </tr>
              <tr *ngIf="selectedExpense?.notes" class="notes-row">
                <td colspan="4"><strong>Notes:</strong> {{ selectedExpense?.notes }}</td>
              </tr>
            </tbody>
            <tfoot>
              <tr>
                <td colspan="3" class="text-right"><strong>Subtotal</strong></td>
                <td>{{ formatCurrency(selectedExpense?.amount || 0) }}</td>
              </tr>
              <tr>
                <td colspan="3" class="text-right"><strong>VAT (20%)</strong></td>
                <td>{{ formatCurrency((selectedExpense?.amount || 0) * 0.2) }}</td>
              </tr>
              <tr class="total-row">
                <td colspan="3" class="text-right"><strong>Total</strong></td>
                <td>{{ formatCurrency((selectedExpense?.amount || 0) * 1.2) }}</td>
              </tr>
            </tfoot>
          </table>

          <!-- Payment Information -->
          <div class="payment-info">
            <h3>Payment Information</h3>
            <p>Please make payment to:</p>
            <p><strong>Bank:</strong> Example Bank</p>
            <p><strong>Account Name:</strong> NI VEHICLE LOGISTICS LTD</p>
            <p><strong>Sort Code:</strong> 00-00-00</p>
            <p><strong>Account Number:</strong> 12345678</p>
            <p><strong>Reference:</strong> {{ getInvoiceNumber(selectedExpense!) }}</p>
          </div>

          <!-- Footer -->
          <div class="invoice-footer">
            <p>Thank you for your business!</p>
            <p class="legal-text">Payment terms: 30 days from invoice date. Late payments may be subject to interest charges.</p>
          </div>
        </div>
      </div>
    </mat-dialog-content>
    <mat-dialog-actions align="end">
      <button mat-button mat-dialog-close>Close</button>
      <button mat-raised-button color="primary" (click)="performPrint()" [disabled]="isPrintingInvoice">
        <mat-icon>print</mat-icon>
        Print
      </button>
    </mat-dialog-actions>
  </div>
</ng-template>


--- ./src/app/pages/expenses/expense-list/expense-list.component.scss ---
.expenses-card {
  margin: 24px;
  padding: 0;
  overflow: hidden;
}

/* Account for sidebar and topbar */
@media (min-width: 1200px) {
  .expenses-card {
    margin-left: 274px; /* 250px sidebar + 24px margin */
    margin-top: 88px; /* 64px topbar + 24px margin */
    margin-right: 24px;
    margin-bottom: 24px;
  }
}

@media (min-width: 768px) and (max-width: 1199px) {
  .expenses-card {
    margin-left: 84px; /* 60px collapsed sidebar + 24px margin */
    margin-top: 88px; /* 64px topbar + 24px margin */
    margin-right: 24px;
    margin-bottom: 24px;
  }
}

@media (max-width: 767px) {
  .expenses-card {
    margin-left: 16px;
    margin-right: 16px;
    margin-top: 80px; /* topbar + smaller margin */
    margin-bottom: 16px;
  }
}

.header-wrapper {
  padding: 24px 24px 0;

  .header-title {
    h1 {
      margin-bottom: 8px;
    }

    .subtitle {
      color: var(--text-secondary);
      margin: 0;
    }
  }
}

.filters-actions-wrapper {
  padding: 16px 24px;
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: flex-start;
  gap: 16px;

  .filters-section {
    flex: 1;
    min-width: 300px;

    .search-field {
      width: 100%;
      margin-bottom: 16px;
    }

    .filters-group {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;

      mat-form-field {
        min-width: 150px;
        flex: 1;
      }

      .date-range-group {
        display: flex;
        gap: 16px;
        width: 100%;

        mat-form-field {
          flex: 1;
        }
      }
    }
  }

  .actions-group {
    display: flex;
    gap: 12px;
    align-items: center;

    .bulk-approve-button {
      white-space: nowrap;
    }

    .create-button {
      white-space: nowrap;
    }
  }
}

.table-container {
  position: relative;
  min-height: 400px;
  max-height: calc(100vh - 350px);
  overflow: auto;

  .loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(255, 255, 255, 0.7);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 10;

    span {
      margin-top: 16px;
      color: var(--text-secondary);
    }
  }

  table {
    width: 100%;

    &.loading {
      opacity: 0.5;
    }

    .expense-row {
      cursor: pointer;
      transition: background-color 0.2s ease;

      &:hover {
        background-color: rgba(0, 0, 0, 0.04);
      }
    }

    .mat-mdc-cell {
      padding: 12px 8px;
    }

    .status-chip {
      padding: 4px 12px;
      border-radius: 16px;
      font-size: 12px;
      font-weight: 500;
      white-space: nowrap;
    }

    .action-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 4px;
    }
  }

  .empty-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 48px 24px;
    text-align: center;

    .empty-icon {
      font-size: 64px;
      width: 64px;
      height: 64px;
      color: rgba(0, 0, 0, 0.2);
      margin-bottom: 16px;
    }

    h3 {
      font-size: 20px;
      margin-bottom: 8px;
    }

    p {
      color: var(--text-secondary);
      margin-bottom: 24px;
    }
  }
}

mat-paginator {
  border-top: 1px solid rgba(0, 0, 0, 0.12);
}

/* Status chips */
.status-pending {
  background-color: rgba(255, 152, 0, 0.12);
  color: #ff9800;
}

.status-approved {
  background-color: rgba(76, 175, 80, 0.12);
  color: #4caf50;
}

.status-rejected {
  background-color: rgba(244, 67, 54, 0.12);
  color: #f44336;
}

.status-default {
  background-color: rgba(0, 0, 0, 0.08);
  color: rgba(0, 0, 0, 0.6);
}

/* Dialog Styles */
.expense-detail-dialog {
  .expense-info-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 16px;
    margin-top: 16px;

    .expense-info-item {
      display: flex;
      flex-direction: column;

      &.full-width {
        grid-column: 1 / -1;
      }

      .label {
        font-size: 12px;
        color: var(--text-secondary);
        margin-bottom: 4px;
      }

      .value {
        font-size: 16px;
      }

      .notes-content {
        background-color: rgba(0, 0, 0, 0.04);
        padding: 12px;
        border-radius: 4px;
        font-size: 14px;
        white-space: pre-line;
      }

      .receipt-image {
        max-width: 300px;
        margin-top: 8px;
        border: 1px solid rgba(0, 0, 0, 0.12);
        border-radius: 4px;
        overflow: hidden;

        img {
          width: 100%;
          height: auto;
          display: block;
        }
      }
    }
  }
}

/* Rejection Dialog */
.rejection-dialog {
  .full-width {
    width: 100%;
  }
}

/* Print Invoice Dialog */
.print-invoice-dialog {
  h2 {
    margin-bottom: 24px;
  }

  .print-preview-container {
    position: relative;
    max-height: 60vh;
    overflow-y: auto;
    padding: 16px;
    background-color: #f5f5f5;
    border-radius: 4px;

    .print-loading {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.8);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10;

      p {
        margin-top: 16px;
        color: var(--text-secondary);
      }
    }
  }

  .invoice-container {
    background-color: white;
    padding: 40px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    max-width: 800px;
    margin: 0 auto;

    .invoice-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 40px;

      .company-logo {
        flex: 1;

        .logo {
          max-width: 200px;
          height: auto;
        }
      }

      .company-details {
        text-align: right;

        h2 {
          font-size: 18px;
          font-weight: bold;
          margin-bottom: 8px;
        }

        p {
          margin: 0 0 4px;
          font-size: 14px;
        }
      }
    }

    .invoice-title {
      text-align: center;
      margin: 40px 0;

      h1 {
        font-size: 28px;
        font-weight: bold;
        color: var(--primary-color);
        margin: 0;
      }
    }

    .invoice-meta {
      margin-bottom: 40px;

      .invoice-meta-row {
        display: flex;
        justify-content: space-between;

        .invoice-meta-left,
        .invoice-meta-right {
          flex: 1;
        }

        .invoice-meta-right {
          text-align: right;
        }
      }

      .invoice-meta-item {
        margin-bottom: 8px;

        strong {
          display: inline-block;
          width: 120px;
        }

        .paid-status {
          color: #4caf50;
          font-weight: bold;
        }
      }
    }

    .invoice-table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 40px;

      th,
      td {
        padding: 12px;
        text-align: left;
        border-bottom: 1px solid #ddd;
      }

      th {
        font-weight: bold;
        background-color: #f5f5f5;
      }

      .text-right {
        text-align: right;
      }

      .notes-row td {
        font-size: 14px;
        color: var(--text-secondary);
        background-color: #f9f9f9;
      }

      tfoot tr:last-child {
        font-weight: bold;
        font-size: 16px;

        td {
          padding-top: 16px;
          border-top: 2px solid #ddd;
        }
      }
    }

    .payment-info {
      margin-bottom: 40px;
      padding: 20px;
      background-color: #f9f9f9;
      border-radius: 4px;

      h3 {
        font-size: 16px;
        margin-top: 0;
        margin-bottom: 12px;
      }

      p {
        margin: 4px 0;
      }
    }

    .invoice-footer {
      margin-top: 60px;
      border-top: 1px solid #ddd;
      padding-top: 20px;
      font-size: 14px;
      color: var(--text-secondary);

      .legal-text {
        font-size: 12px;
        margin-top: 8px;
      }
    }
  }
}

/* Payment Status */
.payment-status-container {
  display: flex;
  align-items: center;
  gap: 8px;

  .payment-menu-button {
    opacity: 0.5;
    transition: opacity 0.2s ease;

    &:hover {
      opacity: 1;
    }
  }
}

/* Responsive styles */
@media (max-width: 1200px) {
  .filters-actions-wrapper {
    flex-direction: column;

    .filters-section {
      width: 100%;
    }

    .actions-group {
      width: 100%;
      justify-content: flex-end;
    }
  }

  .invoice-container {
    padding: 20px;

    .invoice-meta-row {
      flex-direction: column;

      .invoice-meta-right {
        text-align: left;
        margin-top: 16px;
      }
    }
  }
}

@media (max-width: 768px) {
  .header-wrapper,
  .filters-actions-wrapper {
    padding: 16px;
  }

  .filters-group {
    flex-direction: column;

    mat-form-field {
      width: 100%;
    }

    .date-range-group {
      flex-direction: column;
    }
  }

  .expense-info-grid {
    grid-template-columns: 1fr !important;
  }

  .table-container {
    .mat-mdc-cell {
      font-size: 12px;
    }
  }

  /* Hide some columns on mobile */
  .mat-column-jobId,
  .mat-column-driver {
    display: none;
  }

  .print-preview-container {
    padding: 8px;
  }

  .invoice-container {
    padding: 16px;

    .invoice-header {
      flex-direction: column;

      .company-logo,
      .company-details {
        text-align: center;
        margin-bottom: 20px;
      }
    }
  }
}

@media print {
  .print-invoice-dialog {
    .invoice-container {
      box-shadow: none;
      padding: 0;
    }
  }
}


--- ./src/app/pages/expenses/expense-list/expense-list.component.ts ---
import { Component, OnInit, ViewChild, AfterViewInit, TemplateRef } from '@angular/core';
import { Router } from '@angular/router';
import { MatTableDataSource } from '@angular/material/table';
import { MatSort } from '@angular/material/sort';
import { MatPaginator } from '@angular/material/paginator';
import { MatDialog } from '@angular/material/dialog';
import { MatCheckboxChange } from '@angular/material/checkbox';
import { Expense, ExpenseStatus } from '../../../shared/models/expense.model';
import { MatSnackBar } from '@angular/material/snack-bar';
import { ExpenseService } from '../../../services/expense.service';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { ConfirmationDialogComponent } from '../../../dialogs/confirmation-dialog.component';
import { AuthService } from '../../../services/auth.service';
import { finalize } from 'rxjs/operators';

interface ExpenseFilters {
  status: string;
  driver: string;
  chargeable: boolean | 'All';
  dateRange: {
    start: Date | null;
    end: Date | null;
  };
  paidStatus: 'All' | 'Paid' | 'Unpaid';
}

interface Driver {
  id: string;
  name: string;
}

// Extended expense type that includes payment properties
interface ExtendedExpense extends Expense {
  isPaid?: boolean;
  paidDate?: Date;
  paidBy?: string;
  paymentReference?: string;
}

@Component({
  selector: 'app-expense-list',
  templateUrl: './expense-list.component.html',
  styleUrls: ['./expense-list.component.scss'],
  standalone: false,
})
export class ExpenseListComponent implements OnInit, AfterViewInit {
  @ViewChild(MatSort) sort!: MatSort;
  @ViewChild(MatPaginator) paginator!: MatPaginator;
  @ViewChild('expenseDetailDialog') expenseDetailDialog!: TemplateRef<any>;
  @ViewChild('rejectDialog') rejectDialog!: TemplateRef<any>;
  @ViewChild('printInvoiceDialog') printInvoiceDialog!: TemplateRef<any>;

  displayedColumns: string[] = ['id', 'description', 'amount', 'date', 'jobId', 'driver', 'status', 'paidStatus', 'chargeable', 'actions'];

  dataSource = new MatTableDataSource<ExtendedExpense>([]);
  filteredExpenses: ExtendedExpense[] = [];
  allExpenses: ExtendedExpense[] = [];
  isLoading = false;
  isManager = false;
  isPrintingInvoice = false;

  statusOptions = Object.values(ExpenseStatus);
  selectedExpense: ExtendedExpense | null = null;

  // For rejection comment
  rejectionForm: FormGroup;
  expenseToReject: ExtendedExpense | null = null;

  // For print invoice
  companyDetails = {
    name: 'NI VEHICLE LOGISTICS LTD',
    address: '55-59 Adelaide Street',
    city: 'Belfast',
    postcode: 'BT2 8FE',
    country: 'Northern Ireland',
    companyNumber: 'NI684159',
  };

  filters: ExpenseFilters = {
    status: 'All',
    driver: 'All',
    chargeable: 'All',
    dateRange: {
      start: null,
      end: null,
    },
    paidStatus: 'All',
  };

  drivers: Driver[] = [];

  constructor(
    private router: Router,
    private expenseService: ExpenseService,
    private dialog: MatDialog,
    private snackBar: MatSnackBar,
    private formBuilder: FormBuilder,
    private authService: AuthService
  ) {
    this.rejectionForm = this.formBuilder.group({
      reason: ['', Validators.required],
    });
  }

  ngOnInit(): void {
    this.loadExpenses();
    this.loadDrivers();
    this.checkPermissions();
  }

  ngAfterViewInit(): void {
    this.dataSource.sort = this.sort;
    this.dataSource.paginator = this.paginator;
    this.setupCustomFilter();
  }

  private checkPermissions(): void {
    this.authService.hasPermission('canApproveExpenses').subscribe((hasPermission) => {
      this.isManager = hasPermission;
    });
  }

  private loadDrivers(): void {
    this.authService.getUsersByRole('driver').subscribe({
      next: (drivers) => {
        this.drivers = drivers.map((driver) => ({
          id: driver.id,
          name: driver.name,
        }));
      },
      error: (error) => {
        console.error('Error loading drivers:', error);
      },
    });
  }

  private setupCustomFilter(): void {
    this.dataSource.filterPredicate = (data: ExtendedExpense, filter: string) => {
      const searchStr = filter.toLowerCase();

      // Check if the expense matches the search text
      const matchesSearch =
        data.description.toLowerCase().includes(searchStr) ||
        data.driverName.toLowerCase().includes(searchStr) ||
        data.jobId?.toLowerCase().includes(searchStr) ||
        data.id.toLowerCase().includes(searchStr);

      return matchesSearch;
    };
  }

  loadExpenses(): void {
    this.isLoading = true;

    this.expenseService.getExpenses().subscribe({
      next: (expenses: Expense[]) => {
        // Extend expenses with paid status if not present
        this.allExpenses = expenses.map((expense) => ({
          ...expense,
          isPaid: (expense as ExtendedExpense).isPaid !== undefined ? (expense as ExtendedExpense).isPaid : false,
        })) as ExtendedExpense[];

        this.applyFilters();
        this.isLoading = false;
      },
      error: (error) => {
        console.error('Error loading expenses:', error);
        this.showErrorMessage('Failed to load expenses. Please try again.');
        this.isLoading = false;
      },
    });
  }

  applyFilter(event: Event): void {
    const filterValue = (event.target as HTMLInputElement).value;
    this.dataSource.filter = filterValue.trim().toLowerCase();

    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage();
    }

    this.updateFilteredExpenses();
  }

  applyFilters(): void {
    // Get all expenses
    let filtered = [...this.allExpenses];

    // Apply status filter
    if (this.filters.status !== 'All') {
      filtered = filtered.filter((expense) => expense.status === this.filters.status);
    }

    // Apply driver filter
    if (this.filters.driver !== 'All') {
      filtered = filtered.filter((expense) => expense.driverId === this.filters.driver);
    }

    // Apply chargeable filter
    if (this.filters.chargeable !== 'All') {
      filtered = filtered.filter((expense) => expense.isChargeable === this.filters.chargeable);
    }

    // Apply paid status filter
    if (this.filters.paidStatus !== 'All') {
      const isPaid = this.filters.paidStatus === 'Paid';
      filtered = filtered.filter((expense) => expense.isPaid === isPaid);
    }

    // Apply date range filter
    if (this.filters.dateRange.start && this.filters.dateRange.end) {
      const startDate = new Date(this.filters.dateRange.start);
      const endDate = new Date(this.filters.dateRange.end);
      endDate.setHours(23, 59, 59); // Include the entire end day

      filtered = filtered.filter((expense) => {
        const expenseDate = new Date(expense.date);
        return expenseDate >= startDate && expenseDate <= endDate;
      });
    }

    // Update the data source
    this.dataSource.data = filtered;
    this.updateFilteredExpenses();
  }

  private updateFilteredExpenses(): void {
    this.filteredExpenses = this.dataSource.filteredData;
  }

  getStatusClass(status: ExpenseStatus): string {
    const statusMap: Record<string, string> = {
      [ExpenseStatus.PENDING]: 'status-pending',
      [ExpenseStatus.APPROVED]: 'status-approved',
      [ExpenseStatus.REJECTED]: 'status-rejected',
    };
    return statusMap[status] || 'status-default';
  }

  getPaidStatusClass(isPaid: boolean | undefined): string {
    return isPaid ? 'status-approved' : 'status-pending';
  }

  getPaidStatusText(isPaid: boolean | undefined): string {
    return isPaid ? 'Paid' : 'Unpaid';
  }

  createNewExpense(): void {
    this.router.navigate(['/expenses/new']);
  }

  viewExpenseDetails(expense: ExtendedExpense): void {
    this.selectedExpense = expense;
    this.dialog.open(this.expenseDetailDialog, {
      width: '600px',
    });
  }

  closeDialog(): void {
    this.dialog.closeAll();
  }

  approveExpense(expense: ExtendedExpense): void {
    // Confirm with the manager
    const dialogRef = this.dialog.open(ConfirmationDialogComponent, {
      width: '400px',
      data: {
        title: 'Approve Invoice',
        message: `Are you sure you want to approve this invoice of ${this.formatCurrency(expense.amount)}?`,
        confirmText: 'Approve',
        cancelText: 'Cancel',
      },
    });

    dialogRef.afterClosed().subscribe((result) => {
      if (result) {
        this.expenseService
          .updateExpenseStatus(
            expense.id,
            ExpenseStatus.APPROVED,
            { approvedBy: 'Admin User' } // In a real app, this would be the current user
          )
          .subscribe({
            next: (updatedExpense: Expense) => {
              // Update the expense in the list
              const index = this.allExpenses.findIndex((e) => e.id === updatedExpense.id);
              if (index !== -1) {
                // Preserve the isPaid status when updating
                this.allExpenses[index] = {
                  ...updatedExpense,
                  isPaid: this.allExpenses[index].isPaid,
                  paidDate: this.allExpenses[index].paidDate,
                } as ExtendedExpense;

                this.applyFilters();
              }

              this.showSuccessMessage('Invoice approved successfully');
              this.dialog.closeAll();
            },
            error: (error: any) => {
              this.showErrorMessage('Failed to approve invoice');
              console.error('Error approving invoice:', error);
            },
          });
      }
    });
  }

  openRejectDialog(expense: ExtendedExpense): void {
    this.expenseToReject = expense;
    this.rejectionForm.reset({
      reason: '',
    });
    this.dialog.open(this.rejectDialog, {
      width: '400px',
    });
  }

  confirmReject(): void {
    if (!this.expenseToReject || this.rejectionForm.invalid) {
      return;
    }

    const reason = this.rejectionForm.get('reason')?.value;

    this.expenseService
      .updateExpenseStatus(
        this.expenseToReject.id,
        ExpenseStatus.REJECTED,
        { approvedBy: 'Admin User' } // In a real app, this would be the current user
      )
      .subscribe({
        next: (updatedExpense: Expense) => {
          // Update the expense in the list
          const index = this.allExpenses.findIndex((e) => e.id === updatedExpense.id);
          if (index !== -1) {
            // Update with rejection reason and preserve payment info
            const updatedWithNotes = {
              ...updatedExpense,
              notes: (updatedExpense.notes || '') + `\nRejection reason: ${reason}`,
              isPaid: this.allExpenses[index].isPaid,
              paidDate: this.allExpenses[index].paidDate,
            } as ExtendedExpense;

            this.allExpenses[index] = updatedWithNotes;
            this.applyFilters();
          }

          this.showSuccessMessage('Invoice rejected');
          this.dialog.closeAll();
          this.expenseToReject = null;
        },
        error: (error: any) => {
          this.showErrorMessage('Failed to reject invoice');
          console.error('Error rejecting invoice:', error);
        },
      });
  }

  rejectExpense(expense: ExtendedExpense): void {
    this.openRejectDialog(expense);
  }

  updateChargeable(expense: ExtendedExpense, event: MatCheckboxChange): void {
    if (expense.status !== ExpenseStatus.APPROVED) {
      this.showErrorMessage('Only approved invoices can be marked as chargeable');
      return;
    }

    this.expenseService.updateExpenseChargeableStatus(expense.id, event.checked).subscribe({
      next: (updatedExpense: Expense) => {
        // Update the expense in the list
        const index = this.allExpenses.findIndex((e) => e.id === updatedExpense.id);
        if (index !== -1) {
          // Preserve payment info when updating
          this.allExpenses[index] = {
            ...updatedExpense,
            isPaid: this.allExpenses[index].isPaid,
            paidDate: this.allExpenses[index].paidDate,
          } as ExtendedExpense;

          this.applyFilters();
        }

        this.showSuccessMessage(event.checked ? 'Invoice marked as chargeable' : 'Invoice marked as non-chargeable');
      },
      error: (error: any) => {
        this.showErrorMessage('Failed to update invoice');
        console.error('Error updating invoice:', error);
      },
    });
  }

  updatePaidStatus(expense: ExtendedExpense, isPaid: boolean): void {
    // Only allow updating paid status for approved invoices
    if (expense.status !== ExpenseStatus.APPROVED) {
      this.showErrorMessage('Only approved invoices can be marked as paid');
      return;
    }

    this.expenseService.updateExpensePaidStatus(expense.id, isPaid).subscribe({
      next: (updatedExpense: Expense) => {
        // Update the expense in the list
        const index = this.allExpenses.findIndex((e) => e.id === updatedExpense.id);
        if (index !== -1) {
          // Update with payment info
          this.allExpenses[index] = {
            ...this.allExpenses[index],
            isPaid: isPaid,
            paidDate: isPaid ? new Date() : undefined,
          } as ExtendedExpense;

          this.applyFilters();
        }

        this.showSuccessMessage(isPaid ? 'Invoice marked as paid' : 'Invoice marked as unpaid');
      },
      error: (error) => {
        this.showErrorMessage('Failed to update invoice payment status');
        console.error('Error updating invoice payment status:', error);
      },
    });
  }

  printInvoice(expense: ExtendedExpense): void {
    this.selectedExpense = expense;
    const dialogRef = this.dialog.open(this.printInvoiceDialog, {
      width: '800px',
      panelClass: 'print-dialog',
    });

    dialogRef.afterOpened().subscribe(() => {
      // Give time for the dialog content to render
      setTimeout(() => {
        this.performPrint();
      }, 500);
    });
  }

  performPrint(): void {
    this.isPrintingInvoice = true;

    setTimeout(() => {
      const printContent = document.getElementById('printableInvoice');
      const originalContents = document.body.innerHTML;

      if (printContent) {
        const printWindow = window.open('', '_blank');
        if (printWindow) {
          printWindow.document.open();
          printWindow.document.write(`
            <html>
              <head>
                <title>Invoice ${this.selectedExpense?.id}</title>
                <style>
                  body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }
                  .invoice-container { max-width: 800px; margin: 0 auto; }
                  .invoice-header { display: flex; justify-content: space-between; margin-bottom: 40px; }
                  .logo { max-width: 200px; }
                  .company-details { text-align: right; }
                  .invoice-title { font-size: 24px; font-weight: bold; margin: 40px 0 20px; }
                  .invoice-meta { margin-bottom: 30px; }
                  .invoice-meta-item { margin-bottom: 5px; }
                  .invoice-table { width: 100%; border-collapse: collapse; margin: 20px 0; }
                  .invoice-table th, .invoice-table td { border: 1px solid #ddd; padding: 10px; text-align: left; }
                  .invoice-table th { background-color: #f5f5f5; }
                  .total-row { font-weight: bold; }
                  .footer { margin-top: 40px; border-top: 1px solid #ddd; padding-top: 20px; font-size: 12px; }
                </style>
              </head>
              <body>
                ${printContent.innerHTML}
              </body>
            </html>
          `);
          printWindow.document.close();
          printWindow.focus();

          // Print after a small delay to ensure content is fully loaded
          setTimeout(() => {
            printWindow.print();
            printWindow.close();
            this.isPrintingInvoice = false;
          }, 500);
        } else {
          this.showErrorMessage('Failed to open print window. Please check your browser settings.');
          this.isPrintingInvoice = false;
        }
      }
    }, 300);
  }

  formatCurrency(amount: number): string {
    return new Intl.NumberFormat('en-GB', {
      style: 'currency',
      currency: 'GBP',
    }).format(amount);
  }

  getBulkApprovalCount(): number {
    return this.filteredExpenses.filter((expense) => expense.status === ExpenseStatus.PENDING).length;
  }

  bulkApproveExpenses(): void {
    const pendingExpenses = this.filteredExpenses.filter((expense) => expense.status === ExpenseStatus.PENDING);

    if (pendingExpenses.length === 0) {
      this.showErrorMessage('No pending invoices to approve');
      return;
    }

    // Confirm with the manager
    const dialogRef = this.dialog.open(ConfirmationDialogComponent, {
      width: '400px',
      data: {
        title: 'Bulk Approve Invoices',
        message: `Are you sure you want to approve all ${pendingExpenses.length} pending invoices?`,
        confirmText: 'Approve All',
        cancelText: 'Cancel',
      },
    });

    dialogRef.afterClosed().subscribe((result) => {
      if (result) {
        let approvedCount = 0;
        let errorCount = 0;

        // Process each expense one by one
        pendingExpenses.forEach((expense) => {
          this.expenseService
            .updateExpenseStatus(expense.id, ExpenseStatus.APPROVED, {
              approvedBy: 'Admin User',
            })
            .subscribe({
              next: (updatedExpense: Expense) => {
                // Update the expense in the list
                const index = this.allExpenses.findIndex((e) => e.id === updatedExpense.id);
                if (index !== -1) {
                  // Preserve payment info when updating
                  this.allExpenses[index] = {
                    ...updatedExpense,
                    isPaid: this.allExpenses[index].isPaid,
                    paidDate: this.allExpenses[index].paidDate,
                  } as ExtendedExpense;
                }

                approvedCount++;

                // When all done, refresh the view
                if (approvedCount + errorCount === pendingExpenses.length) {
                  this.applyFilters();
                  if (errorCount === 0) {
                    this.showSuccessMessage(`Successfully approved ${approvedCount} invoices`);
                  } else {
                    this.showErrorMessage(`Approved ${approvedCount} invoices, but failed to approve ${errorCount} invoices`);
                  }
                }
              },
              error: () => {
                errorCount++;

                // When all done, refresh the view
                if (approvedCount + errorCount === pendingExpenses.length) {
                  this.applyFilters();
                  if (errorCount === 0) {
                    this.showSuccessMessage(`Successfully approved ${approvedCount} invoices`);
                  } else {
                    this.showErrorMessage(`Approved ${approvedCount} invoices, but failed to approve ${errorCount} invoices`);
                  }
                }
              },
            });
        });
      }
    });
  }

  getCurrentDate(): string {
    return new Date().toLocaleDateString('en-GB');
  }

  getInvoiceNumber(expense: ExtendedExpense): string {
    return `INV-${expense.id.replace('EXP', '')}`;
  }

  private showSuccessMessage(message: string): void {
    this.snackBar.open(message, 'Close', {
      duration: 3000,
      horizontalPosition: 'end',
      verticalPosition: 'top',
      panelClass: ['success-snackbar'],
    });
  }

  private showErrorMessage(message: string): void {
    this.snackBar.open(message, 'Close', {
      duration: 5000,
      horizontalPosition: 'end',
      verticalPosition: 'top',
      panelClass: ['error-snackbar'],
    });
  }
}


--- ./src/app/pages/dashboard/dashboard.component.html ---
<!-- Dashboard Container -->
<div class="dashboard-container">
  <!-- Header Section -->
  <div class="dashboard-header">
    <h1 class="dashboard-title">Dashboard Overview</h1>
    <button mat-raised-button color="primary" (click)="refreshDashboardData()">
      <mat-icon>refresh</mat-icon>
      Refresh Data
    </button>
  </div>

  <!-- Loading Indicator -->
  <div *ngIf="isLoading" class="loading-container">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Loading dashboard data...</p>
  </div>

  <!-- Dashboard Content -->
  <div *ngIf="!isLoading" class="dashboard-content">
    <!-- Metrics Cards Section -->
    <div class="metrics-grid">
      <!-- Active Jobs Card -->
      <mat-card class="metric-card active-jobs">
        <mat-card-header>
          <mat-card-title>Active Jobs</mat-card-title>
          <mat-card-subtitle>Currently in progress</mat-card-subtitle>
        </mat-card-header>
        <mat-card-content>
          <div class="metric-value">{{ metrics.activeJobs }}</div>
          <div class="metric-trend" [class.trend-up]="metrics.activeJobsTrend.increased" [class.trend-down]="!metrics.activeJobsTrend.increased">
            <mat-icon>{{ metrics.activeJobsTrend.increased ? 'trending_up' : 'trending_down' }}</mat-icon>
            <span>{{ metrics.activeJobsTrend.percentChange | number : '1.1-1' }}%</span>
          </div>
        </mat-card-content>
      </mat-card>

      <!-- Unallocated Jobs Card -->
      <mat-card class="metric-card unallocated-jobs">
        <mat-card-header>
          <mat-card-title>Unallocated Jobs</mat-card-title>
          <mat-card-subtitle>Awaiting driver assignment</mat-card-subtitle>
        </mat-card-header>
        <mat-card-content>
          <div class="metric-value">{{ metrics.unallocatedJobs }}</div>
          <div class="metric-trend" [class.trend-up]="metrics.unallocatedJobsTrend.increased" [class.trend-down]="!metrics.unallocatedJobsTrend.increased">
            <mat-icon>{{ metrics.unallocatedJobsTrend.increased ? 'trending_up' : 'trending_down' }}</mat-icon>
            <span>{{ metrics.unallocatedJobsTrend.percentChange | number : '1.1-1' }}%</span>
          </div>
        </mat-card-content>
      </mat-card>

      <!-- Completed Jobs Card -->
      <mat-card class="metric-card completed-jobs">
        <mat-card-header>
          <mat-card-title>Completed Jobs</mat-card-title>
          <mat-card-subtitle>Successfully delivered</mat-card-subtitle>
        </mat-card-header>
        <mat-card-content>
          <div class="metric-value">{{ metrics.deliveredJobs }}</div>
        </mat-card-content>
      </mat-card>

      <!-- Total Jobs Card -->
      <mat-card class="metric-card total-jobs">
        <mat-card-header>
          <mat-card-title>Total Jobs</mat-card-title>
          <mat-card-subtitle>All jobs in system</mat-card-subtitle>
        </mat-card-header>
        <mat-card-content>
          <div class="metric-value">{{ metrics.totalJobs }}</div>
        </mat-card-content>
      </mat-card>
    </div>

    <!-- Main Content -->
    <div class="main-content">
      <!-- Today's Jobs Table -->
      <div class="jobs-table-container mat-elevation-z3">
        <div class="header-wrapper">
          <div class="header-title">
            <h2>Today's Jobs</h2>
            <p class="subtitle">{{ jobs.length }} total jobs</p>
          </div>
        </div>

        <div class="table-container">
          <!-- Loading Overlay -->
          <div class="loading-overlay" *ngIf="isLoading">
            <mat-spinner diameter="40"></mat-spinner>
            <span>Loading jobs...</span>
          </div>

          <!-- Table -->
          <table mat-table [dataSource]="jobsDataSource" matSort [class.loading]="isLoading">
            <!-- Job ID Column -->
            <ng-container matColumnDef="shippingReference">
              <th mat-header-cell *matHeaderCellDef mat-sort-header>Shipping Reference</th>
              <td mat-cell *matCellDef="let job" class="job-id">{{ job.shippingReference }}</td>
            </ng-container>

            <!-- Reg Column -->
            <ng-container matColumnDef="regNumber">
              <th mat-header-cell *matHeaderCellDef mat-sort-header>Reg</th>
              <td mat-cell *matCellDef="let job">{{ job.vehicleRegistration || 'N/A' }}</td>
            </ng-container>

            <!-- Customer Name Column -->
            <ng-container matColumnDef="customerName">
              <th mat-header-cell *matHeaderCellDef mat-sort-header>Customer</th>
              <td mat-cell *matCellDef="let job">{{ job.customerName || 'N/A' }}</td>
            </ng-container>

            <!-- Collection Date Column -->
            <ng-container matColumnDef="collectionDate">
              <th mat-header-cell *matHeaderCellDef mat-sort-header>Collection Date</th>
              <td mat-cell *matCellDef="let job">
                {{ job.createdAt | date : 'short' }}
              </td>
            </ng-container>

            <!-- Collection Town Column -->
            <ng-container matColumnDef="collectionTown">
              <th mat-header-cell *matHeaderCellDef>Collection Town</th>
              <td mat-cell *matCellDef="let job">{{ job.collectionCity || 'N/A' }}</td>
            </ng-container>

            <!-- Delivery Town Column -->
            <ng-container matColumnDef="deliveryTown">
              <th mat-header-cell *matHeaderCellDef>Delivery Town</th>
              <td mat-cell *matCellDef="let job">{{ job.deliveryCity || 'N/A' }}</td>
            </ng-container>

            <!-- Status Column -->
            <ng-container matColumnDef="status">
              <th mat-header-cell *matHeaderCellDef mat-sort-header>Status</th>
              <td mat-cell *matCellDef="let job">
                <span class="status-chip" [ngClass]="getStatusClass(job.status)">
                  {{ job.status | titlecase }}
                </span>
              </td>
            </ng-container>

            <!-- Driver Column -->
            <ng-container matColumnDef="driver">
              <th mat-header-cell *matHeaderCellDef mat-sort-header>Driver</th>
              <td mat-cell *matCellDef="let job">
                <span *ngIf="job.driverId">Assigned</span>
                <span *ngIf="!job.driverId">Unassigned</span>
              </td>
            </ng-container>

            <!-- Actions Column -->
            <ng-container matColumnDef="actions">
              <th mat-header-cell *matHeaderCellDef></th>
              <td mat-cell *matCellDef="let job">
                <button mat-icon-button [matMenuTriggerFor]="menu" (click)="$event.stopPropagation()">
                  <mat-icon>more_vert</mat-icon>
                </button>
                <mat-menu #menu="matMenu" xPosition="before">
                  <button mat-menu-item (click)="viewJobDetails(job)">
                    <mat-icon>visibility</mat-icon>
                    <span>View Details</span>
                  </button>
                  <button mat-menu-item (click)="editJob(job, $event)">
                    <mat-icon>edit</mat-icon>
                    <span>Edit</span>
                  </button>
                  <button mat-menu-item (click)="assignJob(job, $event)" *ngIf="!job.driverId">
                    <mat-icon>assignment_ind</mat-icon>
                    <span>Assign Driver</span>
                  </button>
                </mat-menu>
              </td>
            </ng-container>

            <!-- Header and Data Rows -->
            <tr mat-header-row *matHeaderRowDef="displayedColumns; sticky: true"></tr>
            <tr mat-row *matRowDef="let row; columns: displayedColumns" (click)="viewJobDetails(row)" class="job-row"></tr>
          </table>

          <!-- Empty State -->
          <div class="empty-state" *ngIf="!isLoading && jobs.length === 0">
            <mat-icon class="empty-icon">work_outline</mat-icon>
            <h3>No jobs for today</h3>
            <p>There are no jobs scheduled for today</p>
            <button mat-flat-button color="primary" (click)="createNewJob()">
              <mat-icon>add</mat-icon>
              New Job
            </button>
          </div>
        </div>

        <!-- Paginator -->
        <mat-paginator [length]="jobs.length" [pageSize]="10" [pageSizeOptions]="[5, 10, 25]" showFirstLastButtons> </mat-paginator>
      </div>

      <!-- Drivers List -->
      <div class="drivers-list-container mat-elevation-z3">
        <div class="header-wrapper">
          <div class="header-title">
            <h2>Driver Status</h2>
          </div>
        </div>

        <!-- Status Filter Chips -->
        <div class="status-filter">
          <span class="status-chip" [class.active]="selectedDriverStatus === status" *ngFor="let status of driverStatusOptions" (click)="setDriverStatusFilter(status)">
            {{ status }}
          </span>
        </div>

        <!-- Loading Message -->
        <div class="loading-message" *ngIf="isLoadingDrivers">
          <mat-spinner diameter="30" style="margin: 0 auto 10px"></mat-spinner>
          Loading drivers...
        </div>

        <!-- No Drivers Message -->
        <div class="no-drivers" *ngIf="!isLoadingDrivers && filteredDrivers.length === 0">
          <mat-icon>person_off</mat-icon>
          <p>No drivers found with the selected status</p>
        </div>

        <!-- Driver Grid -->
        <div class="driver-grid" *ngIf="!isLoadingDrivers && filteredDrivers.length > 0">
          <div class="driver-card" *ngFor="let driver of filteredDrivers" (click)="viewDriverDetails(driver)">
            <div class="driver-avatar">
              {{ getDriverInitials(driver) }}
              <span
                class="availability-indicator"
                [ngClass]="{
                  available: driver.status === 'Available',
                  busy: driver.status === 'Busy',
                  'on-leave': driver.status === 'On Leave',
                  offline: driver.status === 'Offline'
                }"></span>
            </div>
            <div class="driver-info">
              <div class="driver-name">{{ driver.profile.name }}</div>
              <div class="driver-status">
                {{ driver.status }}
                <span *ngIf="driver.status !== 'On Leave' && driver.status !== 'Offline'">
                  • Jobs:
                  <span class="job-count" [ngClass]="getJobCountClass(driver.currentJobs)">
                    {{ driver.currentJobs }}
                  </span>
                </span>
              </div>
            </div>
            <div class="driver-actions">
              <button mat-icon-button matTooltip="View Details" (click)="$event.stopPropagation(); viewDriverDetails(driver)">
                <mat-icon>visibility</mat-icon>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Recent Jobs Section -->
    <div class="recent-jobs-section">
      <mat-card class="jobs-table-card">
        <mat-card-header>
          <mat-card-title>All Jobs</mat-card-title>
          <mat-card-subtitle>Latest job activities</mat-card-subtitle>
        </mat-card-header>
        <mat-card-content>
          <!-- Search Filter -->
          <div class="table-controls">
            <mat-form-field appearance="outline" class="search-field">
              <mat-label>Search jobs...</mat-label>
              <input matInput (keyup)="applyFilter($event)" placeholder="Enter job ID, registration, or customer name" />
              <mat-icon matSuffix>search</mat-icon>
            </mat-form-field>
          </div>

          <!-- Jobs Table -->
          <div class="table-container">
            <table mat-table [dataSource]="jobsDataSource" matSort class="jobs-table">
              <!-- Job ID Column -->
              <ng-container matColumnDef="id">
                <th mat-header-cell *matHeaderCellDef mat-sort-header>Job ID</th>
                <td mat-cell *matCellDef="let job">
                  <span class="job-id">{{ job.id }}</span>
                </td>
              </ng-container>

              <!-- Registration Column -->
              <ng-container matColumnDef="regNumber">
                <th mat-header-cell *matHeaderCellDef mat-sort-header>Registration</th>
                <td mat-cell *matCellDef="let job">
                  <span class="registration">{{ job.regNumber || 'N/A' }}</span>
                </td>
              </ng-container>

              <!-- Customer Column -->
              <ng-container matColumnDef="customerName">
                <th mat-header-cell *matHeaderCellDef mat-sort-header>Customer</th>
                <td mat-cell *matCellDef="let job">
                  <span class="customer-name">{{ job.customerName || 'N/A' }}</span>
                </td>
              </ng-container>

              <!-- Collection Date Column -->
              <ng-container matColumnDef="collectionDate">
                <th mat-header-cell *matHeaderCellDef mat-sort-header>Collection Date</th>
                <td mat-cell *matCellDef="let job">
                  <span class="collection-date">{{ formatDate(job.collectionDate) }}</span>
                </td>
              </ng-container>

              <!-- Collection Town Column -->
              <ng-container matColumnDef="collectionTown">
                <th mat-header-cell *matHeaderCellDef>Collection</th>
                <td mat-cell *matCellDef="let job">
                  <span class="location">{{ job.collectionTown || 'N/A' }}</span>
                </td>
              </ng-container>

              <!-- Delivery Town Column -->
              <ng-container matColumnDef="deliveryTown">
                <th mat-header-cell *matHeaderCellDef>Delivery</th>
                <td mat-cell *matCellDef="let job">
                  <span class="location">{{ job.deliveryTown || 'N/A' }}</span>
                </td>
              </ng-container>

              <!-- Status Column -->
              <ng-container matColumnDef="status">
                <th mat-header-cell *matHeaderCellDef mat-sort-header>Status</th>
                <td mat-cell *matCellDef="let job">
                  <span class="status-badge" [ngClass]="getStatusClass(job.status)">
                    {{ job.status | titlecase }}
                  </span>
                </td>
              </ng-container>

              <!-- Driver Column -->
              <ng-container matColumnDef="driver">
                <th mat-header-cell *matHeaderCellDef>Driver</th>
                <td mat-cell *matCellDef="let job">
                  <span class="driver-name">{{ getDriverName(job.driverId) }}</span>
                </td>
              </ng-container>

              <!-- Actions Column -->
              <ng-container matColumnDef="actions">
                <th mat-header-cell *matHeaderCellDef>Actions</th>
                <td mat-cell *matCellDef="let job">
                  <div class="action-buttons">
                    <button mat-icon-button color="primary" (click)="viewJob(job)" matTooltip="View Job">
                      <mat-icon>visibility</mat-icon>
                    </button>
                    <button mat-icon-button color="accent" (click)="editJob(job)" matTooltip="Edit Job">
                      <mat-icon>edit</mat-icon>
                    </button>
                    <button *ngIf="job.status === 'unallocated'" mat-icon-button color="primary" (click)="allocateJob(job)" matTooltip="Allocate Job">
                      <mat-icon>assignment</mat-icon>
                    </button>
                    <button mat-icon-button color="warn" (click)="deleteJob(job)" matTooltip="Delete Job">
                      <mat-icon>delete</mat-icon>
                    </button>
                  </div>
                </td>
              </ng-container>

              <!-- Table Header and Rows -->
              <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
              <tr mat-row *matRowDef="let row; columns: displayedColumns" class="job-row"></tr>
            </table>

            <!-- No Data Message -->
            <div *ngIf="jobsDataSource.data.length === 0" class="no-data">
              <mat-icon>inbox</mat-icon>
              <p>No jobs found.</p>
            </div>
          </div>

          <!-- Paginator -->
          <mat-paginator [pageSizeOptions]="[10, 25, 50, 100]" [pageSize]="25" showFirstLastButtons> </mat-paginator>
        </mat-card-content>
      </mat-card>
    </div>

    <!-- Delivery Metrics Section -->
    <div class="delivery-metrics-section">
      <mat-card class="delivery-metrics-card">
        <mat-card-header>
          <mat-card-title>Delivery Performance</mat-card-title>
          <mat-card-subtitle>Period-over-period comparison</mat-card-subtitle>
        </mat-card-header>
        <mat-card-content>
          <div class="delivery-metrics-grid">
            <!-- Week Metric -->
            <div class="delivery-metric">
              <div class="metric-label">This Week</div>
              <div class="metric-value">{{ deliveryMetrics.week.current }}</div>
              <div class="metric-change" [class.positive]="deliveryMetrics.week.increased" [class.negative]="!deliveryMetrics.week.increased">
                <mat-icon>{{ deliveryMetrics.week.increased ? 'arrow_upward' : 'arrow_downward' }}</mat-icon>
                <span>{{ deliveryMetrics.week.change | number : '1.1-1' }}%</span>
              </div>
            </div>

            <!-- Month Metric -->
            <div class="delivery-metric">
              <div class="metric-label">This Month</div>
              <div class="metric-value">{{ deliveryMetrics.month.current }}</div>
              <div class="metric-change" [class.positive]="deliveryMetrics.month.increased" [class.negative]="!deliveryMetrics.month.increased">
                <mat-icon>{{ deliveryMetrics.month.increased ? 'arrow_upward' : 'arrow_downward' }}</mat-icon>
                <span>{{ deliveryMetrics.month.change | number : '1.1-1' }}%</span>
              </div>
            </div>

            <!-- Year Metric -->
            <div class="delivery-metric">
              <div class="metric-label">This Year</div>
              <div class="metric-value">{{ deliveryMetrics.year.current }}</div>
              <div class="metric-change" [class.positive]="deliveryMetrics.year.increased" [class.negative]="!deliveryMetrics.year.increased">
                <mat-icon>{{ deliveryMetrics.year.increased ? 'arrow_upward' : 'arrow_downward' }}</mat-icon>
                <span>{{ deliveryMetrics.year.change | number : '1.1-1' }}%</span>
              </div>
            </div>
          </div>
        </mat-card-content>
      </mat-card>
    </div>
  </div>
</div>


--- ./src/app/pages/dashboard/dashboard.component.scss ---
// Header Section
.dashboard-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;

  .dashboard-title {
    margin: 0;
    font-size: 2rem;
    font-weight: 500;
    color: var(--primary-color, #3f51b5);
  }

  button {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  @media (max-width: 768px) {
    flex-direction: column;
    align-items: flex-start;
    gap: 16px;

    .dashboard-title {
      font-size: 1.5rem;
    }
  }
}

// Loading State
.loading-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 200px;
  gap: 16px;

  p {
    margin: 0;
    color: rgba(0, 0, 0, 0.6);
    font-size: 1rem;
  }
}

.dashboard-content {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

// Metrics Grid
.metrics-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 20px;

  @media (max-width: 768px) {
    grid-template-columns: 1fr;
  }
}

.metric-card {
  position: relative;
  transition: transform 0.2s ease, box-shadow 0.2s ease;

  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
  }

  mat-card-header {
    padding-bottom: 8px;

    mat-card-title {
      font-size: 1.1rem;
      font-weight: 500;
      margin-bottom: 4px;
    }

    mat-card-subtitle {
      font-size: 0.875rem;
      opacity: 0.7;
    }
  }

  mat-card-content {
    padding-top: 8px;
  }

  .metric-value {
    font-size: 2.5rem;
    font-weight: 600;
    line-height: 1;
    margin-bottom: 8px;
  }

  .metric-trend {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 0.875rem;
    font-weight: 500;

    &.trend-up {
      color: #4caf50;
    }

    &.trend-down {
      color: #f44336;
    }

    mat-icon {
      font-size: 1.2rem;
      width: 1.2rem;
      height: 1.2rem;
    }
  }

  .metric-info {
    font-size: 0.875rem;
    color: rgba(0, 0, 0, 0.6);
    margin-top: 8px;
  }

  // Card-specific colors
  &.active-jobs {
    border-left: 4px solid #2196f3;

    .metric-value {
      color: #2196f3;
    }
  }

  &.unallocated-jobs {
    border-left: 4px solid #ff9800;

    .metric-value {
      color: #ff9800;
    }
  }

  &.completed-jobs {
    border-left: 4px solid #4caf50;

    .metric-value {
      color: #4caf50;
    }
  }

  &.total-jobs {
    border-left: 4px solid #9c27b0;

    .metric-value {
      color: #9c27b0;
    }
  }
}

// Delivery Metrics Section
.delivery-metrics-section {
  margin: 24px 0;
}

.delivery-metrics-card {
  .delivery-metrics-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 24px;

    @media (max-width: 768px) {
      grid-template-columns: 1fr;
      gap: 16px;
    }
  }

  .delivery-metric {
    text-align: center;
    padding: 16px;
    border-radius: 8px;
    background: rgba(0, 0, 0, 0.02);

    .metric-label {
      font-size: 0.875rem;
      color: rgba(0, 0, 0, 0.6);
      margin-bottom: 8px;
      font-weight: 500;
    }

    .metric-value {
      font-size: 2rem;
      font-weight: 600;
      color: #333;
      margin-bottom: 8px;
    }

    .metric-change {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      font-size: 0.875rem;
      font-weight: 500;

      &.positive {
        color: #4caf50;
      }

      &.negative {
        color: #f44336;
      }

      mat-icon {
        font-size: 1rem;
        width: 1rem;
        height: 1rem;
      }
    }
  }
}

// Drivers Section
.drivers-section {
  margin: 24px 0;
}

.drivers-card {
  .driver-filter {
    margin-bottom: 16px;

    mat-form-field {
      width: 200px;
    }
  }

  .drivers-loading {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    padding: 40px 0;
    color: rgba(0, 0, 0, 0.6);
  }

  .drivers-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .driver-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px;
    border: 1px solid rgba(0, 0, 0, 0.1);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;

    &:hover {
      background: rgba(0, 0, 0, 0.02);
      border-color: rgba(63, 81, 181, 0.3);
    }

    .driver-info {
      flex: 1;

      .driver-name {
        font-weight: 500;
        margin-bottom: 4px;
      }

      .driver-email {
        font-size: 0.875rem;
        color: rgba(0, 0, 0, 0.6);
      }
    }

    .driver-status {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      margin: 0 16px;

      .status-badge {
        padding: 4px 12px;
        border-radius: 16px;
        font-size: 0.75rem;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .driver-jobs {
        font-size: 0.75rem;
        color: rgba(0, 0, 0, 0.6);
      }
    }

    .driver-actions {
      display: flex;
      gap: 8px;
    }
  }

  .no-drivers {
    text-align: center;
    padding: 40px 0;
    color: rgba(0, 0, 0, 0.6);

    mat-icon {
      font-size: 3rem;
      width: 3rem;
      height: 3rem;
      margin-bottom: 16px;
      opacity: 0.5;
    }

    p {
      margin: 0;
      font-size: 1.1rem;
    }
  }
}

// Driver Status Badge Colors
.driver-available {
  background: #e8f5e8;
  color: #2e7d32;
}

.driver-busy {
  background: #fff3e0;
  color: #f57c00;
}

.driver-on-leave {
  background: #e3f2fd;
  color: #1976d2;
}

.driver-offline {
  background: #fce4ec;
  color: #c2185b;
}

.driver-default {
  background: #f5f5f5;
  color: #757575;
}

// Recent Jobs Section
.recent-jobs-section {
  margin: 24px 0;
}

.jobs-table-card {
  .table-controls {
    display: flex;
    align-items: center;
    margin-bottom: 16px;

    .search-field {
      width: 300px;

      @media (max-width: 768px) {
        width: 100%;
      }
    }
  }

  .table-container {
    overflow-x: auto;

    .jobs-table {
      width: 100%;
      min-width: 800px;

      th {
        font-weight: 600;
        color: rgba(0, 0, 0, 0.87);
      }

      .job-row {
        cursor: pointer;
        transition: background-color 0.2s ease;

        &:hover {
          background: rgba(0, 0, 0, 0.02);
        }
      }

      .job-id {
        font-family: 'Courier New', monospace;
        font-weight: 500;
        color: #3f51b5;
      }

      .registration {
        font-weight: 500;
        text-transform: uppercase;
      }

      .customer-name {
        font-weight: 500;
      }

      .collection-date,
      .location {
        color: rgba(0, 0, 0, 0.7);
      }

      .status-badge {
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 0.75rem;
        font-weight: 500;
        text-transform: capitalize;

        // Status-specific colors
        &.status-unallocated {
          background: #fff3e0;
          color: #f57c00;
        }

        &.status-allocated {
          background: #e3f2fd;
          color: #1976d2;
        }

        &.status-collected {
          background: #f3e5f5;
          color: #7b1fa2;
        }

        &.status-in-transit {
          background: #e8f5e8;
          color: #388e3c;
        }

        &.status-delivered {
          background: #e8f5e8;
          color: #2e7d32;
        }

        &.status-completed {
          background: #e8f5e8;
          color: #1b5e20;
        }

        &.status-default {
          background: #f5f5f5;
          color: #757575;
        }
      }

      .driver-name {
        font-weight: 500;
        color: rgba(0, 0, 0, 0.8);
      }

      .action-buttons {
        display: flex;
        gap: 4px;

        button {
          min-width: 36px;

          mat-icon {
            font-size: 1.2rem;
            width: 1.2rem;
            height: 1.2rem;
          }
        }
      }
    }

    .no-data {
      text-align: center;
      padding: 60px 0;
      color: rgba(0, 0, 0, 0.6);

      mat-icon {
        font-size: 4rem;
        width: 4rem;
        height: 4rem;
        margin-bottom: 16px;
        opacity: 0.3;
      }

      p {
        margin: 0;
        font-size: 1.2rem;
      }
    }
  }
}

// Responsive Design
@media (max-width: 1200px) {
  .dashboard-container {
    padding: 16px;
  }

  .metrics-grid {
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  }

  .charts-grid {
    grid-template-columns: 1fr;
  }
}

@media (max-width: 768px) {
  .dashboard-header {
    .dashboard-title {
      font-size: 1.5rem;
    }
  }

  .metric-card {
    .metric-value {
      font-size: 2rem;
    }
  }

  .delivery-metrics-card {
    .delivery-metrics-grid {
      grid-template-columns: 1fr;
    }

    .delivery-metric {
      .metric-value {
        font-size: 1.5rem;
      }
    }
  }

  .driver-item {
    flex-direction: column;
    align-items: flex-start;
    gap: 12px;

    .driver-status {
      align-self: flex-end;
      margin: 0;
    }

    .driver-actions {
      align-self: flex-end;
    }
  }

  .jobs-table-card {
    .table-controls {
      .search-field {
        width: 100%;
      }
    }

    .table-container {
      .jobs-table {
        font-size: 0.875rem;

        .action-buttons {
          flex-direction: column;
          gap: 2px;

          button {
            min-width: 32px;
            width: 32px;
            height: 32px;

            mat-icon {
              font-size: 1rem;
              width: 1rem;
              height: 1rem;
            }
          }
        }
      }
    }
  }
}

@media (max-width: 480px) {
  .dashboard-container {
    padding: 12px;
  }

  .metrics-grid {
    grid-template-columns: 1fr;
    gap: 16px;
  }

  .metric-card {
    .metric-value {
      font-size: 1.8rem;
    }

    .metric-trend {
      font-size: 0.8rem;
    }
  }

  .chart-card {
    .chart-container {
      height: 200px;
    }
  }

  .driver-item {
    padding: 12px;
  }
}

// Dark Theme Support
@media (prefers-color-scheme: dark) {
  .dashboard-container {
    color: rgba(255, 255, 255, 0.87);
  }

  .loading-container p {
    color: rgba(255, 255, 255, 0.6);
  }

  .metric-card {
    background: #424242;
    color: rgba(255, 255, 255, 0.87);

    mat-card-subtitle {
      color: rgba(255, 255, 255, 0.6);
    }

    .metric-info {
      color: rgba(255, 255, 255, 0.6);
    }
  }

  .delivery-metric {
    background: rgba(255, 255, 255, 0.05);

    .metric-label {
      color: rgba(255, 255, 255, 0.6);
    }

    .metric-value {
      color: rgba(255, 255, 255, 0.87);
    }
  }

  .driver-item {
    background: #424242;
    border-color: rgba(255, 255, 255, 0.12);

    &:hover {
      background: #484848;
      border-color: rgba(63, 81, 181, 0.5);
    }

    .driver-email {
      color: rgba(255, 255, 255, 0.6);
    }

    .driver-jobs {
      color: rgba(255, 255, 255, 0.6);
    }
  }

  .jobs-table {
    background: #424242;

    th {
      color: rgba(255, 255, 255, 0.87);
    }

    .job-row:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .collection-date,
    .location {
      color: rgba(255, 255, 255, 0.7);
    }

    .driver-name {
      color: rgba(255, 255, 255, 0.8);
    }
  }

  .no-drivers,
  .no-data {
    color: rgba(255, 255, 255, 0.6);
  }
}

// Print Styles
@media print {
  .dashboard-container {
    padding: 0;
  }

  .dashboard-header button,
  .driver-actions,
  .action-buttons {
    display: none;
  }

  .metric-card,
  .chart-card,
  .delivery-metrics-card,
  .drivers-card,
  .jobs-table-card {
    break-inside: avoid;
    box-shadow: none;
    border: 1px solid #ddd;
  }

  .chart-container {
    height: 200px;
  }
}

/* Dashboard Styles */
.dashboard-container {
  padding: 20px;
  padding-top: 84px; /* Account for the fixed topbar (64px height + 20px padding) */
  display: flex;
  flex-direction: column;
  gap: 24px;
  height: 100vh;
  overflow-y: auto;
  box-sizing: border-box;
  margin-left: 250px; /* Account for the sidebar width */
}

/* Metric Cards Row */
.metric-cards {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 20px;
  margin-bottom: 20px;
}

/* Expanded Card for Deliveries */
.expanded-card {
  grid-column: span 1;
  @media (min-width: 992px) {
    grid-column: span 2;
  }
}

/* Base Metric Card */
.metric-card {
  padding: 20px;
  background-color: var(--card-background);
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
  display: flex;
  flex-direction: column;
  position: relative;
  overflow: hidden;
  min-height: 130px;

  .metric-title {
    font-size: 1rem;
    font-weight: 600;
    color: var(--text-secondary);
    margin: 0 0 16px;
  }

  .metric-content {
    display: flex;
    align-items: baseline;
    justify-content: space-between;
    margin-top: auto;
  }

  .metric-value {
    font-size: 2.5rem;
    font-weight: 700;
    color: var(--text-primary);
    line-height: 1;
  }

  // Specific styling for different card types
  &.metric-active {
    border-left: 4px solid var(--primary-color);
  }

  &.metric-unallocated {
    border-left: 4px solid var(--warning-color);

    &.metric-red {
      border-left: 4px solid var(--error-color);
      .metric-value {
        color: var(--error-color);
      }
    }
  }

  &.metric-deliveries {
    border-left: 4px solid var(--success-color);
  }
}

/* Trend Indicator Styling */
.trend-indicator {
  display: flex;
  align-items: center;
  padding: 6px 10px;
  border-radius: 20px;
  background-color: rgba(0, 0, 0, 0.05);
  font-weight: 600;
  font-size: 0.85rem;

  .trend-arrow {
    margin-right: 4px;
    font-style: normal;
  }

  &.trend-positive {
    color: var(--success-color);
    background-color: rgba(76, 175, 80, 0.1);
  }

  &.trend-negative {
    color: var(--error-color);
    background-color: rgba(244, 67, 54, 0.1);
  }
}

/* Trend Sections for Delivery Card */
.trend-sections {
  .trend-row {
    display: flex;
    width: 100%;
    height: 100%;
  }

  .trend-section {
    flex: 1;
    padding: 0 5px;

    .period-label {
      font-size: 0.75rem;
      font-weight: 500;
      color: var(--text-secondary);
      margin-bottom: 8px;
      display: block;
    }

    .trend-content {
      display: flex;
      flex-direction: column;
      height: 100%;

      .trend-metrics {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 8px;

        .current-value {
          font-size: 1.75rem;
          font-weight: 600;
          color: var(--text-primary);
        }

        .trend-indicator {
          padding: 3px 8px;
          font-size: 0.7rem;
        }
      }

      .trend-graph {
        height: 50px;
        margin-top: auto;
      }
    }
  }

  .vertical-divider {
    width: 1px;
    background-color: var(--border-color);
    margin: 0 10px;
  }
}

/* Main Content Layout */
.main-content {
  display: flex;
  flex-direction: column;
  gap: 24px;
  width: 100%;
}

/* Jobs Table Container */
.jobs-table-container {
  background: white;
  border-radius: 8px;
  overflow: hidden;
  padding: 20px;

  .header-wrapper {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
  }

  .header-title {
    h2 {
      margin: 0;
      font-size: 1.25rem;
      color: var(--text-primary);
    }

    .subtitle {
      margin: 5px 0 0;
      color: var(--text-secondary);
      font-size: 0.875rem;
    }
  }

  .table-container {
    position: relative;
    overflow-x: auto;
    min-height: 200px;
    max-height: 600px;
  }

  table {
    width: 100%;

    &.loading {
      opacity: 0.6;
    }

    .job-row {
      cursor: pointer;
      transition: background-color 0.2s;

      &:hover {
        background-color: rgba(0, 0, 0, 0.02);
      }
    }

    .job-id {
      font-weight: 500;
      color: var(--primary-color);
    }
  }
}

/* Loading Overlay */
.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  background-color: rgba(255, 255, 255, 0.8);
  z-index: 10;
  backdrop-filter: blur(2px);

  span {
    margin-top: 16px;
    color: var(--text-secondary);
  }
}

/* Empty State */
.empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 40px 20px;
  text-align: center;

  .empty-icon {
    font-size: 48px;
    height: 48px;
    width: 48px;
    color: var(--text-secondary);
    opacity: 0.5;
    margin-bottom: 16px;
  }

  h3 {
    margin: 0 0 8px;
    color: var(--text-primary);
    font-weight: 500;
  }

  p {
    color: var(--text-secondary);
    margin: 0 0 20px;
  }
}

/* Status Chips */
.status-chip {
  padding: 6px 12px;
  border-radius: 16px;
  font-size: 0.75rem;
  font-weight: 500;
  display: inline-block;
  text-align: center;
  white-space: nowrap;

  &.status-loaded {
    background-color: rgba(255, 152, 0, 0.12);
    color: #ff9800;
  }

  &.status-allocated {
    background-color: rgba(33, 150, 243, 0.12);
    color: #2196f3;
  }

  &.status-collected {
    background-color: rgba(156, 39, 176, 0.12);
    color: #9c27b0;
  }

  &.status-delivered {
    background-color: rgba(76, 175, 80, 0.12);
    color: #4caf50;
  }

  &.status-aborted,
  &.status-cancelled {
    background-color: rgba(244, 67, 54, 0.12);
    color: #f44336;
  }

  &.status-default {
    background-color: rgba(158, 158, 158, 0.12);
    color: #9e9e9e;
  }
}

/* Drivers List Section */
.drivers-list-container {
  background: white;
  border-radius: 8px;
  padding: 20px;
  margin-bottom: 24px;

  .header-wrapper {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
  }

  .header-title {
    h2 {
      margin: 0;
      font-size: 1.25rem;
      color: var(--text-primary);
    }
  }

  .driver-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 16px;
    margin-top: 16px;

    .driver-card {
      display: flex;
      align-items: center;
      padding: 16px;
      background-color: #f9f9f9;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;

      &:hover {
        background-color: #f1f1f1;
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
      }
    }
  }

  .driver-avatar {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background-color: var(--primary-color);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 600;
    position: relative;
    margin-right: 16px;
    font-size: 18px;

    .availability-indicator {
      position: absolute;
      bottom: 0;
      right: 0;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 2px solid white;

      &.available {
        background-color: #4caf50;
      }

      &.busy {
        background-color: #ff9800;
      }

      &.on-leave {
        background-color: #9e9e9e;
      }

      &.offline {
        background-color: #f44336;
      }
    }
  }

  .driver-info {
    flex: 1;

    .driver-name {
      font-weight: 500;
      margin-bottom: 4px;
      font-size: 16px;
    }

    .driver-status {
      font-size: 0.8125rem;
      color: var(--text-secondary);

      .job-count {
        font-weight: 600;

        &.low {
          color: #4caf50;
        }

        &.medium {
          color: #ff9800;
        }

        &.high {
          color: #f44336;
        }
      }
    }
  }

  .driver-actions {
    opacity: 0.6;

    &:hover {
      opacity: 1;
    }
  }

  .loading-message {
    text-align: center;
    padding: 20px;
    color: var(--text-secondary);
    font-size: 0.875rem;
  }

  .no-drivers {
    text-align: center;
    padding: 32px 16px;
    color: var(--text-secondary);

    mat-icon {
      font-size: 36px;
      height: 36px;
      width: 36px;
      margin-bottom: 8px;
      opacity: 0.5;
    }

    p {
      margin: 0;
    }
  }
}

/* Status Filter */
.status-filter {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 16px;

  .status-chip {
    cursor: pointer;
    transition: all 0.2s;
    background-color: rgba(0, 0, 0, 0.05);
    color: var(--text-secondary);

    &:hover {
      background-color: rgba(0, 0, 0, 0.08);
    }

    &.active {
      background-color: var(--primary-color);
      color: white;
    }
  }
}

/* Responsive fixes */
@media (max-width: 768px) {
  .dashboard-container {
    margin-left: 60px; /* Account for the collapsed sidebar on mobile (60px width) */
    padding: 15px;
    padding-top: 74px; /* Slightly reduce top padding on mobile */
  }

  .metric-cards {
    grid-template-columns: 1fr;
  }

  .expanded-card {
    grid-column: span 1;
  }

  .trend-sections .trend-row {
    flex-direction: column;
    gap: 20px;
  }

  .trend-sections .vertical-divider {
    display: none;
  }

  .table-container {
    overflow-x: auto;
  }

  .driver-grid {
    grid-template-columns: 1fr !important;
  }
}

/* Handle when sidebar is collapsed or in compact mode */
:host-context(.sidebar-collapsed) .dashboard-container {
  margin-left: 60px;
}


--- ./src/app/pages/dashboard/dashboard.component.ts ---
import { AfterViewInit, Component, OnDestroy, OnInit, ViewChild } from '@angular/core';
import { MatDialog } from '@angular/material/dialog';
import { MatPaginator } from '@angular/material/paginator';
import { MatSort } from '@angular/material/sort';
import { MatTableDataSource } from '@angular/material/table';
import { Router } from '@angular/router';
import * as shape from 'd3-shape';
import { Timestamp } from '@angular/fire/firestore';

import { BehaviorSubject, Subject, Subscription, combineLatest, interval, of, timer } from 'rxjs';
import { catchError, delay, finalize, switchMap, take, takeUntil, timeout } from 'rxjs/operators';

import { ConfirmationDialogComponent } from '../../dialogs/confirmation-dialog.component';
import { DriverSelectionDialogComponent } from '../../dialogs/driver-selection-dialog.component';
import { AuthService } from '../../services/auth.service';
import { JobService } from '../../services/job.service';
import { NotificationService } from '../../services/notification.service';
import { VehicleService } from '../../services/vehicle.service';

import { Job } from '../../interfaces/job-new.interface';
import { UserProfile } from '../../interfaces/user-profile.interface';
import { Vehicle } from '../../interfaces/vehicle.interface';

interface TrendData {
  name: string;
  value: number;
}

interface PeriodMetric {
  current: number;
  change: number;
  increased: boolean;
  data: TrendData[];
}

interface DeliveryMetrics {
  week: PeriodMetric;
  month: PeriodMetric;
  year: PeriodMetric;
}

interface TrendInfo {
  percentChange: number;
  increased: boolean;
}

interface DashboardMetrics {
  activeJobs: number;
  unallocatedJobs: number;
  totalJobs: number;
  completedJobs: number;
  collectedJobs: number;
  deliveredJobs: number;
  activeJobsTrend: TrendInfo;
  unallocatedJobsTrend: TrendInfo;
}

enum DriverStatus {
  AVAILABLE = 'Available',
  BUSY = 'Busy',
  ON_LEAVE = 'On Leave',
  OFFLINE = 'Offline',
}

interface EnhancedDriverInfo {
  profile: UserProfile;
  status: DriverStatus;
  currentJobs: number;
  lastActivity?: Date;
  activeJobs?: Job[];
  isAvailable: boolean;
}

@Component({
  selector: 'app-dashboard',
  templateUrl: './dashboard.component.html',
  styleUrls: ['./dashboard.component.scss'],
  standalone: false,
})
export class DashboardComponent implements OnInit, AfterViewInit, OnDestroy {
  @ViewChild(MatSort) sort!: MatSort;
  @ViewChild(MatPaginator) paginator!: MatPaginator;

  displayedColumns: string[] = ['shippingReference', 'regNumber', 'customerName', 'collectionDate', 'collectionTown', 'deliveryTown', 'status', 'driver', 'actions'];

  jobsDataSource = new MatTableDataSource<Job>([]);
  isLoading = true;
  isLoadingDrivers = true;
  curve = shape.curveLinear;
  jobs: Job[] = [];
  vehicles: Vehicle[] = [];

  // Dashboard refresh interval (5 minutes)
  private readonly REFRESH_INTERVAL = 5 * 60 * 1000;
  private readonly LOADING_TIMEOUT = 10000; // 10 seconds

  // Previous metrics for trend calculation
  private previousJobCounts = {
    active: 0,
    unallocated: 0,
    total: 0,
  };

  // Dashboard metrics
  metrics: DashboardMetrics = {
    activeJobs: 0,
    unallocatedJobs: 0,
    totalJobs: 0,
    completedJobs: 0,
    collectedJobs: 0,
    deliveredJobs: 0,
    activeJobsTrend: {
      percentChange: 0,
      increased: false,
    },
    unallocatedJobsTrend: {
      percentChange: 0,
      increased: false,
    },
  };

  // Track metric changes over time for charts
  private metricHistory = {
    activeJobs: [] as number[],
    unallocatedJobs: [] as number[],
    totalJobs: [] as number[],
  };

  // Delivery metrics
  deliveryMetrics: DeliveryMetrics = {
    week: {
      current: 0,
      change: 0,
      increased: false,
      data: [],
    },
    month: {
      current: 0,
      change: 0,
      increased: false,
      data: [],
    },
    year: {
      current: 0,
      change: 0,
      increased: false,
      data: [],
    },
  };

  // Chart data
  jobStatusChartData: any[] = [];
  deliveryTrendData: any[] = [];

  // Using string-based color schemes (most reliable approach)
  pieChartColorScheme: string = 'cool';
  lineChartColorScheme: string = 'cool';

  // Driver-related properties
  allDrivers: EnhancedDriverInfo[] = [];
  filteredDrivers: EnhancedDriverInfo[] = [];
  selectedDriverStatus: string = 'All';
  driverStatusOptions = ['All', 'Available', 'Busy', 'On Leave', 'Offline'];

  // Data loading states
  private jobsLoaded$ = new BehaviorSubject<boolean>(false);
  private driversLoaded$ = new BehaviorSubject<boolean>(false);
  private metricsLoaded$ = new BehaviorSubject<boolean>(false);
  private vehiclesLoaded$ = new BehaviorSubject<boolean>(false);

  // Cleanup
  private destroy$ = new Subject<void>();
  private subscriptions: Subscription[] = [];

  constructor(
    private router: Router,
    private jobService: JobService,
    private authService: AuthService,
    private vehicleService: VehicleService,
    private notificationService: NotificationService,
    private dialog: MatDialog
  ) {
    this.jobsDataSource = new MatTableDataSource<Job>([]);
  }

  ngOnInit(): void {
    console.log('Dashboard initializing...');

    // Force loading to complete after timeout
    this.setupLoadingTimeout();
    this.setupDataSubscriptions();
    this.setupCustomSort();

    // Initialize with default data first
    this.initializeDefaultData();

    // Then try to load real data
    this.initDashboardData();
    this.setupRefreshInterval();
  }

  ngAfterViewInit(): void {
    if (this.sort && this.paginator) {
      this.jobsDataSource.sort = this.sort;
      this.jobsDataSource.paginator = this.paginator;
    }
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }

  private setupLoadingTimeout(): void {
    timer(this.LOADING_TIMEOUT)
      .pipe(takeUntil(this.destroy$))
      .subscribe(() => {
        if (this.isLoading) {
          console.warn('Dashboard loading timeout - forcing completion');
          this.forceLoadingComplete();
        }
      });
  }

  private forceLoadingComplete(): void {
    this.isLoading = false;
    this.isLoadingDrivers = false;
    this.jobsLoaded$.next(true);
    this.driversLoaded$.next(true);
    this.metricsLoaded$.next(true);
    this.vehiclesLoaded$.next(true);

    this.notificationService.addNotification({
      type: 'warning',
      title: 'Loading Timeout',
      message: 'Dashboard took longer than expected to load. Some data may be incomplete.',
    });
  }

  private initializeDefaultData(): void {
    console.log('Initializing default dashboard data');

    // Set default metrics
    this.metrics = {
      activeJobs: 0,
      unallocatedJobs: 0,
      totalJobs: 0,
      completedJobs: 0,
      collectedJobs: 0,
      deliveredJobs: 0,
      activeJobsTrend: { percentChange: 0, increased: false },
      unallocatedJobsTrend: { percentChange: 0, increased: false },
    };

    // Set default delivery metrics
    this.deliveryMetrics = {
      week: { current: 0, change: 0, increased: false, data: [] },
      month: { current: 0, change: 0, increased: false, data: [] },
      year: { current: 0, change: 0, increased: false, data: [] },
    };

    // Set default chart data
    this.jobStatusChartData = [{ name: 'No Data Available', value: 1 }];

    this.deliveryTrendData = [];

    // Initialize empty arrays
    this.jobs = [];
    this.vehicles = [];
    this.allDrivers = [];
    this.filteredDrivers = [];

    // Set data source
    this.jobsDataSource.data = [];
  }

  private setupDataSubscriptions(): void {
    // Monitor all loading states with detailed logging
    const dataLoadingSubscription = combineLatest([this.jobsLoaded$, this.driversLoaded$, this.metricsLoaded$, this.vehiclesLoaded$]).subscribe(
      ([jobsLoaded, driversLoaded, metricsLoaded, vehiclesLoaded]) => {
        this.isLoading = !(jobsLoaded && metricsLoaded && vehiclesLoaded);
        this.isLoadingDrivers = !driversLoaded;

        if (!this.isLoading) {
          console.log('Dashboard loading completed!');
        }
      }
    );

    this.subscriptions.push(dataLoadingSubscription);
  }

  private setupCustomSort(): void {
    this.jobsDataSource.sortingDataAccessor = (item, property) => {
      switch (property) {
        case 'timestamp':
          return item['timestamp'] ? new Date(item['timestamp']).getTime() : 0;
        case 'collectionDate':
          return item['collectionDate'] ? new Date(item['collectionDate']).getTime() : 0;
        case 'createdAt':
          return item.createdAt ? new Date(item.createdAt).getTime() : 0;
        case 'updatedAt':
          return item.updatedAt ? new Date(item.updatedAt).getTime() : 0;
        default:
          const value = item[property as keyof Job];
          return typeof value === 'string' ? value.toLowerCase() : value;
      }
    };
  }

  private setupRefreshInterval(): void {
    const refreshSub = interval(this.REFRESH_INTERVAL)
      .pipe(takeUntil(this.destroy$))
      .subscribe(() => {
        this.refreshDashboardData();
      });

    this.subscriptions.push(refreshSub);
  }

  private initDashboardData(): void {
    this.storePreviousMetrics();
    this.loadJobs();
    this.loadDriversWithJobs();
    this.loadVehicles();
    this.loadDeliveryMetrics();
    this.loadDashboardStats();
  }

  refreshDashboardData(): void {
    this.storePreviousMetrics();

    this.notificationService.addNotification({
      type: 'info',
      title: 'Dashboard Refreshing',
      message: 'Dashboard data is being refreshed...',
    });

    // Reset loading states
    this.jobsLoaded$.next(false);
    this.driversLoaded$.next(false);
    this.metricsLoaded$.next(false);
    this.vehiclesLoaded$.next(false);

    // Reload all data
    this.initDashboardData();
  }

  private storePreviousMetrics(): void {
    this.previousJobCounts = {
      active: this.metrics.activeJobs,
      unallocated: this.metrics.unallocatedJobs,
      total: this.metrics.totalJobs,
    };

    // Add current metrics to history for charts
    if (this.metrics.totalJobs > 0) {
      this.metricHistory.activeJobs.push(this.metrics.activeJobs);
      this.metricHistory.unallocatedJobs.push(this.metrics.unallocatedJobs);
      this.metricHistory.totalJobs.push(this.metrics.totalJobs);

      // Keep only the last 14 data points for trends
      if (this.metricHistory.activeJobs.length > 14) {
        this.metricHistory.activeJobs.shift();
        this.metricHistory.unallocatedJobs.shift();
        this.metricHistory.totalJobs.shift();
      }
    }
  }

  private loadJobs(): void {
    const jobsSub = this.jobService
      .getRecentJobs(50)
      .pipe(
        timeout(8000),
        takeUntil(this.destroy$),
        catchError((error) => {
          console.error('Error loading jobs:', error);
          this.notificationService.addNotification({
            type: 'error',
            title: 'Error Loading Jobs',
            message: 'There was a problem loading job data from the database.',
          });
          return of([]);
        }),
        finalize(() => {
          this.jobsLoaded$.next(true);
        })
      )
      .subscribe({
        next: (jobs: Job[]) => {
          this.jobs = jobs;
          console.log(this.jobs);
          this.jobsDataSource.data = jobs;
          this.calculateJobMetrics(jobs);
          this.updateJobStatusChart(jobs);
        },
        error: (error: any) => {
          console.error('Jobs subscription error:', error);
          this.jobsLoaded$.next(true);
        },
      });

    this.subscriptions.push(jobsSub);
  }

  private loadDashboardStats(): void {
    const statsSub = this.jobService
      .getDashboardStats()
      .pipe(
        timeout(8000),
        takeUntil(this.destroy$),
        catchError((error) => {
          console.error('Error loading dashboard stats:', error);
          return of({
            unallocated: 0,
            allocated: 0,
            collected: 0,
            delivered: 0,
            completed: 0,
            total: 0,
            active: 0,
          });
        })
      )
      .subscribe({
        next: (stats: any) => {
          this.updateMetricsFromStats(stats);
        },
        error: (error: any) => {
          console.error('Dashboard stats error:', error);
        },
      });

    this.subscriptions.push(statsSub);
  }

  private loadVehicles(): void {
    // Simplified vehicle loading to avoid type conflicts
    const vehiclesSub = of([] as any[])
      .pipe(
        delay(100), // Small delay to prevent race conditions
        finalize(() => {
          this.vehiclesLoaded$.next(true);
        })
      )
      .subscribe({
        next: (vehicles) => {
          this.vehicles = vehicles;
        },
        error: (error: any) => {
          console.error('Vehicles subscription error:', error);
          this.vehicles = [];
          this.vehiclesLoaded$.next(true);
        },
      });

    this.subscriptions.push(vehiclesSub);

    // Optionally try to load real vehicles in the background
    this.loadVehiclesBackground();
  }

  private loadVehiclesBackground(): void {
    // Try to load vehicles without blocking the dashboard
    this.vehicleService.vehicles$
      .pipe(
        take(1),
        timeout(5000),
        catchError((error) => {
          console.error('Background vehicle loading failed:', error);
          return of([]);
        })
      )
      .subscribe({
        next: (vehicles: any[]) => {
          if (vehicles && vehicles.length > 0) {
            this.vehicles = vehicles;
          }
        },
        error: (error) => {
          console.error('Background vehicle error:', error);
        },
      });
  }

  private loadDriversWithJobs(): void {
    const driversSub = this.authService
      .getDrivers()
      .pipe(
        timeout(8000),
        takeUntil(this.destroy$),
        switchMap((drivers) => {
          if (drivers.length === 0) {
            return of([]);
          }

          // Create enhanced driver info with empty jobs for now
          const enhancedDrivers = drivers.map((driver) => this.createEnhancedDriverInfo(driver, []));

          return of(enhancedDrivers);
        }),
        catchError((error) => {
          console.error('Error loading drivers with jobs:', error);
          return of([]);
        }),
        finalize(() => {
          this.driversLoaded$.next(true);
          console.log('Drivers loading completed');
        })
      )
      .subscribe({
        next: (enhancedDrivers: EnhancedDriverInfo[]) => {
          console.log('Drivers loaded:', enhancedDrivers.length);
          this.allDrivers = enhancedDrivers;
          this.filterDrivers();
        },
        error: (error: any) => {
          console.error('Drivers subscription error:', error);
          this.driversLoaded$.next(true);
        },
      });

    this.subscriptions.push(driversSub);
  }

  private loadDeliveryMetrics(): void {
    // Simplified delivery metrics loading
    const deliveriesSub = timer(200)
      .pipe(
        switchMap(() => of([])), // Return empty for now
        finalize(() => {
          this.metricsLoaded$.next(true);
          console.log('Delivery metrics loading completed');
        })
      )
      .subscribe({
        next: (deliveryJobs) => {
          console.log('Delivery metrics loaded');
          this.initializeEmptyDeliveryMetrics();
        },
        error: (error: any) => {
          console.error('Delivery metrics error:', error);
          this.metricsLoaded$.next(true);
        },
      });

    this.subscriptions.push(deliveriesSub);
  }

  private createEnhancedDriverInfo(driver: UserProfile, jobs: Job[]): EnhancedDriverInfo {
    const activeJobs = jobs.filter((job) => ['allocated', 'collected', 'in-transit'].includes(job.status));

    // Ensure we always get a proper boolean value
    const driverIsActive = Boolean(driver.isActive);
    const hasNoActiveJobs = activeJobs.length === 0;
    const isAvailable = hasNoActiveJobs && driverIsActive;

    // Determine status based on job load and last activity
    let status: DriverStatus;
    if (!driverIsActive) {
      status = DriverStatus.OFFLINE;
    } else if (activeJobs.length > 0) {
      status = DriverStatus.BUSY;
    } else {
      status = DriverStatus.AVAILABLE;
    }

    return {
      profile: driver,
      status,
      currentJobs: activeJobs.length,
      activeJobs,
      isAvailable, // Now guaranteed to be boolean
      lastActivity: this.calculateLastActivity(jobs),
    };
  }

  private calculateLastActivity(jobs: Job[]): Date | undefined {
    if (jobs.length === 0) return undefined;

    return jobs.reduce((latest, job) => {
      const jobUpdate = job.updatedAt || job.createdAt;
      if (!jobUpdate) return latest;

      const jobDate = new Date(jobUpdate);
      return !latest || jobDate > latest ? jobDate : latest;
    }, undefined as Date | undefined);
  }

  private calculateJobMetrics(jobs: Job[]): void {
    const activeStatuses = ['unallocated', 'allocated', 'collected', 'in-transit'];
    const completedStatuses = ['delivered', 'completed'];

    const activeJobs = jobs.filter((job) => activeStatuses.includes(job.status));
    const unallocatedJobs = jobs.filter((job) => job.status === 'unallocated');
    const collectedJobs = jobs.filter((job) => job.status === 'collected');
    const deliveredJobs = jobs.filter((job) => job.status === 'delivered');
    const completedJobs = jobs.filter((job) => completedStatuses.includes(job.status));

    // Calculate trends
    const activeJobsTrend = this.calculateTrend(activeJobs.length, this.previousJobCounts.active);
    const unallocatedJobsTrend = this.calculateTrend(unallocatedJobs.length, this.previousJobCounts.unallocated);

    this.metrics = {
      activeJobs: activeJobs.length,
      unallocatedJobs: unallocatedJobs.length,
      totalJobs: jobs.length,
      completedJobs: completedJobs.length,
      collectedJobs: collectedJobs.length,
      deliveredJobs: deliveredJobs.length,
      activeJobsTrend,
      unallocatedJobsTrend,
    };
  }

  private updateMetricsFromStats(stats: any): void {
    const activeJobsTrend = this.calculateTrend(stats.active, this.previousJobCounts.active);
    const unallocatedJobsTrend = this.calculateTrend(stats.unallocated, this.previousJobCounts.unallocated);

    this.metrics = {
      ...this.metrics,
      activeJobs: stats.active,
      unallocatedJobs: stats.unallocated,
      totalJobs: stats.total,
      completedJobs: stats.completed,
      collectedJobs: stats.collected,
      deliveredJobs: stats.delivered,
      activeJobsTrend,
      unallocatedJobsTrend,
    };
  }

  private calculateTrend(current: number, previous: number): TrendInfo {
    if (previous === 0) {
      return {
        percentChange: current > 0 ? 100 : 0,
        increased: current > 0,
      };
    }

    const percentChange = ((current - previous) / previous) * 100;
    return {
      percentChange: Math.abs(percentChange),
      increased: percentChange > 0,
    };
  }

  private updateJobStatusChart(jobs: Job[]): void {
    if (jobs.length === 0) {
      this.jobStatusChartData = [{ name: 'No Data', value: 1 }];
      return;
    }

    const statusCounts = jobs.reduce((acc, job) => {
      acc[job.status] = (acc[job.status] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    this.jobStatusChartData = Object.entries(statusCounts).map(([status, count]) => ({
      name: this.formatStatusName(status),
      value: count,
    }));
  }

  private formatStatusName(status: string): string {
    return status
      .split('-')
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }

  private initializeEmptyDeliveryMetrics(): void {
    this.deliveryMetrics = {
      week: { current: 0, change: 0, increased: false, data: [] },
      month: { current: 0, change: 0, increased: false, data: [] },
      year: { current: 0, change: 0, increased: false, data: [] },
    };
  }

  // Filter and search methods
  filterDrivers(): void {
    if (this.selectedDriverStatus === 'All') {
      this.filteredDrivers = this.allDrivers;
    } else {
      this.filteredDrivers = this.allDrivers.filter((driver) => driver.status === this.selectedDriverStatus);
    }
  }

  onDriverStatusChange(): void {
    this.filterDrivers();
  }

  applyFilter(event: Event): void {
    const filterValue = (event.target as HTMLInputElement).value;
    this.jobsDataSource.filter = filterValue.trim().toLowerCase();

    if (this.jobsDataSource.paginator) {
      this.jobsDataSource.paginator.firstPage();
    }
  }

  // Navigation methods
  viewJob(job: Job): void {
    this.router.navigate(['/jobs', job.id]);
  }

  editJob(job: Job, event?: Event): void {
    if (event) {
      event.stopPropagation();
    }
    this.router.navigate(['/jobs', job.id, 'edit']);
  }

  viewDriver(driver: UserProfile): void {
    this.router.navigate(['/drivers', driver.id]);
  }

  // Action methods
  allocateJob(job: Job): void {
    const dialogRef = this.dialog.open(DriverSelectionDialogComponent, {
      width: '500px',
      data: { job },
    });

    dialogRef.afterClosed().subscribe((result) => {
      if (result) {
        this.jobService.allocateJobToDriver(job.id, result.driverId).subscribe({
          next: () => {
            this.notificationService.addNotification({
              type: 'success',
              title: 'Job Allocated',
              message: `Job ${job.id} has been allocated successfully.`,
            });
          },
          error: (error: any) => {
            this.notificationService.addNotification({
              type: 'error',
              title: 'Allocation Failed',
              message: `Failed to allocate job: ${error.message}`,
            });
          },
        });
      }
    });
  }

  deleteJob(job: Job): void {
    const dialogRef = this.dialog.open(ConfirmationDialogComponent, {
      width: '400px',
      data: {
        title: 'Delete Job',
        message: `Are you sure you want to delete job ${job.id}? This action cannot be undone.`,
        confirmText: 'Delete',
        cancelText: 'Cancel',
      },
    });

    dialogRef.afterClosed().subscribe((result) => {
      if (result) {
        this.jobService.deleteJob(job.id).subscribe({
          next: () => {
            this.notificationService.addNotification({
              type: 'success',
              title: 'Job Deleted',
              message: `Job ${job.id} has been deleted successfully.`,
            });
          },
          error: (error: any) => {
            this.notificationService.addNotification({
              type: 'error',
              title: 'Delete Failed',
              message: `Failed to delete job: ${error.message}`,
            });
          },
        });
      }
    });
  }

  // Utility methods
  getStatusClass(status: string): string {
    const statusMap: Record<string, string> = {
      unallocated: 'status-unallocated',
      allocated: 'status-allocated',
      collected: 'status-collected',
      'in-transit': 'status-in-transit',
      delivered: 'status-delivered',
      completed: 'status-completed',
    };
    return statusMap[status] || 'status-default';
  }

  getDriverStatusClass(status: DriverStatus): string {
    const statusMap: Record<DriverStatus, string> = {
      [DriverStatus.AVAILABLE]: 'driver-available',
      [DriverStatus.BUSY]: 'driver-busy',
      [DriverStatus.ON_LEAVE]: 'driver-on-leave',
      [DriverStatus.OFFLINE]: 'driver-offline',
    };
    return statusMap[status] || 'driver-default';
  }

  formatDate(date: Date | string | undefined): string {
    if (!date) return 'N/A';

    const dateObj = typeof date === 'string' ? new Date(date) : date;
    return dateObj.toLocaleDateString('en-GB', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
    });
  }

  formatDateTime(date: Date | string | undefined): string {
    if (!date) return 'N/A';

    const dateObj = typeof date === 'string' ? new Date(date) : date;
    return dateObj.toLocaleString('en-GB', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  }

  getDriverName(driverId: string | null): string {
    if (!driverId) return 'Unassigned';

    const driver = this.allDrivers.find((d) => d.profile.id === driverId);
    return driver ? driver.profile.name : 'Unknown Driver';
  }

  createNewJob(): void {
    this.router.navigate(['/jobs/new']);
  }

  // View driver details
  viewDriverDetails(driver: EnhancedDriverInfo): void {
    this.router.navigate(['/drivers', driver.profile.id]);
  }

  viewJobDetails(job: Job): void {
    this.router.navigate(['/jobs', job.id]);
  }

  // Assign job to driver dialog
  assignJob(job: Job, event?: Event): void {
    if (event) {
      event.stopPropagation();
    }

    // First open confirmation dialog
    const confirmDialogRef = this.dialog.open(ConfirmationDialogComponent, {
      width: '400px',
      data: {
        title: 'Assign Job',
        message: `Do you want to assign job ${job.id}?`,
        confirmText: 'Proceed',
        cancelText: 'Cancel',
        icon: 'assignment_ind',
      },
    });

    confirmDialogRef.afterClosed().subscribe((result) => {
      if (result) {
        // Open driver selection dialog
        this.openDriverSelectionDialog(job);
      }
    });
  }

  private openDriverSelectionDialog(job: Job): void {
    const dialogRef = this.dialog.open(DriverSelectionDialogComponent, {
      width: '500px',
      data: {
        jobId: job.id,
        jobTitle: `${job['make'] || ''} ${job['model'] || ''} ${job['registration'] ? '(' + job['registration'] + ')' : ''}`,
      },
    });

    dialogRef.afterClosed().subscribe((driver) => {
      if (driver) {
        this.isLoading = true;

        // Assign driver to job
        this.jobService
          .updateJob(job.id, {
            driverId: driver.id,
            status: 'allocated',
          })
          .pipe(finalize(() => (this.isLoading = false)))
          .subscribe({
            next: () => {
              this.notificationService.addNotification({
                type: 'success',
                title: 'Job Assigned',
                message: `Job ${job.id} has been assigned to ${driver.name}`,
              });

              // Refresh job data
              this.loadJobs();
              this.loadDriversWithJobs();
            },
            error: (error) => {
              console.error('Error assigning job:', error);
              this.notificationService.addNotification({
                type: 'error',
                title: 'Assignment Failed',
                message: 'Failed to assign job to driver.',
              });
            },
          });
      }
    });
  }

  getJobCountClass(count: number): string {
    if (count > 2) return 'high';
    if (count > 0) return 'medium';
    return 'low';
  }

  setDriverStatusFilter(status: string): void {
    this.selectedDriverStatus = status;
    this.filterDrivers();
  }

  // Get initials for driver avatar
  getDriverInitials(driver: EnhancedDriverInfo): string {
    const name = driver.profile.name || '';
    if (!name) return '?';

    const nameParts = name.split(' ');
    if (nameParts.length === 1) {
      return nameParts[0].charAt(0).toUpperCase();
    }

    return (nameParts[0].charAt(0) + nameParts[nameParts.length - 1].charAt(0)).toUpperCase();
  }
}


--- ./src/app/pages/vehicles/vehicle-list/vehicle-list.component.scss ---
// Main container styles
:host {
  display: block;
  padding: 24px;
  background-color: #f5f5f5;
  min-height: 100vh;
  margin-left: 250px; /* Account for sidebar */
  padding-top: 88px; /* Account for topbar height (64px) + padding */
}

// Card styles
.main-card {
  margin-bottom: 24px;
  background-color: white;
  border-radius: 8px;
}

// Header Section
.header-wrapper {
  padding: 24px 24px 0;
}

.header-title h1 {
  margin: 0;
  font-size: 24px;
  font-weight: 600;
  color: var(--primary-color);
}

.header-title .subtitle {
  margin: 4px 0 0;
  color: rgba(0, 0, 0, 0.6);
  font-size: 14px;
}

// Filters and Actions Section
.filters-actions-wrapper {
  padding: 24px;
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 24px;
  border-bottom: 1px solid rgba(0, 0, 0, 0.12);
}

.filters-section {
  display: flex;
  flex: 1;
  gap: 16px;
  align-items: flex-start;
  flex-direction: column;
}

.search-field {
  width: 100%;
  max-width: 400px;
}

.search-field ::ng-deep .mat-mdc-text-field-wrapper {
  background-color: #f8f9fa;
}

.search-field input {
  height: 20px;
}

.filters-group {
  display: flex;
  flex-wrap: wrap;
  gap: 16px;
  width: 100%;
}

.filters-group mat-form-field {
  flex: 1;
  min-width: 150px;
}

.actions-group {
  display: flex;
  gap: 12px;
  margin-left: auto;
}

.refresh-button {
  height: 40px;
  background-color: #f5f5f5;
  color: #333;
  border: 1px solid #ddd;
}

.refresh-button:hover {
  background-color: #e0e0e0;
}

.create-button {
  height: 40px;
  padding: 0 20px;
}

.actions-group .mat-icon {
  margin-right: 8px;
}

// Table Container
.table-container {
  position: relative;
  min-height: 400px;
  overflow: auto;
}

// Scrollbar styling
.table-container::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

.table-container::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 4px;
}

.table-container::-webkit-scrollbar-thumb {
  background: #ddd;
  border-radius: 4px;
}

.table-container::-webkit-scrollbar-thumb:hover {
  background: #ccc;
}

// Loading Overlay
.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.9);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  gap: 16px;
}

.loading-overlay span {
  color: rgba(0, 0, 0, 0.6);
  font-size: 14px;
}

// Table Styles
table {
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
}

table.loading {
  opacity: 0.6;
}

// Header Styles
.mat-mdc-header-row {
  background-color: #f8f9fa;
  min-height: 48px;
  border-bottom: 1px solid rgba(0, 0, 0, 0.12);
}

.mat-mdc-header-cell {
  color: rgba(0, 0, 0, 0.6);
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  padding: 0 16px;
  white-space: nowrap;
  border-bottom: 1px solid rgba(0, 0, 0, 0.12);
}

.mat-mdc-header-cell:first-of-type {
  padding-left: 24px;
}

.mat-mdc-header-cell:last-of-type {
  padding-right: 24px;
}

// Sort header styling
.mat-sort-header-container {
  justify-content: flex-start;
}

.mat-sort-header-arrow {
  color: rgba(0, 0, 0, 0.38);
}

// Cell Styles
.mat-mdc-cell {
  font-size: 14px;
  color: rgba(0, 0, 0, 0.87);
  padding: 0 16px;
  border-bottom: 1px solid rgba(0, 0, 0, 0.08);
  height: 52px;
}

.mat-mdc-cell:first-of-type {
  padding-left: 24px;
}

.mat-mdc-cell:last-of-type {
  padding-right: 24px;
}

// Row Styles
.vehicle-row {
  min-height: 52px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.vehicle-row:hover {
  background-color: #fafafa;
}

.vehicle-row:hover .registration {
  color: var(--secondary-color);
}

.vehicle-row:active {
  background-color: #e3f2fd;
}

// Column Styles
.registration {
  font-weight: 600;
  color: var(--primary-color);
  transition: color 0.2s ease;
}

.jobs-count {
  font-weight: 600;
  color: #0288d1;
}

.color-chip {
  display: inline-block;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  margin-right: 8px;
  vertical-align: middle;
  border: 1px solid rgba(0, 0, 0, 0.1);
}

.mat-column-actions {
  width: 48px;
  padding-left: 0;
}

.mat-column-registration {
  width: 120px;
}

.mat-column-lastProcessedDate {
  width: 120px;
}

.mat-column-jobCount {
  width: 80px;
  text-align: center;
}

// Empty State
.empty-state {
  text-align: center;
  padding: 48px 24px;
}

.empty-state .empty-icon {
  font-size: 48px;
  width: 48px;
  height: 48px;
  color: rgba(0, 0, 0, 0.38);
  margin-bottom: 16px;
}

.empty-state h3 {
  margin: 0 0 8px;
  font-size: 16px;
  color: rgba(0, 0, 0, 0.87);
}

.empty-state p {
  margin: 0 0 24px;
  color: rgba(0, 0, 0, 0.6);
  font-size: 14px;
}

.empty-state button {
  min-width: 160px;
}

// Responsive Design
@media screen and (max-width: 1200px) {
  .filters-actions-wrapper {
    flex-direction: column;
  }

  .actions-group {
    width: 100%;
    justify-content: flex-end;
  }
}

@media screen and (max-width: 960px) {
  :host {
    padding: 16px;
    padding-top: 80px;
  }

  .actions-group {
    width: 100%;
  }

  .actions-group button {
    flex: 1;
  }

  .mat-column-color,
  .mat-column-type {
    display: none;
  }
}

@media screen and (max-width: 768px) {
  :host {
    margin-left: 60px; /* Collapsed sidebar width */
  }
}

@media screen and (max-width: 600px) {
  :host {
    padding: 8px;
    padding-top: 72px;
  }

  .header-wrapper {
    padding: 16px 16px 0;
  }

  .filters-actions-wrapper {
    padding: 16px;
  }

  .filters-group {
    flex-direction: column;
  }

  .filters-group mat-form-field {
    width: 100%;
  }

  .actions-group {
    flex-direction: column;
    gap: 8px;
  }

  // Hide less important columns on mobile
  .mat-column-model,
  .mat-column-lastProcessedDate {
    display: none;
  }
}

// Print Styles
@media print {
  :host {
    padding: 0;
    background: white;
    margin-left: 0; // No sidebar in print
    padding-top: 0; // No topbar in print
  }

  .mat-mdc-card {
    box-shadow: none !important;
  }

  .filters-actions-wrapper,
  .mat-mdc-paginator,
  .mat-column-actions {
    display: none !important;
  }

  .table-container {
    overflow: visible;
  }

  .vehicle-row {
    break-inside: avoid;
  }
}


--- ./src/app/pages/vehicles/vehicle-list/vehicle-list.component.html ---
<mat-card class="mat-elevation-z3 main-card">
  <!-- Header -->
  <div class="header-wrapper">
    <div class="header-title">
      <h1>Vehicles</h1>
      <p class="subtitle">{{ dataSource.filteredData.length }} total vehicles</p>
    </div>
  </div>

  <!-- Filters and Actions Bar -->
  <div class="filters-actions-wrapper">
    <div class="filters-section">
      <!-- Search Bar -->
      <mat-form-field appearance="outline" class="search-field">
        <mat-label>Search vehicles</mat-label>
        <input matInput [formControl]="searchControl" placeholder="Search by registration, make, model, or chassis" />
        <mat-icon matSuffix>search</mat-icon>
      </mat-form-field>

      <div class="filters-group" [formGroup]="filterForm">
        <mat-form-field appearance="outline">
          <mat-label>Make</mat-label>
          <mat-select formControlName="make">
            <mat-option value="All">All</mat-option>
            <mat-option *ngFor="let make of makes" [value]="make">
              {{ make }}
            </mat-option>
          </mat-select>
        </mat-form-field>

        <mat-form-field appearance="outline">
          <mat-label>Type</mat-label>
          <mat-select formControlName="type">
            <mat-option value="All">All</mat-option>
            <mat-option *ngFor="let type of vehicleTypes" [value]="type">
              {{ type }}
            </mat-option>
          </mat-select>
        </mat-form-field>

        <mat-form-field appearance="outline">
          <mat-label>Color</mat-label>
          <mat-select formControlName="color">
            <mat-option value="All">All</mat-option>
            <mat-option *ngFor="let color of colors" [value]="color">
              {{ color }}
            </mat-option>
          </mat-select>
        </mat-form-field>
      </div>
    </div>

    <div class="actions-group">
      <button mat-flat-button color="primary" (click)="refreshVehicles()" class="refresh-button" matTooltip="Refresh vehicles list">
        <mat-icon>refresh</mat-icon>
      </button>
      <button mat-flat-button color="primary" (click)="createNewVehicle()" class="create-button" *ngIf="hasCreatePermission">
        <mat-icon>add</mat-icon>
        New Vehicle
      </button>
    </div>
  </div>

  <!-- Table Container -->
  <div class="table-container">
    <!-- Loading Overlay -->
    <div class="loading-overlay" *ngIf="isLoading">
      <mat-spinner diameter="40"></mat-spinner>
      <span>Loading vehicles...</span>
    </div>

    <!-- Table -->
    <table mat-table [dataSource]="dataSource" matSort matSortActive="lastProcessedDate" matSortDirection="desc" [class.loading]="isLoading">
      <!-- Registration Column -->
      <ng-container matColumnDef="registration">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Registration</th>
        <td mat-cell *matCellDef="let vehicle" class="registration">
          {{ vehicle.registration }}
        </td>
      </ng-container>

      <!-- Make Column -->
      <ng-container matColumnDef="make">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Make</th>
        <td mat-cell *matCellDef="let vehicle">{{ vehicle.makeName }}</td>
      </ng-container>

      <!-- Model Column -->
      <ng-container matColumnDef="model">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Model</th>
        <td mat-cell *matCellDef="let vehicle">{{ vehicle.modelName }}</td>
      </ng-container>

      <!-- Type Column -->
      <ng-container matColumnDef="type">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Type</th>
        <td mat-cell *matCellDef="let vehicle">{{ vehicle.type }}</td>
      </ng-container>

      <!-- Color Column -->
      <ng-container matColumnDef="color">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Color</th>
        <td mat-cell *matCellDef="let vehicle">
          <span class="color-chip" [style.background]="getColorHex(vehicle.color)"></span>
          {{ vehicle.color }}
        </td>
      </ng-container>

      <!-- Last Processed Date Column -->
      <ng-container matColumnDef="lastProcessedDate">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Last Job</th>
        <td mat-cell *matCellDef="let vehicle">
          {{ formatDate(vehicle.lastProcessedDate) }}
        </td>
      </ng-container>

      <!-- Job Count Column -->
      <ng-container matColumnDef="jobCount">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Jobs</th>
        <td mat-cell *matCellDef="let vehicle" class="jobs-count">
          {{ vehicle.jobCount }}
        </td>
      </ng-container>

      <!-- Actions Column -->
      <ng-container matColumnDef="actions">
        <th mat-header-cell *matHeaderCellDef></th>
        <td mat-cell *matCellDef="let vehicle">
          <button mat-icon-button [matMenuTriggerFor]="menu">
            <mat-icon>more_vert</mat-icon>
          </button>
          <mat-menu #menu="matMenu" xPosition="before">
            <button mat-menu-item (click)="viewVehicleDetails(vehicle)">
              <mat-icon>visibility</mat-icon>
              <span>View Details</span>
            </button>
            <button mat-menu-item (click)="editVehicle(vehicle, $event)" *ngIf="hasEditPermission">
              <mat-icon>edit</mat-icon>
              <span>Edit</span>
            </button>
            <button mat-menu-item (click)="viewVehicleJobs(vehicle, $event)">
              <mat-icon>work</mat-icon>
              <span>View Jobs</span>
            </button>
          </mat-menu>
        </td>
      </ng-container>

      <!-- Header and Data Rows -->
      <tr mat-header-row *matHeaderRowDef="displayedColumns; sticky: true"></tr>
      <tr mat-row *matRowDef="let row; columns: displayedColumns" (click)="viewVehicleDetails(row)" class="vehicle-row"></tr>
    </table>

    <!-- Empty State -->
    <div class="empty-state" *ngIf="!isLoading && dataSource.filteredData.length === 0">
      <mat-icon class="empty-icon">directions_car</mat-icon>
      <h3>No vehicles found</h3>
      <p>Try adjusting your filters or add a new vehicle</p>
      <button mat-flat-button color="primary" (click)="createNewVehicle()" *ngIf="hasCreatePermission">
        <mat-icon>add</mat-icon>
        New Vehicle
      </button>
    </div>
  </div>

  <!-- Paginator -->
  <mat-paginator [length]="dataSource.filteredData.length" [pageSize]="25" [pageSizeOptions]="[10, 25, 50, 100]" showFirstLastButtons> </mat-paginator>
</mat-card>


--- ./src/app/pages/vehicles/vehicle-list/vehicle-list.component.ts ---
import { Component, OnInit, ViewChild, AfterViewInit, OnDestroy } from '@angular/core';
import { Router } from '@angular/router';
import { MatTableDataSource } from '@angular/material/table';
import { MatSort } from '@angular/material/sort';
import { MatPaginator } from '@angular/material/paginator';
import { FormControl, FormGroup } from '@angular/forms';
import { Subscription } from 'rxjs';
import { debounceTime, distinctUntilChanged } from 'rxjs/operators';
import { MatSnackBar } from '@angular/material/snack-bar';
import { AuthService } from '../../../services/auth.service';
import { VehicleService, Vehicle } from '../../../services/vehicle.service';

@Component({
  selector: 'app-vehicle-list',
  templateUrl: './vehicle-list.component.html',
  styleUrls: ['./vehicle-list.component.scss'],
  standalone: false,
})
export class VehicleListComponent implements OnInit, AfterViewInit, OnDestroy {
  displayedColumns: string[] = ['registration', 'make', 'model', 'type', 'color', 'lastProcessedDate', 'jobCount', 'actions'];

  isLoading = false;
  dataSource = new MatTableDataSource<Vehicle>([]);
  hasCreatePermission = false;
  hasEditPermission = false;

  // Form controls
  searchControl = new FormControl('');
  filterForm: FormGroup;

  // Dropdown options
  makes: string[] = [];
  vehicleTypes: string[] = [];
  colors: string[] = [];

  // Color mapping for visualization
  colorMap: { [key: string]: string } = {
    Black: '#333333',
    White: '#FFFFFF',
    Silver: '#C0C0C0',
    Grey: '#808080',
    Blue: '#0000FF',
    Red: '#FF0000',
    Green: '#008000',
    Yellow: '#FFFF00',
    Brown: '#A52A2A',
    Orange: '#FFA500',
    Purple: '#800080',
    Gold: '#FFD700',
    Beige: '#F5F5DC',
  };

  private subscriptions: Subscription[] = [];

  @ViewChild(MatSort) sort!: MatSort;
  @ViewChild(MatPaginator) paginator!: MatPaginator;

  constructor(private router: Router, private vehicleService: VehicleService, private authService: AuthService, private snackBar: MatSnackBar) {
    this.filterForm = new FormGroup({
      make: new FormControl('All'),
      type: new FormControl('All'),
      color: new FormControl('All'),
    });
  }

  ngOnInit(): void {
    this.checkPermissions();
    this.loadVehicles();
    this.setupFilterListeners();
  }

  ngAfterViewInit(): void {
    this.dataSource.sort = this.sort;
    this.dataSource.paginator = this.paginator;
    this.setupCustomFilter();
  }

  ngOnDestroy(): void {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }

  private checkPermissions(): void {
    const authSub = this.authService.getUserProfile().subscribe((user) => {
      this.hasCreatePermission = user?.permissions?.canManageUsers || user?.permissions?.isAdmin || false;
      this.hasEditPermission = user?.permissions?.canManageUsers || user?.permissions?.isAdmin || false;
    });
    this.subscriptions.push(authSub);
  }

  private setupFilterListeners(): void {
    // Subscribe to search input changes
    const searchSub = this.searchControl.valueChanges.pipe(debounceTime(300), distinctUntilChanged()).subscribe((value) => {
      this.applyFilter(value || '');
    });
    this.subscriptions.push(searchSub);

    // Subscribe to filter form changes
    const filterSub = this.filterForm.valueChanges.subscribe(() => {
      this.applyFilters();
    });
    this.subscriptions.push(filterSub);
  }

  private setupCustomFilter(): void {
    this.dataSource.filterPredicate = (data: Vehicle, filter: string) => {
      const searchStr = filter.toLowerCase();

      // Apply dropdown filters first
      const makeFilter = this.filterForm.get('make')?.value;
      if (makeFilter !== 'All' && data.makeName !== makeFilter) {
        return false;
      }

      const typeFilter = this.filterForm.get('type')?.value;
      if (typeFilter !== 'All' && data.type !== typeFilter) {
        return false;
      }

      const colorFilter = this.filterForm.get('color')?.value;
      if (colorFilter !== 'All' && data.color !== colorFilter) {
        return false;
      }

      // Then apply search text filter
      return (
        data.registration?.toLowerCase().includes(searchStr) ||
        data.chassisNumber?.toLowerCase().includes(searchStr) ||
        data.makeName?.toLowerCase().includes(searchStr) ||
        data.modelName?.toLowerCase().includes(searchStr) ||
        data.vin?.toLowerCase().includes(searchStr) ||
        data.color?.toLowerCase().includes(searchStr) ||
        (data.year?.toString() || '').includes(searchStr)
      );
    };
  }

  applyFilter(filterValue: string): void {
    this.dataSource.filter = filterValue.trim().toLowerCase();

    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage();
    }
  }

  applyFilters(): void {
    // This will trigger the filterPredicate function with the current search value
    const currentFilter = this.dataSource.filter || ' ';
    this.dataSource.filter = '';
    this.dataSource.filter = currentFilter;
  }

  loadVehicles(): void {
    this.isLoading = true;

    const vehiclesSub = this.vehicleService.getVehicles().subscribe({
      next: (vehicles) => {
        this.dataSource.data = vehicles;
        this.extractFilterOptions(vehicles);
        this.isLoading = false;
      },
      error: (error) => {
        console.error('Error loading vehicles:', error);
        this.showSnackbar('Error loading vehicles. Please try again.');
        this.isLoading = false;
      },
    });

    this.subscriptions.push(vehiclesSub);
  }

  private extractFilterOptions(vehicles: Vehicle[]): void {
    // Extract unique makes, types, and colors for filters
    const makesSet = new Set<string>();
    const typesSet = new Set<string>();
    const colorsSet = new Set<string>();

    vehicles.forEach((vehicle) => {
      if (vehicle.makeName) makesSet.add(vehicle.makeName);
      if (vehicle.type) typesSet.add(vehicle.type);
      if (vehicle.color) colorsSet.add(vehicle.color);
    });

    this.makes = Array.from(makesSet).sort();
    this.vehicleTypes = Array.from(typesSet).sort();
    this.colors = Array.from(colorsSet).sort();
  }

  refreshVehicles(): void {
    this.loadVehicles();
  }

  createNewVehicle(): void {
    this.router.navigate(['/vehicles/new']);
  }

  viewVehicleDetails(vehicle: Vehicle): void {
    this.router.navigate(['/vehicles', vehicle.registration]);
  }

  editVehicle(vehicle: Vehicle, event: Event): void {
    event.stopPropagation(); // Prevent row click event
    this.router.navigate(['/vehicles', vehicle.registration, 'edit']);
  }

  viewVehicleJobs(vehicle: Vehicle, event: Event): void {
    event.stopPropagation(); // Prevent row click event
    this.router.navigate(['/jobs'], {
      queryParams: {
        registration: vehicle.registration,
      },
    });
  }

  formatDate(date: Date | undefined): string {
    if (!date) return 'N/A';

    if (typeof date === 'string') {
      date = new Date(date);
    }

    // Handle Firebase Timestamp
    if (date && typeof date === 'object' && 'toDate' in date) {
      const timestamp = date as unknown as { toDate: () => Date };
      date = timestamp.toDate();
    }

    return date.toLocaleDateString();
  }

  getColorHex(colorName: string): string {
    return this.colorMap[colorName] || '#CCCCCC'; // Default gray if not found
  }

  showSnackbar(message: string): void {
    this.snackBar.open(message, 'Close', {
      duration: 5000,
      horizontalPosition: 'center',
      verticalPosition: 'bottom',
    });
  }
}


--- ./src/app/pages/vehicles/vehicle-create/vehicle-create.component.scss ---
.vehicle-form-container {
  padding: 24px;
  background-color: #f5f5f5;
  min-height: 100vh;
  margin-left: 250px; /* Account for sidebar */
  padding-top: 88px; /* Account for topbar height (64px) + padding */
}

.form-card {
  max-width: 1000px;
  margin: 0 auto;
  background-color: white;
  border-radius: 8px;
}

// Loading Overlay
.loading-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.9);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  gap: 16px;
}

.loading-overlay span {
  color: rgba(0, 0, 0, 0.6);
  font-size: 14px;
  margin-top: 8px;
}

// Header
.header-wrapper {
  padding: 24px 24px 16px;
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  border-bottom: 1px solid rgba(0, 0, 0, 0.12);

  .header-title {
    h1 {
      margin: 0;
      font-size: 24px;
      font-weight: 500;
      color: var(--primary-color);
    }

    .subtitle {
      margin: 4px 0 0;
      color: rgba(0, 0, 0, 0.6);
      font-size: 14px;
    }
  }

  .header-actions {
    display: flex;
    gap: 12px;

    button {
      height: 36px;

      .mat-icon {
        margin-right: 8px;
      }
    }
  }
}

// Form Content
.form-content {
  padding: 24px;

  .form-section {
    margin-bottom: 32px;

    h2 {
      margin: 0 0 16px;
      font-size: 18px;
      font-weight: 500;
      color: var(--primary-color);
    }

    .form-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 16px;

      .full-width {
        grid-column: 1 / -1;
      }
    }
  }
}

// Form field customizations
.color-option {
  display: flex;
  align-items: center;
  gap: 8px;

  .color-swatch {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    display: inline-block;
    border: 1px solid rgba(0, 0, 0, 0.1);
  }
}

// Footer Actions
.footer-actions {
  padding: 16px 24px;
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  border-top: 1px solid rgba(0, 0, 0, 0.12);
}

// Responsive Design
@media screen and (max-width: 992px) {
  .form-content {
    .form-section {
      .form-grid {
        grid-template-columns: 1fr 1fr;
      }
    }
  }
}

@media screen and (max-width: 768px) {
  .vehicle-form-container {
    padding: 16px;
    margin-left: 60px; /* Collapsed sidebar width */
    padding-top: 80px; /* Adjust for smaller topbar */
  }

  .header-wrapper {
    flex-direction: column;
    gap: 16px;

    .header-actions {
      width: 100%;
      justify-content: flex-end;
    }
  }

  .form-content {
    padding: 16px;
  }
}

@media screen and (max-width: 576px) {
  .vehicle-form-container {
    padding: 8px;
    padding-top: 72px;
  }

  .header-wrapper {
    padding: 16px;

    .header-actions {
      flex-direction: column;

      button {
        width: 100%;
      }
    }
  }

  .form-content {
    .form-section {
      .form-grid {
        grid-template-columns: 1fr;
      }
    }
  }

  .footer-actions {
    flex-direction: column;

    button {
      width: 100%;
    }
  }
}


--- ./src/app/pages/vehicles/vehicle-create/vehicle-create.component.html ---
<div class="vehicle-form-container">
  <!-- Loading Overlay -->
  <div class="loading-overlay" *ngIf="isLoading">
    <mat-spinner diameter="40"></mat-spinner>
    <span>Loading...</span>
  </div>

  <mat-card class="form-card">
    <!-- Header -->
    <div class="header-wrapper">
      <div class="header-title">
        <h1>{{ isEditMode ? 'Edit Vehicle' : 'Add New Vehicle' }}</h1>
        <p class="subtitle">
          {{ isEditMode ? 'Update vehicle details' : 'Create a new vehicle entry' }}
        </p>
      </div>
      <div class="header-actions">
        <button mat-stroked-button (click)="cancel()">
          <mat-icon>close</mat-icon>
          Cancel
        </button>
        <button mat-flat-button color="primary" (click)="save()" [disabled]="!vehicleForm.valid || isSubmitting">
          <mat-icon>save</mat-icon>
          Save Vehicle
        </button>
      </div>
    </div>

    <!-- Form Content -->
    <div class="form-content">
      <form [formGroup]="vehicleForm">
        <!-- Basic Information -->
        <section class="form-section">
          <h2>Basic Information</h2>
          <div class="form-grid">
            <mat-form-field appearance="outline">
              <mat-label>Registration Number</mat-label>
              <input matInput formControlName="registration" required placeholder="e.g. AB12CDE" style="text-transform: uppercase" />
              <mat-hint>Registration number (uppercase, no spaces)</mat-hint>
              <mat-error *ngIf="vehicleForm.get('registration')?.hasError('required')"> Registration number is required </mat-error>
              <mat-error *ngIf="vehicleForm.get('registration')?.hasError('pattern')"> Invalid format (letters and numbers only, no spaces) </mat-error>
            </mat-form-field>

            <mat-form-field appearance="outline">
              <mat-label>Chassis Number</mat-label>
              <input matInput formControlName="chassisNumber" placeholder="e.g. ABCD1234567890" style="text-transform: uppercase" />
              <mat-hint>Chassis/VIN number (if available)</mat-hint>
              <mat-error *ngIf="vehicleForm.get('chassisNumber')?.hasError('pattern')"> Invalid format (letters and numbers only) </mat-error>
            </mat-form-field>

            <mat-form-field appearance="outline">
              <mat-label>Make</mat-label>
              <mat-select formControlName="makeId" required (selectionChange)="onMakeChange()">
                <mat-option *ngFor="let make of vehicleMakes" [value]="make.id">
                  {{ make.displayName }}
                </mat-option>
              </mat-select>
              <mat-error *ngIf="vehicleForm.get('makeId')?.hasError('required')"> Make is required </mat-error>
            </mat-form-field>

            <mat-form-field appearance="outline">
              <mat-label>Model</mat-label>
              <mat-select formControlName="modelId" required (selectionChange)="onModelChange()">
                <mat-option *ngFor="let model of availableModels" [value]="model.id">
                  {{ model.name }}
                </mat-option>
              </mat-select>
              <mat-error *ngIf="vehicleForm.get('modelId')?.hasError('required')"> Model is required </mat-error>
            </mat-form-field>

            <mat-form-field appearance="outline">
              <mat-label>Vehicle Type</mat-label>
              <input matInput formControlName="type" readonly />
            </mat-form-field>

            <mat-form-field appearance="outline">
              <mat-label>Color</mat-label>
              <mat-select formControlName="color" required>
                <mat-option *ngFor="let color of colors" [value]="color">
                  <div class="color-option">
                    <span class="color-swatch" [ngStyle]="{ 'background-color': getColorHex(color) }"></span>
                    {{ color }}
                  </div>
                </mat-option>
              </mat-select>
              <mat-error *ngIf="vehicleForm.get('color')?.hasError('required')"> Color is required </mat-error>
            </mat-form-field>

            <mat-form-field appearance="outline">
              <mat-label>Year</mat-label>
              <input matInput type="number" formControlName="year" required min="1900" [max]="currentYear" />
              <mat-error *ngIf="vehicleForm.get('year')?.hasError('required')"> Year is required </mat-error>
              <mat-error *ngIf="vehicleForm.get('year')?.hasError('min')"> Year must be 1900 or later </mat-error>
              <mat-error *ngIf="vehicleForm.get('year')?.hasError('max')"> Year cannot be in the future </mat-error>
            </mat-form-field>
          </div>
        </section>

        <!-- Additional Details -->
        <section class="form-section">
          <h2>Additional Details</h2>
          <div class="form-grid">
            <mat-form-field appearance="outline">
              <mat-label>VIN Number</mat-label>
              <input matInput formControlName="vin" placeholder="Vehicle Identification Number" />
            </mat-form-field>

            <mat-form-field appearance="outline">
              <mat-label>Engine Size</mat-label>
              <input matInput formControlName="engineSize" placeholder="e.g. 2.0L" />
            </mat-form-field>

            <mat-form-field appearance="outline">
              <mat-label>Fuel Type</mat-label>
              <mat-select formControlName="fuelType">
                <mat-option *ngFor="let fuel of fuelTypes" [value]="fuel">
                  {{ fuel }}
                </mat-option>
              </mat-select>
            </mat-form-field>

            <mat-form-field appearance="outline">
              <mat-label>Transmission</mat-label>
              <mat-select formControlName="transmission">
                <mat-option *ngFor="let trans of transmissionTypes" [value]="trans">
                  {{ trans }}
                </mat-option>
              </mat-select>
            </mat-form-field>

            <mat-form-field appearance="outline">
              <mat-label>Current Mileage</mat-label>
              <input matInput type="number" formControlName="mileage" min="0" placeholder="Current mileage in miles" />
              <mat-error *ngIf="vehicleForm.get('mileage')?.hasError('min')"> Mileage cannot be negative </mat-error>
            </mat-form-field>
          </div>
        </section>

        <!-- Notes Section -->
        <section class="form-section">
          <h2>Notes</h2>
          <div class="form-grid">
            <mat-form-field appearance="outline" class="full-width">
              <mat-label>Additional Notes</mat-label>
              <textarea matInput formControlName="notes" rows="4" placeholder="Any additional information about this vehicle"></textarea>
            </mat-form-field>
          </div>
        </section>
      </form>
    </div>

    <!-- Footer Actions -->
    <div class="footer-actions">
      <button mat-stroked-button (click)="cancel()">Cancel</button>
      <button mat-flat-button color="primary" (click)="save()" [disabled]="!vehicleForm.valid || isSubmitting">
        {{ isSubmitting ? 'Saving...' : 'Save Vehicle' }}
      </button>
    </div>
  </mat-card>
</div>


--- ./src/app/pages/vehicles/vehicle-create/vehicle-create.component.ts ---
import { Component, OnInit, OnDestroy } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Router, ActivatedRoute } from '@angular/router';
import { MatSnackBar } from '@angular/material/snack-bar';
import { MatDialog } from '@angular/material/dialog';
import { Subscription, forkJoin, of } from 'rxjs';
import { switchMap, catchError, finalize } from 'rxjs/operators';
import { VehicleService, VehicleMake, VehicleModel } from '../../../services/vehicle.service';
import { AuthService } from '../../../services/auth.service';
import { ConfirmationDialogComponent } from '../../../dialogs/confirmation-dialog.component';

@Component({
  selector: 'app-vehicle-create',
  templateUrl: './vehicle-create.component.html',
  styleUrls: ['./vehicle-create.component.scss'],
  standalone: false,
})
export class VehicleCreateComponent implements OnInit, OnDestroy {
  vehicleForm!: FormGroup;
  isEditMode = false;
  isLoading = false;
  isSubmitting = false;
  vehicleId: string = '';
  currentYear = new Date().getFullYear();

  // Reference data
  vehicleMakes: VehicleMake[] = [];
  availableModels: VehicleModel[] = [];
  allModels: VehicleModel[] = [];

  // Dropdown options
  colors: string[] = ['Black', 'White', 'Silver', 'Grey', 'Blue', 'Red', 'Green', 'Yellow', 'Brown', 'Orange', 'Purple', 'Gold', 'Beige'];

  fuelTypes: string[] = ['Petrol', 'Diesel', 'Hybrid', 'Electric', 'LPG', 'Hydrogen', 'Other'];

  transmissionTypes: string[] = ['Manual', 'Automatic', 'Semi-Automatic', 'CVT'];

  // Color mapping for visualization
  colorMap: { [key: string]: string } = {
    Black: '#333333',
    White: '#FFFFFF',
    Silver: '#C0C0C0',
    Grey: '#808080',
    Blue: '#0000FF',
    Red: '#FF0000',
    Green: '#008000',
    Yellow: '#FFFF00',
    Brown: '#A52A2A',
    Orange: '#FFA500',
    Purple: '#800080',
    Gold: '#FFD700',
    Beige: '#F5F5DC',
  };

  private subscriptions: Subscription[] = [];

  constructor(
    private formBuilder: FormBuilder,
    private router: Router,
    private route: ActivatedRoute,
    private vehicleService: VehicleService,
    private authService: AuthService,
    private snackBar: MatSnackBar,
    private dialog: MatDialog
  ) {
    this.createForm();
  }

  ngOnInit(): void {
    this.loadReferenceData();

    // Check if we're in edit mode (URL contains an ID)
    const routeSub = this.route.params.subscribe((params) => {
      if (params['id']) {
        this.isEditMode = true;
        this.vehicleId = params['id'];
        this.loadVehicleDetails(this.vehicleId);
      }
    });

    this.subscriptions.push(routeSub);
    this.checkPermissions();
  }

  ngOnDestroy(): void {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }

  private createForm(): void {
    this.vehicleForm = this.formBuilder.group({
      registration: ['', [Validators.required, Validators.pattern(/^[A-Z0-9]+$/)]],
      chassisNumber: ['', [Validators.pattern(/^[A-Z0-9]+$/)]],
      makeId: ['', Validators.required],
      modelId: ['', Validators.required],
      type: [{ value: '', disabled: true }],
      color: ['', Validators.required],
      year: ['', [Validators.required, Validators.min(1900), Validators.max(this.currentYear)]],
      vin: [''],
      engineSize: [''],
      fuelType: [''],
      transmission: [''],
      mileage: [null, Validators.min(0)],
      notes: [''],
    });
  }

  private checkPermissions(): void {
    const authSub = this.authService.hasPermission('canManageUsers').subscribe((hasPermission) => {
      if (!hasPermission) {
        this.showSnackbar('You do not have permission to manage vehicles');
        this.router.navigate(['/vehicles']);
      }
    });

    this.subscriptions.push(authSub);
  }

  private loadReferenceData(): void {
    this.isLoading = true;

    const dataSub = forkJoin({
      makes: this.vehicleService.getVehicleMakes(),
      models: this.vehicleService.getVehicleModels(),
    }).subscribe({
      next: (data) => {
        this.vehicleMakes = data.makes;
        this.allModels = data.models;
        this.isLoading = false;
      },
      error: (error) => {
        console.error('Error loading reference data:', error);
        this.showSnackbar('Error loading data. Please try again.');
        this.isLoading = false;
      },
    });

    this.subscriptions.push(dataSub);
  }

  private loadVehicleDetails(vehicleId: string): void {
    this.isLoading = true;

    const vehicleSub = this.vehicleService
      .getVehicleById(vehicleId)
      .pipe(
        catchError((error) => {
          console.error('Error loading vehicle details:', error);
          this.showSnackbar('Error loading vehicle details');
          this.router.navigate(['/vehicles']);
          return of(null);
        }),
        finalize(() => {
          this.isLoading = false;
        })
      )
      .subscribe((vehicle) => {
        if (vehicle) {
          // Update available models based on the make
          if (vehicle.makeId) {
            this.updateAvailableModels(vehicle.makeId);
          }

          // Populate form with vehicle data
          this.vehicleForm.patchValue({
            registration: vehicle.registration,
            chassisNumber: vehicle.chassisNumber || '',
            makeId: vehicle.makeId,
            modelId: vehicle.modelId,
            type: vehicle.type,
            color: vehicle.color,
            year: vehicle.year,
            vin: vehicle.vin || '',
            engineSize: vehicle.engineSize || '',
            fuelType: vehicle.fuelType || '',
            transmission: vehicle.transmission || '',
            mileage: vehicle.mileage || 0,
            notes: vehicle.notes || '',
          });
        }
      });

    this.subscriptions.push(vehicleSub);
  }

  onMakeChange(): void {
    const makeId = this.vehicleForm.get('makeId')?.value;
    if (makeId) {
      this.updateAvailableModels(makeId);

      // Reset model selection and type
      this.vehicleForm.get('modelId')?.setValue('');
      this.vehicleForm.get('type')?.setValue('');
    }
  }

  onModelChange(): void {
    const modelId = this.vehicleForm.get('modelId')?.value;
    if (modelId) {
      const selectedModel = this.availableModels.find((model) => model.id === modelId);
      if (selectedModel) {
        this.vehicleForm.get('type')?.setValue(selectedModel.type);
      }
    }
  }

  private updateAvailableModels(makeId: string): void {
    if (!makeId) {
      this.availableModels = [];
      return;
    }

    // Filter models by the selected make
    this.availableModels = this.allModels.filter((model) => model.makeId === makeId && model.isActive);
  }

  save(): void {
    if (this.vehicleForm.invalid || this.isSubmitting) {
      return;
    }

    this.isSubmitting = true;

    // Get form values
    const formValues = this.vehicleForm.getRawValue();

    // Get make and model names for storing in denormalized fields
    const selectedMake = this.vehicleMakes.find((make) => make.id === formValues.makeId);
    const selectedModel = this.availableModels.find((model) => model.id === formValues.modelId);

    if (this.isEditMode) {
      // For updates, we only send the fields we want to update
      const updateData = {
        registration: formValues.registration.toUpperCase(),
        chassisNumber: formValues.chassisNumber ? formValues.chassisNumber.toUpperCase() : '',
        makeId: formValues.makeId,
        makeName: selectedMake?.displayName || '',
        modelId: formValues.modelId,
        modelName: selectedModel?.name || '',
        type: formValues.type,
        color: formValues.color,
        year: formValues.year,
        vin: formValues.vin ? formValues.vin.toUpperCase() : '',
        engineSize: formValues.engineSize,
        fuelType: formValues.fuelType,
        transmission: formValues.transmission,
        mileage: formValues.mileage || 0,
        notes: formValues.notes,
      };

      // Update existing vehicle
      this.vehicleService
        .updateVehicle(this.vehicleId, updateData)
        .pipe(finalize(() => (this.isSubmitting = false)))
        .subscribe({
          next: () => {
            this.showSnackbar('Vehicle updated successfully');
            this.router.navigate(['/vehicles', this.vehicleId]);
          },
          error: (error) => {
            console.error('Error updating vehicle:', error);
            this.showSnackbar('Error updating vehicle. Please try again.');
          },
        });
    } else {
      // For new vehicles, we need to provide all required fields
      const newVehicleData = {
        registration: formValues.registration.toUpperCase(),
        chassisNumber: formValues.chassisNumber ? formValues.chassisNumber.toUpperCase() : '',
        makeId: formValues.makeId,
        makeName: selectedMake?.displayName || '',
        modelId: formValues.modelId,
        modelName: selectedModel?.name || '',
        type: formValues.type,
        color: formValues.color,
        year: formValues.year,
        vin: formValues.vin ? formValues.vin.toUpperCase() : '',
        engineSize: formValues.engineSize,
        fuelType: formValues.fuelType,
        transmission: formValues.transmission,
        mileage: formValues.mileage || 0,
        notes: formValues.notes,

        // These required fields will be initialized by the service
        firstProcessedDate: new Date(),
        lastProcessedDate: new Date(),
        jobCount: 0,
        jobHistory: [],
      };

      // Create new vehicle
      this.vehicleService
        .createVehicle(newVehicleData)
        .pipe(finalize(() => (this.isSubmitting = false)))
        .subscribe({
          next: (id) => {
            this.showSnackbar('Vehicle created successfully');
            this.router.navigate(['/vehicles', id]);
          },
          error: (error) => {
            console.error('Error creating vehicle:', error);
            this.showSnackbar('Error creating vehicle. Please try again.');
          },
        });
    }
  }

  cancel(): void {
    // Show confirmation dialog if there are unsaved changes
    if (this.vehicleForm.dirty) {
      const dialogRef = this.dialog.open(ConfirmationDialogComponent, {
        data: {
          title: 'Discard Changes',
          message: 'Are you sure you want to discard your changes?',
          confirmText: 'Discard',
          cancelText: 'Continue Editing',
          confirmColor: 'warn',
        },
        width: '400px',
      });

      dialogRef.afterClosed().subscribe((result) => {
        if (result) {
          this.navigateBack();
        }
      });
    } else {
      this.navigateBack();
    }
  }

  private navigateBack(): void {
    if (this.isEditMode) {
      this.router.navigate(['/vehicles', this.vehicleId]);
    } else {
      this.router.navigate(['/vehicles']);
    }
  }

  getColorHex(colorName: string): string {
    return this.colorMap[colorName] || '#CCCCCC'; // Default gray if not found
  }

  showSnackbar(message: string): void {
    this.snackBar.open(message, 'Close', {
      duration: 5000,
      horizontalPosition: 'center',
      verticalPosition: 'bottom',
    });
  }
}


--- ./src/app/pages/vehicles/vehicle-details/vehicle-details.component.scss ---
.vehicle-details-container {
  padding: 24px;
  max-width: 1600px;
  margin: 0 auto;
  margin-left: 250px; /* Account for sidebar */
  padding-top: 88px; /* Account for topbar height (64px) + padding */
}

// Loading & Error States
.loading-state,
.error-state {
  min-height: 400px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 16px;
  color: rgba(0, 0, 0, 0.6);

  .material-icons {
    font-size: 48px;

    &.spinning {
      animation: spin 1.5s linear infinite;
    }
  }

  .retry-button {
    padding: 8px 24px;
    border: none;
    background: var(--primary-color);
    color: white;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;

    &:hover {
      background: var(--secondary-color);
    }
  }
}

// Header Styles
.details-header {
  margin-bottom: 32px;
  background: white;
  border-radius: 8px;
  padding: 24px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);

  .breadcrumb {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 24px;
    font-size: 14px;
    color: #666;

    a {
      color: var(--primary-color);
      text-decoration: none;
      transition: color 0.2s;

      &:hover {
        color: var(--secondary-color);
        text-decoration: underline;
      }
    }

    .material-icons {
      font-size: 18px;
      color: #999;
    }
  }

  .header-content {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;

    .vehicle-info {
      h1 {
        margin: 0 0 12px 0;
        font-size: 32px;
        font-weight: 600;
        color: var(--primary-color);
      }

      .vehicle-meta {
        display: flex;
        align-items: center;
        gap: 16px;
        flex-wrap: wrap;

        .registration-badge {
          background-color: var(--primary-color);
          color: white;
          padding: 4px 12px;
          border-radius: 4px;
          font-weight: 500;
          letter-spacing: 1px;
        }

        .year {
          color: #666;
          font-size: 16px;
        }

        .color-badge {
          display: inline-flex;
          align-items: center;
          padding: 4px 12px;
          border-radius: 16px;
          color: white;
          font-size: 14px;
          white-space: nowrap;
          border: 1px solid rgba(0, 0, 0, 0.1);

          // Dynamic contrast for text color
          &[style*='background:#FFFFFF'],
          &[style*='background:#F5F5DC'],
          &[style*='background:#FFFF00'],
          &[style*='background:#C0C0C0'] {
            color: #333;
          }
        }
      }
    }

    .header-actions {
      display: flex;
      gap: 12px;

      .edit-button {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 16px;
        border: 1px solid #ddd;
        border-radius: 6px;
        background-color: white;
        color: #333;
        cursor: pointer;
        font-weight: 500;
        transition: all 0.2s;

        &:hover {
          border-color: var(--primary-color);
          color: var(--primary-color);
        }

        .material-icons {
          font-size: 20px;
        }
      }
    }
  }
}

// Navigation Tabs
.tabs {
  display: flex;
  gap: 2px;
  margin-bottom: 24px;
  background: white;
  padding: 4px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
  overflow-x: auto;

  &::-webkit-scrollbar {
    height: 3px;
  }

  &::-webkit-scrollbar-track {
    background: #f5f5f5;
  }

  &::-webkit-scrollbar-thumb {
    background: #ddd;
    border-radius: 3px;
  }

  .tab-button {
    flex: 1;
    min-width: 120px;
    padding: 12px;
    border: none;
    background: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;
    color: #666;
    transition: all 0.2s;
    text-transform: uppercase;
    font-size: 13px;
    letter-spacing: 0.5px;

    &:hover:not(.active) {
      background: #f5f5f5;
      color: #333;
    }

    &.active {
      background: var(--primary-color);
      color: white;
    }
  }
}

// Tab Content
.tab-content {
  min-height: 500px;
}

// Two Column Layout
.two-column-layout {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 24px;
}

.info-card {
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  margin-bottom: 24px;
  overflow: hidden;

  h2 {
    padding: 16px 20px;
    margin: 0;
    font-size: 18px;
    color: #333;
    border-bottom: 1px solid #eee;
    font-weight: 600;
  }

  .card-content {
    padding: 20px;
  }

  .info-row {
    display: flex;
    padding: 8px 0;
    border-bottom: 1px solid #f5f5f5;

    &:last-child {
      border-bottom: none;
    }

    .label {
      width: 140px;
      color: #666;
      font-size: 14px;
      font-weight: 500;
    }

    .value {
      flex: 1;
      color: #333;
      font-weight: 400;
    }

    .color-chip {
      display: inline-block;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      margin-right: 8px;
      vertical-align: middle;
      border: 1px solid rgba(0, 0, 0, 0.1);
    }
  }
}

// Stats Card
.stats-card {
  .stats-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 16px;

    .stat-item {
      text-align: center;
      padding: 16px 0;

      .stat-value {
        display: block;
        font-size: 24px;
        font-weight: 600;
        color: var(--primary-color);
        margin-bottom: 8px;
      }

      .stat-label {
        font-size: 14px;
        color: #666;
      }
    }
  }
}

// Photo Card
.photo-card {
  .primary-photo {
    position: relative;

    img {
      width: 100%;
      height: 250px;
      object-fit: cover;
      border-radius: 4px;
    }

    .photo-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 12px;

      .photo-info {
        display: flex;
        flex-direction: column;
        gap: 4px;

        .photo-date,
        .photo-job {
          font-size: 14px;
          color: #666;
        }
      }

      .view-all-button {
        padding: 6px 12px;
        border: 1px solid var(--primary-color);
        background: none;
        color: var(--primary-color);
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;

        &:hover {
          background: var(--primary-color);
          color: white;
        }
      }
    }
  }
}

// Job Preview
.job-preview {
  .job-preview-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;

    .job-id {
      font-weight: 600;
      color: var(--primary-color);
      font-size: 16px;
    }

    .status-badge {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 16px;
      font-size: 12px;
      font-weight: 500;
      text-transform: capitalize;
    }
  }

  .job-preview-content {
    margin-bottom: 16px;
  }

  .view-job-button {
    display: block;
    width: 100%;
    padding: 8px;
    background: var(--primary-color);
    color: white;
    border: none;
    border-radius: 4px;
    text-align: center;
    cursor: pointer;
    font-weight: 500;

    &:hover {
      background: var(--secondary-color);
    }
  }
}

// Status badges
.status-badge {
  display: inline-block;
  padding: 4px 12px;
  border-radius: 16px;
  font-size: 12px;
  font-weight: 500;
  text-transform: capitalize;

  &.status-unallocated,
  &.status-unassigned {
    background-color: #e0e0e0;
    color: #616161;
  }

  &.status-allocated,
  &.status-assigned {
    background-color: #e1f5fe;
    color: #0288d1;
  }

  &.status-collected {
    background-color: #ffecb3;
    color: #ff6f00;
  }

  &.status-delivered {
    background-color: #d1f8ec;
    color: #00796b;
  }

  &.status-completed {
    background-color: #c8e6c9;
    color: #388e3c;
  }

  &.status-cancelled {
    background-color: #ffebee;
    color: #c62828;
  }
}

// Photos Tab
.photos-tab {
  .photos-wrapper {
    background: white;
    border-radius: 8px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    padding: 24px;

    .photos-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;

      @media (max-width: 768px) {
        flex-direction: column;
        align-items: flex-start;
        gap: 16px;
      }

      h2 {
        margin: 0;
        font-size: 20px;
        color: #333;
      }

      .photos-filter {
        display: flex;
        gap: 16px;

        @media (max-width: 768px) {
          width: 100%;
          flex-direction: column;
        }

        mat-form-field {
          width: 200px;

          @media (max-width: 768px) {
            width: 100%;
          }
        }
      }
    }

    .photos-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 20px;

      .photo-item {
        cursor: pointer;
        transition: transform 0.2s;

        &:hover {
          transform: translateY(-4px);

          .photo-thumbnail img {
            opacity: 0.9;
          }
        }

        .photo-thumbnail {
          height: 200px;
          overflow: hidden;
          border-radius: 8px;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);

          img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: opacity 0.2s;
          }
        }

        .photo-info {
          display: flex;
          justify-content: space-between;
          padding: 8px 4px;

          .photo-date,
          .photo-type {
            font-size: 14px;
            color: #666;
          }
        }
      }
    }

    .empty-photos {
      text-align: center;
      padding: 48px 24px;

      mat-icon {
        font-size: 48px;
        width: 48px;
        height: 48px;
        color: rgba(0, 0, 0, 0.38);
        margin-bottom: 16px;
      }

      p {
        margin: 0 0 8px;
        font-size: 16px;
        color: rgba(0, 0, 0, 0.87);

        &.sub-message {
          font-size: 14px;
          color: rgba(0, 0, 0, 0.6);
        }
      }
    }
  }
}

// History Tab
.history-tab {
  .history-wrapper {
    background: white;
    border-radius: 8px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    padding: 24px;

    .history-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;

      h2 {
        margin: 0;
        font-size: 20px;
        color: #333;
      }

      .view-all-jobs-button {
        padding: 8px 16px;
        background: var(--primary-color);
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: 500;

        &:hover {
          background: var(--secondary-color);
        }
      }
    }

    .job-timeline {
      position: relative;
      padding-left: 32px;

      &::before {
        content: '';
        position: absolute;
        top: 0;
        bottom: 0;
        left: 16px;
        width: 2px;
        background: #e0e0e0;
      }

      .job-entry {
        position: relative;
        margin-bottom: 32px;

        &:last-child {
          margin-bottom: 0;
        }

        .timeline-marker {
          position: absolute;
          left: -32px;
          top: 24px;

          .timeline-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #bdbdbd;
            border: 2px solid white;
            box-shadow: 0 0 0 2px #e0e0e0;

            &.status-allocated {
              background: #0288d1;
              box-shadow: 0 0 0 2px #e1f5fe;
            }

            &.status-collected {
              background: #ff6f00;
              box-shadow: 0 0 0 2px #ffecb3;
            }

            &.status-delivered {
              background: #00796b;
              box-shadow: 0 0 0 2px #d1f8ec;
            }

            &.status-completed {
              background: #388e3c;
              box-shadow: 0 0 0 2px #c8e6c9;
            }
          }
        }

        .job-card {
          background: #f9f9f9;
          border-radius: 8px;
          box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
          overflow: hidden;
          cursor: pointer;
          transition: transform 0.2s, box-shadow 0.2s;

          &:hover {
            transform: translateX(4px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
          }

          .job-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: white;
            border-bottom: 1px solid #eee;

            .job-id {
              font-weight: 600;
              color: var(--primary-color);
            }
          }

          .job-details {
            padding: 16px;

            .job-route {
              margin-bottom: 16px;

              .route-point {
                display: flex;
                align-items: flex-start;
                gap: 8px;
                margin-bottom: 8px;

                .material-icons {
                  margin-top: 2px;
                }

                &.collection .material-icons {
                  color: #ff6f00;
                }

                &.delivery .material-icons {
                  color: #388e3c;
                }

                .location {
                  flex: 1;
                  font-size: 14px;
                }
              }

              .route-arrow {
                padding-left: 24px;
                margin-bottom: 8px;
                color: #bdbdbd;
              }
            }

            .job-meta {
              display: flex;
              flex-wrap: wrap;
              gap: 16px;
              font-size: 13px;
              color: #666;
            }
          }
        }
      }
    }

    .empty-history {
      text-align: center;
      padding: 48px 24px;

      mat-icon {
        font-size: 48px;
        width: 48px;
        height: 48px;
        color: rgba(0, 0, 0, 0.38);
        margin-bottom: 16px;
      }

      p {
        margin: 0;
        font-size: 16px;
        color: rgba(0, 0, 0, 0.87);
      }
    }
  }
}

// Reports Tab
.reports-tab {
  .reports-wrapper {
    background: white;
    border-radius: 8px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    padding: 24px;

    .reports-header {
      margin-bottom: 24px;

      h2 {
        margin: 0;
        font-size: 20px;
        color: #333;
      }
    }

    .reports-timeline {
      position: relative;
      padding-left: 32px;

      &::before {
        content: '';
        position: absolute;
        top: 0;
        bottom: 0;
        left: 16px;
        width: 2px;
        background: #e0e0e0;
      }

      .report-entry {
        position: relative;
        margin-bottom: 32px;

        &:last-child {
          margin-bottom: 0;
        }

        .timeline-marker {
          position: absolute;
          left: -32px;
          top: 24px;

          .timeline-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #64b5f6;
            border: 2px solid white;
            box-shadow: 0 0 0 2px #bbdefb;
          }
        }

        .report-card {
          background: #f9f9f9;
          border-radius: 8px;
          box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
          overflow: hidden;

          .report-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: white;
            border-bottom: 1px solid #eee;

            .report-job {
              font-weight: 600;
              color: var(--primary-color);
            }

            .report-date {
              font-size: 14px;
              color: #666;
            }
          }

          .report-content {
            display: flex;
            gap: 24px;
            padding: 16px;

            @media (max-width: 576px) {
              flex-direction: column;
              gap: 16px;
            }

            .report-column {
              flex: 1;

              .report-item {
                margin-bottom: 12px;

                &:last-child {
                  margin-bottom: 0;
                }

                .report-label {
                  display: block;
                  font-size: 12px;
                  color: #666;
                  margin-bottom: 4px;
                }

                .report-value {
                  font-size: 16px;
                  font-weight: 500;
                }
              }
            }
          }

          .report-notes {
            padding: 0 16px 16px;

            .report-label {
              font-size: 12px;
              color: #666;
              margin-right: 8px;
            }

            .report-notes-text {
              font-size: 14px;
            }
          }

          .report-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: #f5f5f5;
            border-top: 1px solid #eee;

            .report-author {
              font-size: 13px;
              color: #666;
            }

            .view-job-button {
              padding: 6px 12px;
              background: var(--primary-color);
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              font-size: 13px;
              font-weight: 500;

              &:hover {
                background: var(--secondary-color);
              }
            }
          }
        }
      }
    }

    .empty-reports {
      text-align: center;
      padding: 48px 24px;

      mat-icon {
        font-size: 48px;
        width: 48px;
        height: 48px;
        color: rgba(0, 0, 0, 0.38);
        margin-bottom: 16px;
      }

      p {
        margin: 0 0 8px;
        font-size: 16px;
        color: rgba(0, 0, 0, 0.87);

        &.sub-message {
          font-size: 14px;
          color: rgba(0, 0, 0, 0.6);
        }
      }
    }
  }
}

// Photo Viewer Dialog
::ng-deep .photo-viewer-dialog {
  .mat-mdc-dialog-container {
    padding: 0 !important;
    overflow: hidden;
    border-radius: 8px;
  }
}

.photo-viewer {
  display: flex;
  flex-direction: column;
  max-height: 90vh;

  .photo-viewer-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px;
    background: var(--primary-color);
    color: white;

    h2 {
      margin: 0;
      font-size: 18px;
    }
  }

  .photo-viewer-content {
    flex: 1;
    overflow: auto;
    background: #f5f5f5;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 400px;

    img {
      max-width: 100%;
      max-height: 70vh;
      object-fit: contain;
      margin: 0 auto;
    }
  }

  .photo-viewer-footer {
    padding: 16px;
    background: white;
    border-top: 1px solid #eee;
    display: flex;
    justify-content: space-between;
    align-items: center;

    @media (max-width: 576px) {
      flex-direction: column;
      gap: 16px;
      align-items: flex-start;
    }

    .photo-info {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;

      .info-item {
        .label {
          font-weight: 500;
          margin-right: 4px;
          color: #666;
        }

        .value {
          color: #333;
        }
      }
    }
  }
}

// Responsive Design
@media screen and (max-width: 1024px) {
  .two-column-layout {
    grid-template-columns: 1fr;
  }
}

@media screen and (max-width: 768px) {
  .vehicle-details-container {
    padding: 16px;
    margin-left: 60px; /* Collapsed sidebar width */
    padding-top: 80px; /* Adjust for smaller topbar */
  }

  .details-header {
    padding: 16px;

    .header-content {
      flex-direction: column;
      gap: 16px;

      .header-actions {
        width: 100%;
        justify-content: flex-end;
      }
    }
  }

  .tabs {
    white-space: nowrap;
    overflow-x: auto;

    .tab-button {
      flex: none;
      min-width: auto;
      padding: 12px 20px;
    }
  }

  .stats-card .stats-grid {
    grid-template-columns: 1fr;
  }
}

@media screen and (max-width: 576px) {
  .vehicle-details-container {
    padding: 8px;
    padding-top: 72px; /* Further adjust for topbar on small screens */
  }

  .details-header {
    padding: 12px;

    .vehicle-meta {
      flex-direction: column;
      align-items: flex-start;
      gap: 8px;
    }

    .header-actions {
      flex-direction: column;

      button {
        width: 100%;
      }
    }
  }
}

// Animation
@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}


--- ./src/app/pages/vehicles/vehicle-details/vehicle-details.component.html ---
<div class="vehicle-details-container">
  <!-- Loading State -->
  <div class="loading-state" *ngIf="loading">
    <mat-spinner diameter="40"></mat-spinner>
    <span>Loading vehicle details...</span>
  </div>

  <!-- Error State -->
  <div class="error-state" *ngIf="error">
    <span class="material-icons">error</span>
    {{ error }}
    <button class="retry-button" (click)="loadVehicleDetails(vehicleId)">Retry</button>
  </div>

  <!-- Content -->
  <ng-container *ngIf="!loading && !error && vehicle">
    <!-- Header -->
    <header class="details-header">
      <div class="breadcrumb">
        <a routerLink="/vehicles">Vehicles</a>
        <span class="material-icons">chevron_right</span>
        <span>{{ vehicle.registration }}</span>
      </div>

      <div class="header-content">
        <div class="vehicle-info">
          <h1>{{ vehicle.makeName }} {{ vehicle.modelName }}</h1>
          <div class="vehicle-meta">
            <span class="registration-badge">{{ vehicle.registration }}</span>
            <span class="year">{{ vehicle.year }}</span>
            <span class="color-badge" [style.background]="getColorHex(vehicle.color)">
              {{ vehicle.color }}
            </span>
          </div>
        </div>

        <div class="header-actions" *ngIf="hasEditPermission">
          <button class="edit-button" (click)="editVehicle()">
            <span class="material-icons">edit</span>
            Edit
          </button>
        </div>
      </div>
    </header>

    <!-- Navigation Tabs -->
    <nav class="tabs">
      <button *ngFor="let tab of ['overview', 'photos', 'history', 'reports']" [class.active]="activeTab === tab" class="tab-button" (click)="setActiveTab(tab)">
        {{ tab | titlecase }}
      </button>
    </nav>

    <!-- Tab Content -->
    <div class="tab-content" [ngSwitch]="activeTab">
      <!-- Overview Tab -->
      <div *ngSwitchCase="'overview'" class="overview-tab">
        <div class="two-column-layout">
          <div class="left-column">
            <!-- Vehicle Details Card -->
            <div class="info-card">
              <h2>Vehicle Details</h2>
              <div class="card-content">
                <div class="info-row">
                  <span class="label">Registration</span>
                  <span class="value">{{ vehicle.registration }}</span>
                </div>
                <div class="info-row">
                  <span class="label">Make</span>
                  <span class="value">{{ vehicle.makeName }}</span>
                </div>
                <div class="info-row">
                  <span class="label">Model</span>
                  <span class="value">{{ vehicle.modelName }}</span>
                </div>
                <div class="info-row">
                  <span class="label">Type</span>
                  <span class="value">{{ vehicle.type }}</span>
                </div>
                <div class="info-row">
                  <span class="label">Color</span>
                  <span class="value">
                    <span class="color-chip" [style.background]="getColorHex(vehicle.color)"></span>
                    {{ vehicle.color }}
                  </span>
                </div>
                <div class="info-row">
                  <span class="label">Year</span>
                  <span class="value">{{ vehicle.year }}</span>
                </div>
              </div>
            </div>

            <!-- Technical Details Card -->
            <div class="info-card">
              <h2>Technical Details</h2>
              <div class="card-content">
                <div class="info-row">
                  <span class="label">Chassis Number</span>
                  <span class="value">{{ vehicle.chassisNumber || 'Not recorded' }}</span>
                </div>
                <div class="info-row">
                  <span class="label">VIN</span>
                  <span class="value">{{ vehicle.vin || 'Not recorded' }}</span>
                </div>
                <div class="info-row">
                  <span class="label">Engine Size</span>
                  <span class="value">{{ vehicle.engineSize || 'Not recorded' }}</span>
                </div>
                <div class="info-row">
                  <span class="label">Fuel Type</span>
                  <span class="value">{{ vehicle.fuelType || 'Not recorded' }}</span>
                </div>
                <div class="info-row">
                  <span class="label">Transmission</span>
                  <span class="value">{{ vehicle.transmission || 'Not recorded' }}</span>
                </div>
                <div class="info-row">
                  <span class="label">Last Recorded Mileage</span>
                  <span class="value">{{ vehicle.mileage | number }} miles</span>
                </div>
              </div>
            </div>
          </div>

          <div class="right-column">
            <!-- Quick Stats Card -->
            <div class="info-card stats-card">
              <h2>Activity Summary</h2>
              <div class="card-content">
                <div class="stats-grid">
                  <div class="stat-item">
                    <span class="stat-value">{{ vehicle.jobCount }}</span>
                    <span class="stat-label">Total Jobs</span>
                  </div>
                  <div class="stat-item">
                    <span class="stat-value">{{ formatDate(vehicle.firstProcessedDate) }}</span>
                    <span class="stat-label">First Processed</span>
                  </div>
                  <div class="stat-item">
                    <span class="stat-value">{{ formatDate(vehicle.lastProcessedDate) }}</span>
                    <span class="stat-label">Last Processed</span>
                  </div>
                </div>
              </div>
            </div>

            <!-- Primary Photo Card -->
            <div class="info-card photo-card" *ngIf="latestPhoto">
              <h2>Primary Photo</h2>
              <div class="card-content">
                <div class="primary-photo">
                  <img [src]="latestPhoto.url" [alt]="vehicle.registration + ' photo'" />
                  <div class="photo-meta">
                    <div class="photo-info">
                      <span class="photo-date">{{ formatDate(latestPhoto.takenAt) }}</span>
                      <span class="photo-job">Job: {{ getJobReference(latestPhoto.jobId) }}</span>
                    </div>
                    <button class="view-all-button" (click)="setActiveTab('photos')">View All Photos</button>
                  </div>
                </div>
              </div>
            </div>

            <!-- Recent Job Card -->
            <div class="info-card" *ngIf="latestJob">
              <h2>Latest Job</h2>
              <div class="card-content">
                <div class="job-preview">
                  <div class="job-preview-header">
                    <span class="job-id">{{ latestJob.id }}</span>
                    <span [class]="'status-badge status-' + latestJob.status">
                      {{ latestJob.status | titlecase }}
                    </span>
                  </div>
                  <div class="job-preview-content">
                    <div class="info-row">
                      <span class="label">Collection</span>
                      <span class="value">{{ latestJob.collectionAddress }}</span>
                    </div>
                    <div class="info-row">
                      <span class="label">Delivery</span>
                      <span class="value">{{ latestJob.deliveryAddress }}</span>
                    </div>
                    <div class="info-row">
                      <span class="label">Date</span>
                      <span class="value">{{ formatDate(latestJob.createdAt) }}</span>
                    </div>
                  </div>
                  <button class="view-job-button" (click)="viewJob(latestJob.id)">View Job Details</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Photos Tab -->
      <div *ngSwitchCase="'photos'" class="photos-tab">
        <div class="photos-wrapper">
          <div class="photos-header">
            <h2>Vehicle Photos</h2>
            <div class="photos-filter">
              <mat-form-field appearance="outline">
                <mat-label>Filter by Job</mat-label>
                <mat-select [(value)]="selectedJobFilter" (selectionChange)="filterPhotos()">
                  <mat-option value="all">All Jobs</mat-option>
                  <mat-option *ngFor="let job of jobsWithPhotos" [value]="job.id"> {{ job.id }} - {{ formatDate(job.createdAt) }} </mat-option>
                </mat-select>
              </mat-form-field>
              <mat-form-field appearance="outline">
                <mat-label>Sort by</mat-label>
                <mat-select [(value)]="photosSort" (selectionChange)="sortPhotos()">
                  <mat-option value="newest">Newest First</mat-option>
                  <mat-option value="oldest">Oldest First</mat-option>
                </mat-select>
              </mat-form-field>
            </div>
          </div>

          <div class="photos-grid" *ngIf="filteredPhotos.length > 0">
            <div class="photo-item" *ngFor="let photo of filteredPhotos" (click)="openPhotoViewer(photo)">
              <div class="photo-thumbnail">
                <img [src]="photo.url" [alt]="'Photo of ' + vehicle.registration" />
              </div>
              <div class="photo-info">
                <span class="photo-date">{{ formatDate(photo.takenAt) }}</span>
                <span class="photo-type">{{ photo.type | titlecase }}</span>
              </div>
            </div>
          </div>

          <div class="empty-photos" *ngIf="filteredPhotos.length === 0">
            <mat-icon>photo_library</mat-icon>
            <p>No photos available for this vehicle</p>
            <p class="sub-message">Photos will be added when processing jobs</p>
          </div>
        </div>
      </div>

      <!-- History Tab -->
      <div *ngSwitchCase="'history'" class="history-tab">
        <div class="history-wrapper">
          <div class="history-header">
            <h2>Job History</h2>
            <button class="view-all-jobs-button" (click)="viewAllJobs()" *ngIf="jobs.length > 0">View All Jobs</button>
          </div>

          <div class="job-timeline" *ngIf="jobs.length > 0">
            <div class="job-entry" *ngFor="let job of jobs">
              <div class="timeline-marker">
                <div class="timeline-line"></div>
                <div class="timeline-dot" [ngClass]="'status-' + job.status"></div>
              </div>
              <div class="job-card" (click)="viewJob(job.id)">
                <div class="job-header">
                  <span class="job-id">{{ job.id }}</span>
                  <span [class]="'status-badge status-' + job.status">
                    {{ job.status | titlecase }}
                  </span>
                </div>
                <div class="job-details">
                  <div class="job-route">
                    <div class="route-point collection">
                      <span class="material-icons">location_on</span>
                      <span class="location">{{ job.collectionAddress }}</span>
                    </div>
                    <div class="route-arrow">
                      <span class="material-icons">arrow_downward</span>
                    </div>
                    <div class="route-point delivery">
                      <span class="material-icons">flag</span>
                      <span class="location">{{ job.deliveryAddress }}</span>
                    </div>
                  </div>
                  <div class="job-meta">
                    <span class="job-date">{{ formatDate(job.createdAt) }}</span>
                    <span class="job-driver" *ngIf="getJobProperty(job, 'driverName')">Driver: {{ getJobProperty(job, 'driverName') }}</span>
                    <span class="job-mileage" *ngIf="getJobProperty(job, 'deliveryMileage') && getJobProperty(job, 'collectionMileage')">
                      Mileage: {{ getJobProperty(job, 'collectionMileage') }} →
                      {{ getJobProperty(job, 'deliveryMileage') }}
                      ({{ getJobProperty(job, 'deliveryMileage') - getJobProperty(job, 'collectionMileage') }} miles)
                    </span>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="empty-history" *ngIf="jobs.length === 0">
            <mat-icon>history</mat-icon>
            <p>No job history available for this vehicle</p>
          </div>
        </div>
      </div>

      <!-- Reports Tab -->
      <div *ngSwitchCase="'reports'" class="reports-tab">
        <div class="reports-wrapper">
          <div class="reports-header">
            <h2>Condition Reports</h2>
          </div>

          <div class="reports-timeline" *ngIf="vehicle.conditionReports && vehicle.conditionReports.length > 0">
            <div class="report-entry" *ngFor="let report of vehicle.conditionReports">
              <div class="timeline-marker">
                <div class="timeline-line"></div>
                <div class="timeline-dot"></div>
              </div>
              <div class="report-card">
                <div class="report-header">
                  <span class="report-job">Job: {{ getJobReference(report.jobId) }}</span>
                  <span class="report-date">{{ formatDate(report.createdAt) }}</span>
                </div>
                <div class="report-content">
                  <div class="report-column">
                    <div class="report-item">
                      <span class="report-label">Mileage</span>
                      <span class="report-value">{{ report.mileage | number }} miles</span>
                    </div>
                    <div class="report-item">
                      <span class="report-label">Fuel Level</span>
                      <span class="report-value">{{ report.fuelLevel }}</span>
                    </div>
                    <div class="report-item">
                      <span class="report-label">Cleanliness</span>
                      <span class="report-value">{{ report.cleanliness }}</span>
                    </div>
                  </div>
                  <div class="report-column">
                    <div class="report-item">
                      <span class="report-label">Interior</span>
                      <span class="report-value">{{ report.interiorCondition }}</span>
                    </div>
                    <div class="report-item">
                      <span class="report-label">Exterior</span>
                      <span class="report-value">{{ report.exteriorCondition }}</span>
                    </div>
                  </div>
                </div>
                <div class="report-notes" *ngIf="report.damageNotes">
                  <span class="report-label">Damage Notes:</span>
                  <span class="report-notes-text">{{ report.damageNotes }}</span>
                </div>
                <div class="report-notes" *ngIf="report.additionalNotes">
                  <span class="report-label">Additional Notes:</span>
                  <span class="report-notes-text">{{ report.additionalNotes }}</span>
                </div>
                <div class="report-footer">
                  <span class="report-author">Recorded by: {{ getReportAuthorName(report.createdBy) }}</span>
                  <button class="view-job-button" (click)="viewJob(report.jobId)">View Job</button>
                </div>
              </div>
            </div>
          </div>

          <div class="empty-reports" *ngIf="!vehicle.conditionReports || vehicle.conditionReports.length === 0">
            <mat-icon>description</mat-icon>
            <p>No condition reports available for this vehicle</p>
            <p class="sub-message">Reports will be added when processing jobs</p>
          </div>
        </div>
      </div>
    </div>
  </ng-container>
</div>

<!-- Photo Viewer Dialog -->
<ng-template #photoViewerDialog>
  <div class="photo-viewer">
    <div class="photo-viewer-header">
      <h2>{{ selectedPhoto?.type | titlecase }} Photo</h2>
      <button mat-icon-button (click)="closePhotoViewer()">
        <mat-icon>close</mat-icon>
      </button>
    </div>
    <div class="photo-viewer-content">
      <img [src]="selectedPhoto?.url" [alt]="'Photo of ' + vehicle?.registration" />
    </div>
    <div class="photo-viewer-footer">
      <div class="photo-info">
        <div class="info-item">
          <span class="label">Date:</span>
          <span class="value">{{ formatDate(selectedPhoto?.takenAt) }}</span>
        </div>
        <div class="info-item">
          <span class="label">Job:</span>
          <span class="value">{{ getJobReference(selectedPhoto?.jobId) }}</span>
        </div>
        <div class="info-item" *ngIf="selectedPhoto?.notes">
          <span class="label">Notes:</span>
          <span class="value">{{ selectedPhoto?.notes }}</span>
        </div>
      </div>
      <button mat-flat-button color="primary" (click)="viewJob(selectedPhoto?.jobId)">View Job</button>
    </div>
  </div>
</ng-template>


--- ./src/app/pages/vehicles/vehicle-details/vehicle-details.component.ts ---
import { Component, OnInit, OnDestroy, ViewChild, TemplateRef } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { MatDialog } from '@angular/material/dialog';
import { MatSnackBar } from '@angular/material/snack-bar';
import { Subscription, forkJoin, of } from 'rxjs';
import { switchMap, catchError, finalize } from 'rxjs/operators';
import { AuthService } from '../../../services/auth.service';
import { VehicleService, Vehicle, VehiclePhoto, ConditionReport } from '../../../services/vehicle.service';
import { JobService } from '../../../services/job.service';
// Import the Job interface with a different name to avoid conflicts
import { Job as JobInterface } from '../../../interfaces/job.interface';

// Create a type alias to make it clear we're using the imported interface
type VehicleJob = JobInterface;

@Component({
  selector: 'app-vehicle-details',
  templateUrl: './vehicle-details.component.html',
  styleUrls: ['./vehicle-details.component.scss'],
  standalone: false,
})
export class VehicleDetailsComponent implements OnInit, OnDestroy {
  vehicleId: string = '';
  vehicle: Vehicle | null = null;
  activeTab: 'overview' | 'photos' | 'history' | 'reports' = 'overview';
  loading = false;
  error: string | null = null;
  hasEditPermission = false;

  // For photos tab
  filteredPhotos: VehiclePhoto[] = [];
  selectedJobFilter: string = 'all';
  photosSort: 'newest' | 'oldest' = 'newest';
  jobsWithPhotos: { id: string; createdAt: Date }[] = [];

  // For history tab
  jobs: VehicleJob[] = [];

  // Photo viewer
  selectedPhoto: VehiclePhoto | null = null;
  @ViewChild('photoViewerDialog') photoViewerDialog!: TemplateRef<any>;

  // Color mapping for visualization
  colorMap: { [key: string]: string } = {
    Black: '#333333',
    White: '#FFFFFF',
    Silver: '#C0C0C0',
    Grey: '#808080',
    Blue: '#0000FF',
    Red: '#FF0000',
    Green: '#008000',
    Yellow: '#FFFF00',
    Brown: '#A52A2A',
    Orange: '#FFA500',
    Purple: '#800080',
    Gold: '#FFD700',
    Beige: '#F5F5DC',
  };

  private subscriptions: Subscription[] = [];

  constructor(
    private route: ActivatedRoute,
    private router: Router,
    private vehicleService: VehicleService,
    private jobService: JobService,
    private authService: AuthService,
    private dialog: MatDialog,
    private snackBar: MatSnackBar
  ) {}

  ngOnInit(): void {
    this.checkPermissions();

    const routeSub = this.route.params.subscribe((params) => {
      this.vehicleId = params['id'];
      this.loadVehicleDetails(this.vehicleId);
    });

    this.subscriptions.push(routeSub);
  }

  ngOnDestroy(): void {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }

  private checkPermissions(): void {
    const authSub = this.authService.getUserProfile().subscribe((user) => {
      this.hasEditPermission = user?.permissions?.canManageUsers || user?.permissions?.isAdmin || false;
    });
    this.subscriptions.push(authSub);
  }

  loadVehicleDetails(vehicleId: string): void {
    this.loading = true;
    this.error = null;

    const vehicleSub = this.vehicleService
      .getVehicleById(vehicleId)
      .pipe(
        switchMap((vehicle) => {
          if (!vehicle) {
            throw new Error('Vehicle not found');
          }

          this.vehicle = vehicle;

          // Load jobs for this vehicle
          return forkJoin({
            jobs: this.jobService.getJobsByVehicle(vehicleId),
            // Additional data can be loaded here if needed
          });
        }),
        catchError((error) => {
          this.error = error.message || 'Failed to load vehicle details';
          console.error('Error loading vehicle details:', error);
          return of({ jobs: [] });
        }),
        finalize(() => {
          this.loading = false;
        })
      )
      .subscribe((result) => {
        if (this.vehicle) {
          // Handle jobs - make sure we handle the case where jobs might be undefined or null
          this.jobs = result.jobs || [];

          // Set up photos filtering
          this.setupPhotosData();
        }
      });

    this.subscriptions.push(vehicleSub);
  }

  private setupPhotosData(): void {
    if (!this.vehicle || !this.vehicle.photos) return;

    // Set filtered photos initially to all photos
    this.filteredPhotos = [...this.vehicle.photos];

    // Apply initial sort
    this.sortPhotos();

    // Build list of jobs with photos for filter dropdown
    const jobsMap = new Map<string, Date>();

    this.vehicle.photos.forEach((photo) => {
      if (!photo.jobId) return; // Skip photos without jobId

      // If we have the job in our jobs array, get the created date
      const job = this.jobs.find((j) => j.id === photo.jobId);
      if (job) {
        jobsMap.set(photo.jobId, job.createdAt);
      } else {
        // If we don't have the job details, use the photo date as fallback
        jobsMap.set(photo.jobId, photo.takenAt);
      }
    });

    // Convert map to array
    this.jobsWithPhotos = Array.from(jobsMap.entries()).map(([id, createdAt]) => ({
      id,
      createdAt,
    }));

    // Sort jobs by date (newest first)
    this.jobsWithPhotos.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
  }

  filterPhotos(): void {
    if (!this.vehicle || !this.vehicle.photos) return;

    if (this.selectedJobFilter === 'all') {
      this.filteredPhotos = [...this.vehicle.photos];
    } else {
      this.filteredPhotos = this.vehicle.photos.filter((photo) => photo.jobId === this.selectedJobFilter);
    }

    // Apply current sort
    this.sortPhotos();
  }

  sortPhotos(): void {
    this.filteredPhotos.sort((a, b) => {
      const dateA = new Date(a.takenAt).getTime();
      const dateB = new Date(b.takenAt).getTime();

      return this.photosSort === 'newest'
        ? dateB - dateA // Newest first
        : dateA - dateB; // Oldest first
    });
  }

  // Update the method to accept a string parameter and then cast it to the expected type
  setActiveTab(tab: string): void {
    this.activeTab = tab as 'overview' | 'photos' | 'history' | 'reports';
  }

  editVehicle(): void {
    this.router.navigate(['/vehicles', this.vehicleId, 'edit']);
  }

  viewJob(jobId?: string): void {
    if (jobId) {
      this.router.navigate(['/jobs', jobId]);
    }
  }

  viewAllJobs(): void {
    this.router.navigate(['/jobs'], {
      queryParams: {
        registration: this.vehicle?.registration,
      },
    });
  }

  get latestPhoto(): VehiclePhoto | undefined {
    if (!this.vehicle || !this.vehicle.photos || this.vehicle.photos.length === 0) {
      return undefined;
    }

    // Return the most recent photo
    return [...this.vehicle.photos].sort((a, b) => new Date(b.takenAt).getTime() - new Date(a.takenAt).getTime())[0];
  }

  get latestJob(): VehicleJob | undefined {
    if (!this.jobs || this.jobs.length === 0) {
      return undefined;
    }

    // Return the most recent job
    return [...this.jobs].sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())[0];
  }

  openPhotoViewer(photo: VehiclePhoto): void {
    this.selectedPhoto = photo;
    this.dialog.open(this.photoViewerDialog, {
      width: '800px',
      maxWidth: '95vw',
      panelClass: 'photo-viewer-dialog',
    });
  }

  closePhotoViewer(): void {
    this.dialog.closeAll();
  }

  getJobReference(jobId?: string): string {
    if (!jobId) return 'Unknown';

    const job = this.jobs.find((j) => j.id === jobId);
    return job ? job.id : jobId;
  }

  getReportAuthorName(authorId: string): string {
    // In a real app, you would look up the author's name
    return authorId || 'Unknown';
  }

  formatDate(date: Date | undefined): string {
    if (!date) return 'N/A';

    if (typeof date === 'string') {
      date = new Date(date);
    }

    // Handle Firebase Timestamp
    if (date && typeof date === 'object' && 'toDate' in date) {
      const timestamp = date as unknown as { toDate: () => Date };
      date = timestamp.toDate();
    }

    return date.toLocaleDateString();
  }

  getColorHex(colorName: string): string {
    return this.colorMap[colorName] || '#CCCCCC'; // Default gray if not found
  }

  showSnackbar(message: string): void {
    this.snackBar.open(message, 'Close', {
      duration: 5000,
      horizontalPosition: 'center',
      verticalPosition: 'bottom',
    });
  }

  /**
   * Safely access job properties - helper method to avoid index signature errors in template
   */
  getJobProperty(job: VehicleJob | undefined, property: string): any {
    if (!job) return undefined;
    return (job as any)[property];
  }
}


--- ./src/app/pages/vehicles/vehicle-models/vehicle-models.component.ts ---
import {
  Component,
  OnInit,
  ViewChild,
  AfterViewInit,
  TemplateRef,
} from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { MatTableDataSource } from '@angular/material/table';
import { MatSort } from '@angular/material/sort';
import { MatPaginator } from '@angular/material/paginator';
import { MatDialog } from '@angular/material/dialog';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { MatSnackBar } from '@angular/material/snack-bar';
import { SelectionModel } from '@angular/cdk/collections';

interface VehicleModel {
  id: string;
  name: string;
  imageUrl: string;
  yearStart: number;
  yearEnd: number | null;
  type: VehicleType;
  dimensions: {
    length: number;
    width: number;
    height: number;
  };
  specialRequirements: SpecialRequirement[];
  activeJobs: number;
}

enum VehicleType {
  SEDAN = 'Sedan',
  SUV = 'SUV',
  TRUCK = 'Truck',
  VAN = 'Van',
  SPORTS = 'Sports',
}

enum SpecialRequirement {
  ENCLOSED_TRANSPORT = 'Enclosed Transport',
  LIFT_GATE = 'Lift Gate Required',
  OVERSIZED = 'Oversized Vehicle',
  LOWERED = 'Lowered Vehicle',
}

interface Manufacturer {
  id: string;
  name: string;
  logoUrl: string;
  totalModels: number;
  activeJobs: number;
  popularModel: string;
}

@Component({
  selector: 'app-vehicle-models',
  templateUrl: './vehicle-models.component.html',
  styleUrls: ['./vehicle-models.component.scss'],
  standalone: false,
})
export class VehicleModelsComponent implements OnInit, AfterViewInit {
  // Table configuration
  readonly displayedColumns: string[] = [
    'select',
    'model',
    'yearRange',
    'type',
    'dimensions',
    'specialRequirements',
    'activeJobs',
    'actions',
  ];

  dataSource = new MatTableDataSource<VehicleModel>([]);
  selection = new SelectionModel<VehicleModel>(true, []);

  @ViewChild(MatSort) sort!: MatSort;
  @ViewChild(MatPaginator) paginator!: MatPaginator;

  // Data
  manufacturer: Manufacturer | null = null;
  modelToDelete: VehicleModel | null = null;
  currentYear = new Date().getFullYear();

  // Dialog state
  dialogData: VehicleModel | null = null;
  isEditMode = false;

  // State
  isLoading = false;
  isAdmin = false; // Should be controlled by auth service

  // Forms
  filterForm!: FormGroup;
  modelForm!: FormGroup;

  // Options for dropdowns
  readonly vehicleTypes = Object.values(VehicleType);
  readonly specialRequirements = Object.values(SpecialRequirement);

  // Template refs
  @ViewChild('modelDialog') modelDialog!: TemplateRef<any>;
  @ViewChild('archiveDialog') archiveDialog!: TemplateRef<any>;

  constructor(
    private route: ActivatedRoute,
    private router: Router,
    private dialog: MatDialog,
    private formBuilder: FormBuilder,
    private snackBar: MatSnackBar
  ) {
    this.initializeForms();
  }

  private initializeForms() {
    this.filterForm = this.formBuilder.group({
      search: [''],
      types: [[]],
      requirements: [[]],
      yearStart: [1990],
      yearEnd: [this.currentYear],
    });

    this.modelForm = this.formBuilder.group({
      name: ['', Validators.required],
      type: [VehicleType.SEDAN, Validators.required],
      yearStart: [
        this.currentYear,
        [
          Validators.required,
          Validators.min(1990),
          Validators.max(this.currentYear),
        ],
      ],
      yearEnd: [null],
      length: ['', [Validators.required, Validators.min(0)]],
      width: ['', [Validators.required, Validators.min(0)]],
      height: ['', [Validators.required, Validators.min(0)]],
      specialRequirements: [[]],
      imageUrl: [''],
    });
  }

  ngOnInit() {
    this.route.params.subscribe((params) => {
      const manufacturerId = params['id'];
      this.loadManufacturerDetails(manufacturerId);
      this.loadModels(manufacturerId);
    });

    this.filterForm.valueChanges.subscribe(() => {
      this.applyFilters();
    });
  }

  ngAfterViewInit() {
    this.dataSource.sort = this.sort;
    this.dataSource.paginator = this.paginator;
    this.setupCustomSort();
  }

  private setupCustomSort() {
    this.dataSource.sortingDataAccessor = (
      item: VehicleModel,
      property: string
    ) => {
      switch (property) {
        case 'model':
          return item.name;
        case 'yearRange':
          return item.yearStart;
        case 'activeJobs':
          return item.activeJobs;
        default:
          return (item as any)[property];
      }
    };
  }

  // CRUD Operations
  addModel() {
    this.isEditMode = false;
    this.dialogData = null;
    this.modelForm.reset({
      yearStart: this.currentYear,
      type: VehicleType.SEDAN,
      specialRequirements: [],
    });

    const dialogRef = this.dialog.open(this.modelDialog, {
      width: '600px',
    });

    dialogRef.afterClosed().subscribe((result) => {
      if (result) {
        this.saveModel();
      }
      this.dialogData = null;
    });
  }

  editModel(model: VehicleModel, event: Event) {
    event.stopPropagation();

    this.isEditMode = true;
    this.dialogData = model;
    this.modelForm.patchValue({
      name: model.name,
      type: model.type,
      yearStart: model.yearStart,
      yearEnd: model.yearEnd,
      length: model.dimensions.length,
      width: model.dimensions.width,
      height: model.dimensions.height,
      specialRequirements: model.specialRequirements,
      imageUrl: model.imageUrl,
    });

    const dialogRef = this.dialog.open(this.modelDialog, {
      width: '600px',
    });

    dialogRef.afterClosed().subscribe((result) => {
      if (result) {
        this.updateModel(model.id);
      }
      this.dialogData = null;
    });
  }

  archiveModel(model: VehicleModel, event: Event) {
    event.stopPropagation();
    this.modelToDelete = model;

    const dialogRef = this.dialog.open(this.archiveDialog, {
      width: '400px',
    });

    dialogRef.afterClosed().subscribe((result) => {
      if (result) {
        this.confirmArchive();
      }
      this.modelToDelete = null;
    });
  }

  saveModel() {
    if (this.modelForm.valid) {
      const formValue = this.modelForm.value;
      const modelData = {
        ...formValue,
        dimensions: {
          length: formValue.length,
          width: formValue.width,
          height: formValue.height,
        },
      };

      // TODO: Implement save logic
      console.log('Saving model:', modelData);

      this.dialog.closeAll();
      this.showSuccessMessage('Model added successfully');
      this.loadModels(this.manufacturer?.id || '');
    }
  }

  updateModel(id: string) {
    if (this.modelForm.valid) {
      const formValue = this.modelForm.value;
      const modelData = {
        id,
        ...formValue,
        dimensions: {
          length: formValue.length,
          width: formValue.width,
          height: formValue.height,
        },
      };

      // TODO: Implement update logic
      console.log('Updating model:', modelData);

      this.dialog.closeAll();
      this.showSuccessMessage('Model updated successfully');
      this.loadModels(this.manufacturer?.id || '');
    }
  }

  confirmArchive() {
    if (this.modelToDelete) {
      // TODO: Implement archive logic
      console.log('Archiving model:', this.modelToDelete.id);

      this.dialog.closeAll();
      this.showSuccessMessage('Model archived successfully');
      this.loadModels(this.manufacturer?.id || '');
    }
  }

  // Filter handling
  applyFilters() {
    const filterValue = this.filterForm.value;

    this.dataSource.filterPredicate = (data: VehicleModel) => {
      const matchesSearch =
        !filterValue.search ||
        data.name.toLowerCase().includes(filterValue.search.toLowerCase());

      const matchesType =
        !filterValue.types.length || filterValue.types.includes(data.type);

      const matchesRequirements =
        !filterValue.requirements.length ||
        filterValue.requirements.every((req: SpecialRequirement) =>
          data.specialRequirements.includes(req)
        );

      const matchesYear =
        data.yearStart >= filterValue.yearStart &&
        (!data.yearEnd || data.yearEnd <= filterValue.yearEnd);

      return matchesSearch && matchesType && matchesRequirements && matchesYear;
    };

    this.dataSource.filter = filterValue.search;
  }

  // Selection handling
  isAllSelected() {
    const numSelected = this.selection.selected.length;
    const numRows = this.dataSource.data.length;
    return numSelected === numRows;
  }

  toggleAllRows() {
    if (this.isAllSelected()) {
      this.selection.clear();
      return;
    }
    this.selection.select(...this.dataSource.data);
  }

  checkboxLabel(row?: VehicleModel): string {
    if (!row) {
      return `${this.isAllSelected() ? 'deselect' : 'select'} all`;
    }
    return `${this.selection.isSelected(row) ? 'deselect' : 'select'} row ${
      row.id
    }`;
  }

  // Navigation
  navigateBack() {
    this.router.navigate(['/vehicles']);
  }

  viewModelDetails(model: VehicleModel) {
    this.router.navigate(['/vehicles', model.id]);
  }

  // Utility Methods
  getRequirementClass(requirement: SpecialRequirement): string {
    const classMap: Record<SpecialRequirement, string> = {
      [SpecialRequirement.ENCLOSED_TRANSPORT]: 'requirement-enclosed',
      [SpecialRequirement.LIFT_GATE]: 'requirement-lift',
      [SpecialRequirement.OVERSIZED]: 'requirement-oversized',
      [SpecialRequirement.LOWERED]: 'requirement-lowered',
    };
    return classMap[requirement];
  }

  loadManufacturerDetails(manufacturerId: string) {
    // TODO: Replace with actual API call
    this.manufacturer = {
      id: manufacturerId,
      name: 'Toyota',
      logoUrl: '/assets/images/car-logos/toyota.png',
      totalModels: 25,
      activeJobs: 12,
      popularModel: 'Corolla',
    };
  }

  loadModels(manufacturerId: string) {
    this.isLoading = true;

    // Simulate API call
    setTimeout(() => {
      const mockData: VehicleModel[] = [
        {
          id: '1',
          name: 'Corolla',
          imageUrl: '/assets/images/corolla.jpg',
          yearStart: 2018,
          yearEnd: null,
          type: VehicleType.SEDAN,
          dimensions: {
            length: 192.7,
            width: 72.4,
            height: 56.9,
          },
          specialRequirements: [SpecialRequirement.LOWERED],
          activeJobs: 5,
        },
      ];

      this.dataSource.data = mockData;
      this.isLoading = false;
    }, 1000);
  }

  showSuccessMessage(message: string) {
    this.snackBar.open(message, 'Close', {
      duration: 3000,
      horizontalPosition: 'end',
      verticalPosition: 'top',
    });
  }
}


--- ./src/app/pages/vehicles/vehicle-models/vehicle-models.component.html ---
<!-- vehicle-models.component.html -->
<mat-card class="mat-elevation-z3">
  <!-- Header -->
  <div class="header-wrapper">
    <div class="header-content">
      <div class="manufacturer-info">
        <img
          [src]="manufacturer?.logoUrl"
          [alt]="manufacturer?.name + ' logo'"
          class="manufacturer-logo"
        />
        <div class="info">
          <h1>{{ manufacturer?.name }} Models</h1>
          <div class="quick-stats">
            <div class="stat">
              <span class="label">Total Models</span>
              <span class="value">{{ manufacturer?.totalModels }}</span>
            </div>
            <div class="stat">
              <span class="label">Active Jobs</span>
              <span class="value">{{ manufacturer?.activeJobs }}</span>
            </div>
            <div class="stat">
              <span class="label">Most Popular</span>
              <span class="value">{{ manufacturer?.popularModel }}</span>
            </div>
          </div>
        </div>
      </div>

      <div class="header-actions">
        <button mat-stroked-button (click)="navigateBack()">
          <mat-icon>arrow_back</mat-icon>
          Back to Makes
        </button>

        <button
          mat-flat-button
          color="primary"
          *ngIf="isAdmin"
          (click)="addModel()"
        >
          <mat-icon>add</mat-icon>
          Add Model
        </button>
      </div>
    </div>
  </div>

  <!-- Filters -->
  <div class="filters-wrapper" [formGroup]="filterForm">
    <mat-form-field appearance="outline" class="search-field">
      <mat-label>Search models</mat-label>
      <input
        matInput
        formControlName="search"
        placeholder="Search by name or details"
      />
      <mat-icon matSuffix>search</mat-icon>
    </mat-form-field>

    <div class="filter-groups">
      <mat-form-field appearance="outline">
        <mat-label>Vehicle Type</mat-label>
        <mat-select formControlName="types" multiple>
          <mat-option *ngFor="let type of vehicleTypes" [value]="type">
            {{ type }}
          </mat-option>
        </mat-select>
      </mat-form-field>

      <mat-form-field appearance="outline">
        <mat-label>Special Requirements</mat-label>
        <mat-select formControlName="requirements" multiple>
          <mat-option *ngFor="let req of specialRequirements" [value]="req">
            {{ req }}
          </mat-option>
        </mat-select>
      </mat-form-field>

      <div class="year-range">
        <mat-form-field appearance="outline">
          <mat-label>Year From</mat-label>
          <input
            matInput
            type="number"
            formControlName="yearStart"
            min="1990"
            [max]="filterForm.get('yearEnd')?.value"
          />
        </mat-form-field>

        <mat-form-field appearance="outline">
          <mat-label>Year To</mat-label>
          <input
            matInput
            type="number"
            formControlName="yearEnd"
            [min]="filterForm.get('yearStart')?.value"
            [max]="currentYear"
          />
        </mat-form-field>
      </div>
    </div>
  </div>

  <!-- Table Container -->
  <div class="table-container">
    <!-- Loading Overlay -->
    <div class="loading-overlay" *ngIf="isLoading">
      <mat-spinner diameter="40"></mat-spinner>
      <span>Loading models...</span>
    </div>

    <!-- Table -->
    <table
      mat-table
      [dataSource]="dataSource"
      matSort
      [class.loading]="isLoading"
    >
      <!-- Checkbox Column -->
      <ng-container matColumnDef="select">
        <th mat-header-cell *matHeaderCellDef>
          <mat-checkbox
            (change)="$event ? toggleAllRows() : null"
            [checked]="selection.hasValue() && isAllSelected()"
            [indeterminate]="selection.hasValue() && !isAllSelected()"
            [aria-label]="checkboxLabel()"
          >
          </mat-checkbox>
        </th>
        <td mat-cell *matCellDef="let row">
          <mat-checkbox
            (click)="$event.stopPropagation()"
            (change)="$event ? selection.toggle(row) : null"
            [checked]="selection.isSelected(row)"
            [aria-label]="checkboxLabel(row)"
          >
          </mat-checkbox>
        </td>
      </ng-container>

      <!-- Model Column -->
      <ng-container matColumnDef="model">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Model</th>
        <td mat-cell *matCellDef="let model">
          <div class="model-info">
            <img [src]="model.imageUrl" [alt]="model.name" />
            <a (click)="$event.stopPropagation(); viewModelDetails(model)">{{
              model.name
            }}</a>
          </div>
        </td>
      </ng-container>

      <!-- Year Range Column -->
      <ng-container matColumnDef="yearRange">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Year Range</th>
        <td mat-cell *matCellDef="let model">
          {{ model.yearStart }} - {{ model.yearEnd || "Present" }}
        </td>
      </ng-container>

      <!-- Type Column -->
      <ng-container matColumnDef="type">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Type</th>
        <td mat-cell *matCellDef="let model">
          <span class="type-chip">{{ model.type }}</span>
        </td>
      </ng-container>

      <!-- Dimensions Column -->
      <ng-container matColumnDef="dimensions">
        <th mat-header-cell *matHeaderCellDef>Dimensions</th>
        <td mat-cell *matCellDef="let model">
          {{ model.dimensions.length }}L x {{ model.dimensions.width }}W x
          {{ model.dimensions.height }}H
        </td>
      </ng-container>

      <!-- Special Requirements Column -->
      <ng-container matColumnDef="specialRequirements">
        <th mat-header-cell *matHeaderCellDef>Special Requirements</th>
        <td mat-cell *matCellDef="let model">
          <div class="requirements-list">
            <mat-chip-set>
              <mat-chip
                *ngFor="let req of model.specialRequirements"
                [class]="getRequirementClass(req)"
                [matTooltip]="req"
              >
                {{ req }}
              </mat-chip>
            </mat-chip-set>
          </div>
        </td>
      </ng-container>

      <!-- Active Jobs Column -->
      <ng-container matColumnDef="activeJobs">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Active Jobs</th>
        <td mat-cell *matCellDef="let model">
          <span class="jobs-count" [class.has-jobs]="model.activeJobs > 0">
            {{ model.activeJobs }}
          </span>
        </td>
      </ng-container>

      <!-- Actions Column -->
      <ng-container matColumnDef="actions">
        <th mat-header-cell *matHeaderCellDef></th>
        <td mat-cell *matCellDef="let model">
          <button
            mat-icon-button
            [matMenuTriggerFor]="menu"
            (click)="$event.stopPropagation()"
          >
            <mat-icon>more_vert</mat-icon>
          </button>
          <mat-menu #menu="matMenu" xPosition="before">
            <button mat-menu-item (click)="editModel(model, $event)">
              <mat-icon>edit</mat-icon>
              <span>Edit</span>
            </button>
            <button mat-menu-item (click)="viewModelDetails(model)">
              <mat-icon>visibility</mat-icon>
              <span>View Details</span>
            </button>
            <button
              mat-menu-item
              (click)="archiveModel(model, $event)"
              class="archive-action"
            >
              <mat-icon>archive</mat-icon>
              <span>Archive</span>
            </button>
          </mat-menu>
        </td>
      </ng-container>

      <!-- Header and Row Definitions -->
      <tr mat-header-row *matHeaderRowDef="displayedColumns; sticky: true"></tr>
      <tr
        mat-row
        *matRowDef="let row; columns: displayedColumns"
        (click)="viewModelDetails(row)"
        [class.selected]="selection.isSelected(row)"
        class="model-row"
      ></tr>
    </table>

    <!-- Empty State -->
    <div
      class="empty-state"
      *ngIf="!isLoading && dataSource.filteredData.length === 0"
    >
      <mat-icon class="empty-icon">directions_car</mat-icon>
      <h3>No models found</h3>
      <p>Try adjusting your filters or add a new model</p>
      <button
        mat-flat-button
        color="primary"
        *ngIf="isAdmin"
        (click)="addModel()"
      >
        <mat-icon>add</mat-icon>
        Add Model
      </button>
    </div>
  </div>

  <!-- Paginator -->
  <mat-paginator
    [length]="dataSource.filteredData.length"
    [pageSize]="10"
    [pageSizeOptions]="[5, 10, 25, 50]"
    showFirstLastButtons
  >
  </mat-paginator>
</mat-card>

<!-- Add/Edit Model Dialog -->
<ng-template #modelDialog let-data>
  <h2 mat-dialog-title>{{ data ? "Edit" : "Add New" }} Model</h2>
  <mat-dialog-content>
    <form [formGroup]="modelForm" class="model-form">
      <mat-form-field appearance="outline">
        <mat-label>Name</mat-label>
        <input matInput formControlName="name" required />
      </mat-form-field>

      <mat-form-field appearance="outline">
        <mat-label>Type</mat-label>
        <mat-select formControlName="type" required>
          <mat-option *ngFor="let type of vehicleTypes" [value]="type">
            {{ type }}
          </mat-option>
        </mat-select>
      </mat-form-field>

      <div class="year-range">
        <mat-form-field appearance="outline">
          <mat-label>Year Start</mat-label>
          <input
            matInput
            type="number"
            formControlName="yearStart"
            required
            [min]="1990"
            [max]="currentYear"
          />
        </mat-form-field>

        <mat-form-field appearance="outline">
          <mat-label>Year End</mat-label>
          <input
            matInput
            type="number"
            formControlName="yearEnd"
            [min]="modelForm.get('yearStart')?.value"
            [max]="currentYear"
          />
          <mat-hint>Leave empty for current models</mat-hint>
        </mat-form-field>
      </div>

      <div class="dimensions">
        <mat-form-field appearance="outline">
          <mat-label>Length (in)</mat-label>
          <input
            matInput
            type="number"
            formControlName="length"
            required
            min="0"
            step="0.1"
          />
        </mat-form-field>

        <mat-form-field appearance="outline">
          <mat-label>Width (in)</mat-label>
          <input
            matInput
            type="number"
            formControlName="width"
            required
            min="0"
            step="0.1"
          />
        </mat-form-field>

        <mat-form-field appearance="outline">
          <mat-label>Height (in)</mat-label>
          <input
            matInput
            type="number"
            formControlName="height"
            required
            min="0"
            step="0.1"
          />
        </mat-form-field>
      </div>

      <mat-form-field appearance="outline">
        <mat-label>Special Requirements</mat-label>
        <mat-select formControlName="specialRequirements" multiple>
          <mat-option *ngFor="let req of specialRequirements" [value]="req">
            {{ req }}
          </mat-option>
        </mat-select>
      </mat-form-field>

      <mat-form-field appearance="outline">
        <mat-label>Image URL</mat-label>
        <input matInput formControlName="imageUrl" />
        <mat-hint>Enter URL for model image</mat-hint>
      </mat-form-field>
    </form>
  </mat-dialog-content>
  <mat-dialog-actions align="end">
    <button mat-button mat-dialog-close>Cancel</button>
    <button
      mat-flat-button
      color="primary"
      [disabled]="modelForm.invalid"
      (click)="saveModel()"
    >
      Save
    </button>
  </mat-dialog-actions>
</ng-template>

<!-- Archive Confirmation Dialog -->
<ng-template #archiveDialog>
  <h2 mat-dialog-title>Archive Model</h2>
  <mat-dialog-content>
    Are you sure you want to archive this model? This will hide it from active
    listings.
  </mat-dialog-content>
  <mat-dialog-actions align="end">
    <button mat-button mat-dialog-close>Cancel</button>
    <button mat-flat-button color="warn" (click)="confirmArchive()">
      Archive
    </button>
  </mat-dialog-actions>
</ng-template>


--- ./src/app/pages/vehicles/vehicle-models/vehicle-models.component.scss ---


--- ./src/app/pages/jobs/job-create/job-create.component.scss ---
/* job-create.component.scss - updated for split journey support */

.create-job-container {
  min-height: 100vh;
  background-color: #f8f9fa;
  padding: 24px;
  margin-left: 250px; /* Account for sidebar */
  padding-top: 88px; /* Account for topbar height (64px) + some padding */
}

.create-job-content {
  max-width: 800px;
  margin: 0 auto;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* Loading Overlay */
.loading-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.9);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  gap: 16px;
}

.loading-overlay span {
  color: rgba(0, 0, 0, 0.6);
  font-size: 14px;
  margin-top: 8px;
}

/* Header */
.form-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 24px;
  border-bottom: 1px solid #eee;
}

.form-header h1 {
  margin: 0;
  font-size: 24px;
  color: #333;
}

.cancel-btn {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  border: 1px solid #ddd;
  border-radius: 4px;
  background-color: white;
  color: #666;
  cursor: pointer;
  transition: all 0.2s ease;
}

.cancel-btn:hover {
  border-color: #dc3545;
  color: #dc3545;
}

.cancel-btn .material-icons {
  font-size: 18px;
}

/* Form */
.job-form {
  padding: 24px;
}

.form-section {
  margin-bottom: 32px;
  padding-bottom: 32px;
  border-bottom: 1px solid #eee;
}

.form-section:last-child {
  border-bottom: none;
  margin-bottom: 0;
  padding-bottom: 0;
}

.form-section h2 {
  font-size: 18px;
  color: #333;
  margin: 0 0 20px 0;
}

.form-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 16px;
}

.form-group {
  margin-bottom: 20px;
}

.form-group.full-width {
  grid-column: 1 / -1;
}

.form-group label {
  display: block;
  margin-bottom: 8px;
  color: #666;
  font-size: 14px;
}

.form-group input,
.form-group select,
.form-group textarea {
  width: 100%;
  padding: 10px 12px;
  border: 1px solid #ddd;
  border-radius: 4px;
  background-color: white;
  color: #333;
  font-family: 'UberMove', sans-serif;
  font-size: 14px;
  font-weight: 400;
}

.form-group input::placeholder,
.form-group select::placeholder,
.form-group textarea::placeholder {
  color: #999;
  font-weight: 300;
}

.form-group input:focus,
.form-group select:focus,
.form-group textarea:focus {
  outline: none;
  border-color: #007bff;
  box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
}

.form-group input.ng-touched.ng-invalid,
.form-group select.ng-touched.ng-invalid,
.form-group textarea.ng-touched.ng-invalid {
  border-color: #dc3545;
}

.form-group input.ng-touched.ng-invalid:focus,
.form-group select.ng-touched.ng-invalid:focus,
.form-group textarea.ng-touched.ng-invalid:focus {
  box-shadow: 0 0 0 3px rgba(220, 53, 69, 0.1);
}

.form-group textarea {
  resize: vertical;
  min-height: 100px;
}

.form-group select {
  appearance: none;
  background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
  background-repeat: no-repeat;
  background-position: right 12px center;
  background-size: 16px;
  padding-right: 40px;
}

.error-message {
  display: block;
  color: #dc3545;
  font-size: 12px;
  margin-top: 4px;
  min-height: 20px;
}

/* Previous Selections */
.previous-selections {
  margin-top: 20px;
}

.previous-selections h3 {
  font-size: 15px;
  color: #555;
  margin-bottom: 10px;
}

.selection-pills {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 16px;
}

.selection-pill {
  background-color: #f0f0f0;
  padding: 8px 12px;
  border-radius: 20px;
  font-size: 14px;
  cursor: pointer;
  transition: background-color 0.2s;
}

.selection-pill:hover {
  background-color: #e0e0e0;
}

/* Journey Type Section */
.journey-type-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.split-journey-toggle {
  display: flex;
  align-items: center;
  gap: 12px;
}

.toggle-btn {
  display: flex;
  align-items: center;
  gap: 8px;
  background: none;
  border: none;
  color: #333;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  padding: 6px 12px;
  border-radius: 4px;
  transition: background-color 0.2s;
}

.toggle-btn:hover {
  background-color: #f0f0f0;
}

.toggle-btn .material-icons {
  color: #007bff;
  font-size: 20px;
}

.journey-info {
  display: flex;
  align-items: center;
  gap: 4px;
  color: #666;
  font-size: 13px;
}

.info-icon {
  color: #007bff;
  font-size: 16px;
}

/* Journey Visualization */
.journey-visualization {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 16px;
  background-color: #f8f9fa;
  border-radius: 8px;
  margin-bottom: 20px;
  flex-wrap: wrap;
  gap: 8px;
}

.journey-step {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  padding: 12px;
  border-radius: 8px;
  min-width: 120px;
}

.journey-step.primary {
  background-color: #e3f2fd;
}

.journey-step.secondary {
  background-color: #fff8e1;
}

.step-icon {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  border-radius: 50%;
  background-color: white;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.journey-step.primary .step-icon {
  color: #1976d2;
}

.journey-step.secondary .step-icon {
  color: #f57c00;
}

.step-icon .material-icons {
  font-size: 20px;
}

.step-label {
  font-size: 12px;
  font-weight: 500;
  color: #555;
}

.journey-arrow {
  display: flex;
  align-items: center;
  color: #999;
}

.journey-arrow .material-icons {
  font-size: 20px;
}

/* Checkbox Group */
.checkbox-group {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 8px;
}

.checkbox-group input[type='checkbox'] {
  width: auto;
}

/* Form Actions */
.form-actions {
  display: flex;
  justify-content: center;
  padding-top: 32px;
  margin-top: 32px;
  border-top: 1px solid #eee;
}

.submit-btn {
  padding: 12px 32px;
  background-color: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  font-size: 16px;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.submit-btn:hover {
  background-color: #0056b3;
}

.submit-btn:disabled {
  background-color: #ccc;
  cursor: not-allowed;
}

/* Responsive Design */
@media (max-width: 768px) {
  .create-job-container {
    margin-left: 60px; /* Collapsed sidebar width */
    padding: 16px;
    padding-top: 80px; /* Adjusted top padding for collapsed topbar */
  }

  .form-grid {
    grid-template-columns: 1fr;
  }

  .form-header {
    flex-direction: column;
    align-items: flex-start;
    gap: 16px;
    padding: 16px;
  }

  .form-header .cancel-btn {
    width: 100%;
    justify-content: center;
  }

  .job-form {
    padding: 16px;
  }

  .form-section {
    margin-bottom: 24px;
    padding-bottom: 24px;
  }

  .form-section h2 {
    font-size: 16px;
    margin-bottom: 16px;
  }

  .form-group {
    margin-bottom: 16px;
  }

  .form-group input,
  .form-group select,
  .form-group textarea {
    font-size: 16px; /* Prevent zoom on iOS */
    padding: 12px;
  }

  .journey-type-header {
    flex-direction: column;
    align-items: flex-start;
    gap: 12px;
  }

  .split-journey-toggle {
    width: 100%;
  }

  .journey-visualization {
    flex-direction: column;
    align-items: stretch;
  }

  .journey-step {
    width: 100%;
    flex-direction: row;
    justify-content: flex-start;
    min-width: 0;
  }

  .journey-arrow {
    transform: rotate(90deg);
    margin: 4px 0;
  }

  .form-actions {
    padding-top: 24px;
    margin-top: 24px;
  }

  .submit-btn {
    width: 100%;
    padding: 14px 32px;
  }
}

@media (max-width: 600px) {
  .create-job-container {
    padding: 8px;
    padding-top: 72px; /* Further adjusted for smaller screens */
  }
}

/* Print Styles */
@media print {
  .create-job-container {
    margin-left: 0; /* No sidebar in print */
    padding: 0;
    padding-top: 0; /* No topbar in print */
    background: white;
  }

  .create-job-content {
    box-shadow: none;
    max-width: none;
  }

  .cancel-btn {
    display: none;
  }
}


--- ./src/app/pages/jobs/job-create/job-create.component.ts ---
import { Component, OnInit, OnDestroy } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Router } from '@angular/router';
import { Observable, Subscription, forkJoin } from 'rxjs';
import { finalize } from 'rxjs/operators';
import { JobService } from '../../../services/job.service';
import { AuthService } from '../../../services/auth.service';
import { VehicleService, VehicleMake, VehicleModel } from '../../../services/vehicle.service';
import { CustomerService } from '../../../services/customer.service';
import { Customer } from '../../../interfaces/customer.interface';
import { MatSnackBar } from '@angular/material/snack-bar';
import { MatDialog } from '@angular/material/dialog';
import { ConfirmationDialogComponent } from '../../../dialogs/confirmation-dialog.component';

@Component({
  selector: 'app-job-create',
  templateUrl: './job-create.component.html',
  styleUrls: ['./job-create.component.scss'],
  standalone: false,
})
export class JobCreateComponent implements OnInit, OnDestroy {
  jobForm!: FormGroup;
  isSubmitting = false;
  isLoading = true;

  // Reference data
  customers: Customer[] = [];
  vehicleMakes: VehicleMake[] = [];
  availableModels: VehicleModel[] = [];
  allModels: VehicleModel[] = [];
  vehicleTypes: string[] = [];

  // Previous selections for easy re-use
  previousSelections: any[] = [];

  private subscriptions: Subscription[] = [];

  constructor(
    private fb: FormBuilder,
    private router: Router,
    private jobService: JobService,
    private authService: AuthService,
    private vehicleService: VehicleService,
    private customerService: CustomerService,
    private snackBar: MatSnackBar,
    private dialog: MatDialog
  ) {
    this.createForm();
  }

  ngOnInit() {
    // Load reference data
    this.loadReferenceData();

    // Set up form listeners
    this.setupFormListeners();

    // Check for access permissions
    this.checkPermissions();
  }

  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }

  createForm() {
    this.jobForm = this.fb.group({
      // Customer Information
      customerId: ['', Validators.required],

      // Vehicle Information
      vehicleMake: ['', Validators.required],
      vehicleModel: ['', Validators.required],
      vehicleType: ['', Validators.required],
      registration: ['', [Validators.required, Validators.pattern(/^[A-Z0-9]+$/)]],
      chassisNumber: ['', Validators.pattern(/^[A-Z0-9]+$/)],
      color: [''],
      year: [''],

      // Primary Collection Details
      collectionAddress: ['', Validators.required],
      collectionCity: [''],
      collectionPostcode: [''],
      collectionContactName: [''],
      collectionContactPhone: [''],
      collectionNotes: [''],

      // Final Delivery Details
      deliveryAddress: ['', Validators.required],
      deliveryCity: [''],
      deliveryPostcode: [''],
      deliveryContactName: [''],
      deliveryContactPhone: [''],
      deliveryNotes: [''],

      // Job Settings
      isSplitJourney: [false],

      // Secondary Collection Details
      secondaryCollectionAddress: [''],
      secondaryCollectionCity: [''],
      secondaryCollectionPostcode: [''],
      secondaryCollectionContactName: [''],
      secondaryCollectionContactPhone: [''],
      secondaryCollectionNotes: [''],

      // Secondary Delivery Details
      secondaryDeliveryAddress: [''],
      secondaryDeliveryCity: [''],
      secondaryDeliveryPostcode: [''],
      secondaryDeliveryContactName: [''],
      secondaryDeliveryContactPhone: [''],
      secondaryDeliveryNotes: [''],

      // General notes
      notes: [''],
    });
  }

  private loadReferenceData() {
    this.isLoading = true;

    // Load all reference data in parallel
    const referenceDataSub = forkJoin({
      customers: this.customerService.getCustomers(),
      makes: this.vehicleService.getVehicleMakes(),
      models: this.vehicleService.getVehicleModels(),
      types: this.vehicleService.getVehicleTypes(),
    }).subscribe({
      next: (data) => {
        this.customers = data.customers;
        this.vehicleMakes = data.makes;
        this.allModels = data.models;
        this.vehicleTypes = data.types;
        this.isLoading = false;
      },
      error: (error) => {
        console.error('Error loading reference data:', error);
        this.showSnackbar('Error loading data. Please try again.');
        this.isLoading = false;
      },
    });

    this.subscriptions.push(referenceDataSub);

    // Load previous vehicle selections
    this.loadPreviousVehicleSelections();
  }

  private checkPermissions() {
    const permissionSub = this.authService.hasPermission('canCreateJobs').subscribe((hasPermission) => {
      if (!hasPermission) {
        this.showSnackbar('You do not have permission to create jobs');
        this.router.navigate(['/jobs']);
      }
    });

    this.subscriptions.push(permissionSub);
  }

  private setupFormListeners() {
    // Listen to make changes to update models
    const makeSub = this.jobForm.get('vehicleMake')?.valueChanges.subscribe((makeId) => {
      this.updateAvailableModels(makeId);
    });

    if (makeSub) this.subscriptions.push(makeSub);

    // Listen to model changes to update vehicle type
    const modelSub = this.jobForm.get('vehicleModel')?.valueChanges.subscribe((modelId) => {
      this.updateVehicleType(modelId);
    });

    if (modelSub) this.subscriptions.push(modelSub);

    // Listen to split journey toggle to update validation
    const splitJourneySub = this.jobForm.get('isSplitJourney')?.valueChanges.subscribe((isSplit) => {
      this.updateSplitJourneyValidation(isSplit);
    });

    if (splitJourneySub) this.subscriptions.push(splitJourneySub);
  }

  private updateSplitJourneyValidation(isSplit: boolean) {
    // Get the form controls for secondary addresses
    const secondaryCollectionAddress = this.jobForm.get('secondaryCollectionAddress');
    const secondaryDeliveryAddress = this.jobForm.get('secondaryDeliveryAddress');

    if (isSplit) {
      // If it's a split journey, make secondary addresses required
      secondaryCollectionAddress?.setValidators([Validators.required]);
      secondaryDeliveryAddress?.setValidators([Validators.required]);
    } else {
      // Otherwise, remove validators
      secondaryCollectionAddress?.clearValidators();
      secondaryDeliveryAddress?.clearValidators();

      // Reset secondary address values
      secondaryCollectionAddress?.setValue('');
      secondaryDeliveryAddress?.setValue('');
      this.jobForm.get('secondaryCollectionCity')?.setValue('');
      this.jobForm.get('secondaryCollectionPostcode')?.setValue('');
      this.jobForm.get('secondaryCollectionContactName')?.setValue('');
      this.jobForm.get('secondaryCollectionContactPhone')?.setValue('');
      this.jobForm.get('secondaryCollectionNotes')?.setValue('');
      this.jobForm.get('secondaryDeliveryCity')?.setValue('');
      this.jobForm.get('secondaryDeliveryPostcode')?.setValue('');
      this.jobForm.get('secondaryDeliveryContactName')?.setValue('');
      this.jobForm.get('secondaryDeliveryContactPhone')?.setValue('');
      this.jobForm.get('secondaryDeliveryNotes')?.setValue('');
    }

    // Update validation status
    secondaryCollectionAddress?.updateValueAndValidity();
    secondaryDeliveryAddress?.updateValueAndValidity();
  }

  private updateAvailableModels(makeId: string) {
    if (!makeId) {
      this.availableModels = [];
      return;
    }

    // If we already loaded all models, filter them locally for faster performance
    this.availableModels = this.allModels.filter((model) => model.makeId === makeId && model.isActive);

    // Reset model selection
    this.jobForm.get('vehicleModel')?.setValue('');
    this.jobForm.get('vehicleType')?.setValue('');
  }

  private updateVehicleType(modelId: string) {
    if (!modelId) {
      return;
    }

    const selectedModel = this.allModels.find((model) => model.id === modelId);

    if (selectedModel) {
      this.jobForm.get('vehicleType')?.setValue(selectedModel.type);
    }
  }

  private loadPreviousVehicleSelections() {
    // Retrieve previous selections from localStorage
    const savedSelections = localStorage.getItem('previousVehicleSelections');

    if (savedSelections) {
      try {
        this.previousSelections = JSON.parse(savedSelections);
      } catch (e) {
        console.error('Error parsing saved vehicle selections:', e);
        this.previousSelections = [];
      }
    }
  }

  getMakeDisplayName(makeId: string): string {
    const make = this.vehicleMakes.find((m) => m.id === makeId);
    return make ? make.displayName : '';
  }

  /**
   * Auto-populate customer address information when a customer is selected
   */
  onCustomerSelected(event: Event) {
    const select = event.target as HTMLSelectElement;
    const customerId = select?.value;

    if (!customerId) return;

    const selectedCustomer = this.customers.find((c) => c.id === customerId);

    if (selectedCustomer && selectedCustomer.address) {
      // Auto-populate the collection address with customer info
      this.jobForm.patchValue({
        collectionAddress: selectedCustomer.address || '',
        collectionCity: selectedCustomer.city || '',
        collectionPostcode: selectedCustomer.postcode || '',
        collectionContactName: selectedCustomer.name || '',
        collectionContactPhone: selectedCustomer.phone || '',
      });
    }
  }

  /**
   * Apply previously used vehicle details
   */
  applyPreviousSelection(selection: any) {
    this.jobForm.patchValue({
      vehicleMake: selection.makeId,
      vehicleModel: selection.modelId,
      registration: selection.registration,
      chassisNumber: selection.chassisNumber || '',
      color: selection.color || '',
      year: selection.year || '',
    });

    // Make sure models list is updated
    this.updateAvailableModels(selection.makeId);

    // Delay setting the model to ensure the models list is populated
    setTimeout(() => {
      this.jobForm.patchValue({
        vehicleModel: selection.modelId,
      });
    }, 100);
  }

  /**
   * Toggle split journey mode
   */
  toggleSplitJourney() {
    const currentValue = this.jobForm.get('isSplitJourney')?.value;
    this.jobForm.get('isSplitJourney')?.setValue(!currentValue);

    // If turning on split journey, show a dialog with information
    if (!currentValue) {
      this.showSplitJourneyInfo();
    }
  }

  /**
   * Show information dialog about split journey
   */
  showSplitJourneyInfo() {
    const dialogRef = this.dialog.open(ConfirmationDialogComponent, {
      data: {
        title: 'Split Journey',
        message: 'You have enabled split journey mode. This allows you to specify additional collection and delivery points. Please fill in all required address fields.',
        confirmText: 'Got it',
        cancelText: 'Disable Split Journey',
        icon: 'call_split',
      },
      width: '400px',
    });

    dialogRef.afterClosed().subscribe((result) => {
      if (result === false) {
        this.jobForm.get('isSplitJourney')?.setValue(false);
      }
    });
  }

  onCancel() {
    this.router.navigate(['/jobs']);
  }

  onSubmit() {
    if (this.jobForm.invalid) {
      this.markFormGroupTouched(this.jobForm);
      this.showSnackbar('Please complete all required fields');
      return;
    }

    this.isSubmitting = true;

    const formValue = this.jobForm.value;

    // Get make and model display names
    const selectedMake = this.vehicleMakes.find((m) => m.id === formValue.vehicleMake);
    const selectedModel = this.availableModels.find((m) => m.id === formValue.vehicleModel);

    // Customer info
    const selectedCustomer = this.customers.find((c) => c.id === formValue.customerId);

    // Prepare job data matching the Job interface
    const jobData = {
      vehicleId: formValue.chassisNumber || formValue.registration, // Using reg/chassis as vehicle ID
      status: 'unallocated' as 'unallocated',
      make: selectedMake?.displayName || '',
      model: selectedModel?.name || '',
      registration: formValue.registration.toUpperCase(),

      // Customer info
      customerId: formValue.customerId,
      customerName: selectedCustomer?.name || '',
      customerContact: selectedCustomer?.name || '',
      customerContactPhone: selectedCustomer?.phone || '',

      // Primary Collection
      collectionAddress: formValue.collectionAddress,
      collectionCity: formValue.collectionCity,
      collectionPostcode: formValue.collectionPostcode,
      collectionContactName: formValue.collectionContactName,
      collectionContactPhone: formValue.collectionContactPhone,
      collectionNotes: formValue.collectionNotes,

      // Final Delivery
      deliveryAddress: formValue.deliveryAddress,
      deliveryCity: formValue.deliveryCity,
      deliveryPostcode: formValue.deliveryPostcode,
      deliveryContactName: formValue.deliveryContactName,
      deliveryContactPhone: formValue.deliveryContactPhone,
      deliveryNotes: formValue.deliveryNotes,

      // Vehicle details
      color: formValue.color,
      year: formValue.year,
      chassisNumber: formValue.chassisNumber ? formValue.chassisNumber.toUpperCase() : '',
      vehicleType: formValue.vehicleType,

      // Split journey flag
      isSplitJourney: formValue.isSplitJourney,

      // Only include secondary addresses if this is a split journey
      ...(formValue.isSplitJourney && {
        // Secondary Collection
        secondaryCollectionAddress: formValue.secondaryCollectionAddress,
        secondaryCollectionCity: formValue.secondaryCollectionCity,
        secondaryCollectionPostcode: formValue.secondaryCollectionPostcode,
        secondaryCollectionContactName: formValue.secondaryCollectionContactName,
        secondaryCollectionContactPhone: formValue.secondaryCollectionContactPhone,
        secondaryCollectionNotes: formValue.secondaryCollectionNotes,

        // Secondary Delivery
        secondaryDeliveryAddress: formValue.secondaryDeliveryAddress,
        secondaryDeliveryCity: formValue.secondaryDeliveryCity,
        secondaryDeliveryPostcode: formValue.secondaryDeliveryPostcode,
        secondaryDeliveryContactName: formValue.secondaryDeliveryContactName,
        secondaryDeliveryContactPhone: formValue.secondaryDeliveryContactPhone,
        secondaryDeliveryNotes: formValue.secondaryDeliveryNotes,
      }),

      // Notes
      notes: formValue.notes,
    };

    // Save the vehicle selection for future use
    this.saveToRecentSelections();

    // Create the job
    this.jobService
      .createJob(jobData)
      .pipe(finalize(() => (this.isSubmitting = false)))
      .subscribe({
        next: (jobId) => {
          this.showSnackbar('Job created successfully');
          this.router.navigate(['/jobs', jobId]);
        },
        error: (error) => {
          console.error('Error creating job:', error);
          this.showSnackbar(`Error creating job: ${error.message}`);
        },
      });
  }

  /**
   * Save current vehicle information to previous selections
   */
  saveToRecentSelections() {
    const formValue = this.jobForm.value;

    // Only save if we have the minimum required information
    if (!formValue.vehicleMake || !formValue.vehicleModel || !formValue.registration) {
      return;
    }

    const selectedMake = this.vehicleMakes.find((m) => m.id === formValue.vehicleMake);
    const selectedModel = this.availableModels.find((m) => m.id === formValue.vehicleModel);

    if (!selectedMake || !selectedModel) {
      return;
    }

    const vehicleSelection = {
      makeId: formValue.vehicleMake,
      makeName: selectedMake.displayName,
      modelId: formValue.vehicleModel,
      modelName: selectedModel.name,
      registration: formValue.registration,
      chassisNumber: formValue.chassisNumber || '',
      color: formValue.color || '',
      year: formValue.year || '',
      timestamp: new Date().toISOString(),
    };

    // Get existing selections
    let selections = [];
    try {
      const savedData = localStorage.getItem('previousVehicleSelections');
      selections = savedData ? JSON.parse(savedData) : [];
    } catch (e) {
      console.error('Error retrieving previous vehicle selections:', e);
      selections = [];
    }

    // Check if this registration already exists
    const existingIndex = selections.findIndex((s: { registration: string }) => s.registration.toLowerCase() === vehicleSelection.registration.toLowerCase());

    if (existingIndex >= 0) {
      // Update existing entry
      selections[existingIndex] = vehicleSelection;
    } else {
      // Add new entry
      selections.unshift(vehicleSelection);

      // Keep max 10 entries
      if (selections.length > 10) {
        selections = selections.slice(0, 10);
      }
    }

    // Save back to localStorage
    localStorage.setItem('previousVehicleSelections', JSON.stringify(selections));

    // Update the component state
    this.previousSelections = selections;
  }

  private markFormGroupTouched(formGroup: FormGroup) {
    Object.values(formGroup.controls).forEach((control) => {
      control.markAsTouched();

      if (control instanceof FormGroup) {
        this.markFormGroupTouched(control);
      }
    });
  }

  getErrorMessage(controlName: string): string {
    const control = this.jobForm.get(controlName);

    if (!control || !control.errors || !control.touched) {
      return '';
    }

    if (control.errors['required']) {
      return 'This field is required';
    }

    if (control.errors['pattern']) {
      if (controlName === 'registration' || controlName === 'chassisNumber') {
        return 'Must be uppercase with no spaces';
      }
      return 'Invalid format';
    }

    return 'Invalid value';
  }

  showSnackbar(message: string): void {
    this.snackBar.open(message, 'Close', {
      duration: 5000,
      horizontalPosition: 'center',
      verticalPosition: 'bottom',
    });
  }
}


--- ./src/app/pages/jobs/job-create/job-create.component.html ---
<div class="create-job-container">
  <!-- Loading Spinner -->
  <div class="loading-overlay" *ngIf="isLoading">
    <mat-spinner diameter="40"></mat-spinner>
    <span>Loading...</span>
  </div>

  <div class="create-job-content">
    <div class="form-header">
      <h1>Create Job</h1>
      <button type="button" class="cancel-btn" (click)="onCancel()">
        <span class="material-icons">close</span>
        Cancel
      </button>
    </div>

    <form [formGroup]="jobForm" (ngSubmit)="onSubmit()" class="job-form">
      <!-- Customer Information Section -->
      <div class="form-section">
        <h2>Customer Information</h2>
        <div class="form-grid">
          <div class="form-group full-width">
            <label for="customerId">Customer</label>
            <select id="customerId" formControlName="customerId" (change)="onCustomerSelected($event)">
              <option value="">Select a customer</option>
              <option *ngFor="let customer of customers" [value]="customer.id">
                {{ customer.name }}
                {{ customer.city ? '- ' + customer.city : '' }}
              </option>
            </select>
            <span class="error-message">{{ getErrorMessage('customerId') }}</span>
          </div>
        </div>
      </div>

      <!-- Vehicle Information Section -->
      <div class="form-section">
        <h2>Vehicle Information</h2>
        <div class="form-grid">
          <div class="form-group">
            <label for="vehicleMake">Make</label>
            <select id="vehicleMake" formControlName="vehicleMake">
              <option value="">Select make</option>
              <option *ngFor="let make of vehicleMakes" [value]="make.id">
                {{ make.displayName }}
              </option>
            </select>
            <span class="error-message">{{ getErrorMessage('vehicleMake') }}</span>
          </div>

          <div class="form-group">
            <label for="vehicleModel">Model</label>
            <select id="vehicleModel" formControlName="vehicleModel">
              <option value="">Select model</option>
              <option *ngFor="let model of availableModels" [value]="model.id">
                {{ model.name }}
              </option>
            </select>
            <span class="error-message">{{ getErrorMessage('vehicleModel') }}</span>
          </div>

          <div class="form-group">
            <label for="vehicleType">Type</label>
            <select id="vehicleType" formControlName="vehicleType">
              <option value="">Select type</option>
              <option *ngFor="let type of vehicleTypes" [value]="type">
                {{ type }}
              </option>
            </select>
            <span class="error-message">{{ getErrorMessage('vehicleType') }}</span>
          </div>

          <div class="form-group">
            <label for="registration">Registration (UPPERCASE, NO SPACES)</label>
            <input id="registration" type="text" formControlName="registration" style="text-transform: uppercase" />
            <span class="error-message">{{ getErrorMessage('registration') }}</span>
          </div>

          <div class="form-group">
            <label for="chassisNumber">Chassis Number (optional)</label>
            <input id="chassisNumber" type="text" formControlName="chassisNumber" style="text-transform: uppercase" />
            <span class="error-message">{{ getErrorMessage('chassisNumber') }}</span>
          </div>

          <div class="form-group">
            <label for="color">Color (optional)</label>
            <input id="color" type="text" formControlName="color" />
          </div>

          <div class="form-group">
            <label for="year">Year (optional)</label>
            <input id="year" type="number" formControlName="year" />
          </div>
        </div>

        <div class="previous-selections" *ngIf="previousSelections.length > 0">
          <h3>Previously Used Vehicles</h3>
          <div class="selection-pills">
            <div *ngFor="let item of previousSelections" class="selection-pill" (click)="applyPreviousSelection(item)">
              {{ item.makeName }} {{ item.modelName }} ({{ item.registration }})
            </div>
          </div>
        </div>
      </div>

      <!-- Journey Type Selection -->
      <div class="form-section">
        <div class="journey-type-header">
          <h2>Journey Type</h2>
          <div class="split-journey-toggle">
            <button type="button" class="toggle-btn" (click)="toggleSplitJourney()">
              <span class="material-icons">{{ jobForm.get('isSplitJourney')?.value ? 'check_box' : 'check_box_outline_blank' }}</span>
              Split Journey
            </button>
            <div class="journey-info" *ngIf="jobForm.get('isSplitJourney')?.value">
              <span class="material-icons info-icon">info</span>
              <span class="info-text">Split journey enables multiple collection and delivery points</span>
            </div>
          </div>
        </div>

        <!-- Journey Visualization -->
        <div class="journey-visualization">
          <div class="journey-step primary">
            <div class="step-icon">
              <span class="material-icons">location_on</span>
            </div>
            <div class="step-label">Primary Collection</div>
          </div>
          <div class="journey-arrow">
            <span class="material-icons">arrow_forward</span>
          </div>
          <div class="journey-step secondary" *ngIf="jobForm.get('isSplitJourney')?.value">
            <div class="step-icon">
              <span class="material-icons">add_location</span>
            </div>
            <div class="step-label">Secondary Collection</div>
          </div>
          <div class="journey-arrow" *ngIf="jobForm.get('isSplitJourney')?.value">
            <span class="material-icons">arrow_forward</span>
          </div>
          <div class="journey-step secondary" *ngIf="jobForm.get('isSplitJourney')?.value">
            <div class="step-icon">
              <span class="material-icons">add_location</span>
            </div>
            <div class="step-label">Secondary Delivery</div>
          </div>
          <div class="journey-arrow">
            <span class="material-icons">arrow_forward</span>
          </div>
          <div class="journey-step primary">
            <div class="step-icon">
              <span class="material-icons">flag</span>
            </div>
            <div class="step-label">Final Delivery</div>
          </div>
        </div>
      </div>

      <!-- Primary Collection Details Section -->
      <div class="form-section">
        <h2>Primary Collection Details</h2>
        <div class="form-grid">
          <div class="form-group full-width">
            <label for="collectionAddress">Address</label>
            <input id="collectionAddress" type="text" formControlName="collectionAddress" />
            <span class="error-message">{{ getErrorMessage('collectionAddress') }}</span>
          </div>

          <div class="form-group">
            <label for="collectionCity">City</label>
            <input id="collectionCity" type="text" formControlName="collectionCity" />
          </div>

          <div class="form-group">
            <label for="collectionPostcode">Postcode</label>
            <input id="collectionPostcode" type="text" formControlName="collectionPostcode" />
          </div>

          <div class="form-group">
            <label for="collectionContactName">Contact Name</label>
            <input id="collectionContactName" type="text" formControlName="collectionContactName" />
          </div>

          <div class="form-group">
            <label for="collectionContactPhone">Contact Phone</label>
            <input id="collectionContactPhone" type="text" formControlName="collectionContactPhone" />
          </div>

          <div class="form-group full-width">
            <label for="collectionNotes">Notes</label>
            <textarea id="collectionNotes" formControlName="collectionNotes" rows="2"></textarea>
          </div>
        </div>
      </div>

      <!-- Secondary Collection Details Section - Only shown for split journeys -->
      <div class="form-section" *ngIf="jobForm.get('isSplitJourney')?.value">
        <h2>Secondary Collection Details</h2>
        <div class="form-grid">
          <div class="form-group full-width">
            <label for="secondaryCollectionAddress">Address</label>
            <input id="secondaryCollectionAddress" type="text" formControlName="secondaryCollectionAddress" />
            <span class="error-message">{{ getErrorMessage('secondaryCollectionAddress') }}</span>
          </div>

          <div class="form-group">
            <label for="secondaryCollectionCity">City</label>
            <input id="secondaryCollectionCity" type="text" formControlName="secondaryCollectionCity" />
          </div>

          <div class="form-group">
            <label for="secondaryCollectionPostcode">Postcode</label>
            <input id="secondaryCollectionPostcode" type="text" formControlName="secondaryCollectionPostcode" />
          </div>

          <div class="form-group">
            <label for="secondaryCollectionContactName">Contact Name</label>
            <input id="secondaryCollectionContactName" type="text" formControlName="secondaryCollectionContactName" />
          </div>

          <div class="form-group">
            <label for="secondaryCollectionContactPhone">Contact Phone</label>
            <input id="secondaryCollectionContactPhone" type="text" formControlName="secondaryCollectionContactPhone" />
          </div>

          <div class="form-group full-width">
            <label for="secondaryCollectionNotes">Notes</label>
            <textarea id="secondaryCollectionNotes" formControlName="secondaryCollectionNotes" rows="2"></textarea>
          </div>
        </div>
      </div>

      <!-- Secondary Delivery Details Section - Only shown for split journeys -->
      <div class="form-section" *ngIf="jobForm.get('isSplitJourney')?.value">
        <h2>Secondary Delivery Details</h2>
        <div class="form-grid">
          <div class="form-group full-width">
            <label for="secondaryDeliveryAddress">Address</label>
            <input id="secondaryDeliveryAddress" type="text" formControlName="secondaryDeliveryAddress" />
            <span class="error-message">{{ getErrorMessage('secondaryDeliveryAddress') }}</span>
          </div>

          <div class="form-group">
            <label for="secondaryDeliveryCity">City</label>
            <input id="secondaryDeliveryCity" type="text" formControlName="secondaryDeliveryCity" />
          </div>

          <div class="form-group">
            <label for="secondaryDeliveryPostcode">Postcode</label>
            <input id="secondaryDeliveryPostcode" type="text" formControlName="secondaryDeliveryPostcode" />
          </div>

          <div class="form-group">
            <label for="secondaryDeliveryContactName">Contact Name</label>
            <input id="secondaryDeliveryContactName" type="text" formControlName="secondaryDeliveryContactName" />
          </div>

          <div class="form-group">
            <label for="secondaryDeliveryContactPhone">Contact Phone</label>
            <input id="secondaryDeliveryContactPhone" type="text" formControlName="secondaryDeliveryContactPhone" />
          </div>

          <div class="form-group full-width">
            <label for="secondaryDeliveryNotes">Notes</label>
            <textarea id="secondaryDeliveryNotes" formControlName="secondaryDeliveryNotes" rows="2"></textarea>
          </div>
        </div>
      </div>

      <!-- Final Delivery Details Section -->
      <div class="form-section">
        <h2>Final Delivery Details</h2>
        <div class="form-grid">
          <div class="form-group full-width">
            <label for="deliveryAddress">Address</label>
            <input id="deliveryAddress" type="text" formControlName="deliveryAddress" />
            <span class="error-message">{{ getErrorMessage('deliveryAddress') }}</span>
          </div>

          <div class="form-group">
            <label for="deliveryCity">City</label>
            <input id="deliveryCity" type="text" formControlName="deliveryCity" />
          </div>

          <div class="form-group">
            <label for="deliveryPostcode">Postcode</label>
            <input id="deliveryPostcode" type="text" formControlName="deliveryPostcode" />
          </div>

          <div class="form-group">
            <label for="deliveryContactName">Contact Name</label>
            <input id="deliveryContactName" type="text" formControlName="deliveryContactName" />
          </div>

          <div class="form-group">
            <label for="deliveryContactPhone">Contact Phone</label>
            <input id="deliveryContactPhone" type="text" formControlName="deliveryContactPhone" />
          </div>

          <div class="form-group full-width">
            <label for="deliveryNotes">Notes</label>
            <textarea id="deliveryNotes" formControlName="deliveryNotes" rows="2"></textarea>
          </div>
        </div>
      </div>

      <!-- Additional Details Section -->
      <div class="form-section">
        <h2>Additional Information</h2>
        <div class="form-grid">
          <div class="form-group full-width">
            <label for="notes">Job Notes</label>
            <textarea id="notes" formControlName="notes" rows="4"></textarea>
          </div>
        </div>
      </div>

      <!-- Form Actions -->
      <div class="form-actions">
        <button type="submit" class="submit-btn" [disabled]="!jobForm.valid || isSubmitting">
          {{ isSubmitting ? 'Creating...' : 'Create Job' }}
        </button>
      </div>
    </form>
  </div>
</div>


--- ./src/app/pages/jobs/job-list/job-list.component.ts ---
import { AfterViewInit, Component, OnDestroy, OnInit, ViewChild } from '@angular/core';
import { FormControl, FormGroup } from '@angular/forms';
import { MatDialog } from '@angular/material/dialog';
import { MatPaginator } from '@angular/material/paginator';
import { MatSnackBar } from '@angular/material/snack-bar';
import { MatSort } from '@angular/material/sort';
import { MatTableDataSource } from '@angular/material/table';
import { Router } from '@angular/router';
import { Subscription } from 'rxjs';
import { debounceTime, distinctUntilChanged } from 'rxjs/operators';
import { JobDuplicateDialogComponent } from '../../../dialogs/job-duplicate-dialog.component';
import { Job } from '../../../interfaces/job.interface';
import { AuthService } from '../../../services/auth.service';
import { JobService } from '../../../services/job.service';

interface JobFilters {
  status: string;
  driver: string;
  dateRange: {
    start: Date | null;
    end: Date | null;
  };
}

@Component({
  selector: 'app-job-list',
  templateUrl: './job-list.component.html',
  styleUrls: ['./job-list.component.scss'],
  standalone: false,
})
export class JobListComponent implements OnInit, AfterViewInit, OnDestroy {
  displayedColumns: string[] = ['id', 'regNumber', 'make', 'model', 'collectionDate', 'status', 'driver', 'actions'];

  isLoading = false;
  dataSource = new MatTableDataSource<Job>([]);

  private subscriptions: Subscription[] = [];
  filterForm: FormGroup;
  searchControl = new FormControl('');

  @ViewChild(MatSort) sort!: MatSort;
  @ViewChild(MatPaginator) paginator!: MatPaginator;

  statusOptions = ['unallocated', 'allocated', 'collected', 'delivered', 'completed'];
  drivers: string[] = [];
  driverMap: { [key: string]: string } = {};

  filters: JobFilters = {
    status: 'All',
    driver: 'All',
    dateRange: {
      start: null,
      end: null,
    },
  };

  constructor(private router: Router, private jobService: JobService, private authService: AuthService, private snackBar: MatSnackBar, private dialog: MatDialog) {
    this.filterForm = new FormGroup({
      status: new FormControl('All'),
      driver: new FormControl('All'),
      startDate: new FormControl(null),
      endDate: new FormControl(null),
    });
  }

  ngOnInit(): void {
    this.isLoading = true;

    // Initialize driver information
    this.loadDrivers();

    // Subscribe to jobs observable
    const jobsSub = this.jobService.jobs$.subscribe((jobs) => {
      this.dataSource.data = jobs;
      this.isLoading = false;
    });
    this.subscriptions.push(jobsSub);

    // Subscribe to loading state
    const loadingSub = this.jobService.loading$.subscribe((loading) => (this.isLoading = loading));
    this.subscriptions.push(loadingSub);

    // Load initial jobs data
    this.jobService.getDriverJobs().subscribe();

    // Setup filter form listeners
    this.setupFilterListeners();
  }

  private setupFilterListeners(): void {
    // Subscribe to search input changes
    const searchSub = this.searchControl.valueChanges.pipe(debounceTime(300), distinctUntilChanged()).subscribe((value) => {
      this.applyFilter(value || '');
    });
    this.subscriptions.push(searchSub);

    // Subscribe to filter form changes
    const filterSub = this.filterForm.valueChanges.subscribe(() => {
      this.applyFilters();
    });
    this.subscriptions.push(filterSub);
  }

  private loadDrivers(): void {
    // Get all drivers from the users collection
    this.authService.getDrivers().subscribe((drivers) => {
      this.drivers = drivers.map((driver) => driver.name);

      // Create a map of driver IDs to names for display
      drivers.forEach((driver) => {
        this.driverMap[driver.id] = driver.name;
      });
    });
  }

  ngAfterViewInit(): void {
    this.dataSource.sort = this.sort;
    this.dataSource.paginator = this.paginator;
    this.setupCustomFilter();
  }

  ngOnDestroy(): void {
    // Unsubscribe from all subscriptions
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }

  private setupCustomFilter(): void {
    this.dataSource.filterPredicate = (data: Job, filter: string) => {
      const searchStr = filter.toLowerCase();

      // Apply status filter
      if (this.filters.status !== 'All' && data.status !== this.filters.status) {
        return false;
      }

      // Apply driver filter
      if (this.filters.driver !== 'All' && this.driverMap[data.driverId || ''] !== this.filters.driver) {
        return false;
      }

      // Apply date range filter
      if (this.filters.dateRange.start && this.filters.dateRange.end) {
        const jobDate = new Date(data.createdAt);
        const startDate = new Date(this.filters.dateRange.start);
        const endDate = new Date(this.filters.dateRange.end);

        if (jobDate < startDate || jobDate > endDate) {
          return false;
        }
      }

      // Apply text search
      return (
        data.id?.toLowerCase().includes(searchStr) ||
        data['registration']?.toLowerCase().includes(searchStr) ||
        data.make?.toLowerCase().includes(searchStr) ||
        data.model?.toLowerCase().includes(searchStr) ||
        this.driverMap[data.driverId || '']?.toLowerCase().includes(searchStr)
      );
    };
  }

  applyFilter(filterValue: string): void {
    this.dataSource.filter = filterValue.trim().toLowerCase();

    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage();
    }
  }

  applyFilters(): void {
    const formValues = this.filterForm.value;

    this.filters.status = formValues.status;
    this.filters.driver = formValues.driver;
    this.filters.dateRange.start = formValues.startDate;
    this.filters.dateRange.end = formValues.endDate;

    // This will trigger the filterPredicate function
    this.dataSource.filter = this.dataSource.filter || ' ';
  }

  getDriverName(driverId: string | null): string {
    if (!driverId) return 'Unassigned';
    return this.driverMap[driverId] || 'Unknown Driver';
  }

  formatCreationDate(date: Date | undefined): string {
    if (!date) return 'N/A';

    if (typeof date === 'string') {
      return new Date(date).toLocaleDateString();
    }

    // Handle Firebase Timestamp
    if (date && typeof date === 'object' && 'toDate' in date) {
      const timestamp = date as unknown as { toDate: () => Date };
      return timestamp.toDate().toLocaleDateString();
    }

    return date.toLocaleDateString();
  }

  getStatusClass(status: string): string {
    const statusMap: Record<string, string> = {
      unallocated: 'status-unallocated',
      allocated: 'status-allocated',
      collected: 'status-collected',
      delivered: 'status-delivered',
      completed: 'status-completed',
    };
    return statusMap[status] || 'status-default';
  }

  createNewJob(): void {
    this.router.navigate(['/jobs/new']);
  }

  viewJobDetails(job: Job): void {
    this.router.navigate(['/jobs', job.id]);
  }

  editJob(job: Job, event: Event): void {
    event.stopPropagation(); // Prevent row click event
    this.router.navigate(['/jobs', job.id, 'edit']);
  }

  allocateJob(job: Job, event: Event): void {
    event.stopPropagation(); // Prevent row click event

    this.isLoading = true;
    this.jobService.allocateJob(job.id).subscribe({
      next: () => {
        this.isLoading = false;
      },
      error: (error) => {
        console.error('Error allocating job:', error);
        this.isLoading = false;
        // Handle error (show notification)
      },
    });
  }

  refreshJobs(): void {
    this.isLoading = true;
    this.jobService.getDriverJobs().subscribe({
      next: () => {
        this.isLoading = false;
      },
      error: () => {
        this.isLoading = false;
      },
    });
  }

  /**
   * Duplicate a job
   * @param job The job to duplicate
   * @param event The click event
   */
  duplicateJob(job: Job, event: Event): void {
    event.stopPropagation(); // Prevent row click event

    const dialogRef = this.dialog.open(JobDuplicateDialogComponent, {
      data: {
        jobId: job.id,
        registrationNumber: job['registration'],
        makeModel: job.make && job.model ? `${job.make} ${job.model}` : undefined,
      },
      width: '400px',
      panelClass: ['custom-dialog-container', 'duplication-dialog'],
    });

    dialogRef.afterClosed().subscribe((result: any) => {
      if (result) {
        this.isLoading = true;

        this.jobService.duplicateJob(job.id).subscribe({
          next: (newJobId) => {
            this.isLoading = false;
            this.showSnackbar('Job duplicated successfully');
            this.router.navigate(['/jobs', newJobId]);
          },
          error: (error) => {
            console.error('Error duplicating job:', error);
            this.isLoading = false;
            this.showSnackbar('Error duplicating job: ' + error.message);
          },
        });
      }
    });
  }

  /**
   * Show a snackbar message
   * @param message The message to display
   */
  private showSnackbar(message: string): void {
    this.snackBar.open(message, 'Close', {
      duration: 5000,
      horizontalPosition: 'center',
      verticalPosition: 'bottom',
    });
  }
}


--- ./src/app/pages/jobs/job-list/job-list.component.scss ---
/* job-list.component.scss - with proper sidebar and topbar spacing */

:host {
  display: block;
  padding: 24px;
  background-color: #f5f5f5;
  min-height: 100vh;
  margin-left: 250px; /* Account for sidebar */
  padding-top: 88px; /* Account for topbar height (64px) + some padding */
}

/* Card styles */
.mat-mdc-card {
  margin-bottom: 24px;
  background-color: white;
  border-radius: 8px;
}

/* Header Section */
.header-wrapper {
  padding: 24px 24px 0;
}

.header-title h1 {
  margin: 0;
  font-size: 24px;
  font-weight: 500;
  color: rgba(0, 0, 0, 0.87);
}

.header-title .subtitle {
  margin: 4px 0 0;
  color: rgba(0, 0, 0, 0.6);
  font-size: 14px;
}

/* Filters and Actions Section */
.filters-actions-wrapper {
  padding: 24px;
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 24px;
  border-bottom: 1px solid rgba(0, 0, 0, 0.12);
}

.filters-section {
  display: flex;
  flex: 1;
  gap: 16px;
  align-items: flex-start;
}

.search-field {
  width: 300px;
}

.search-field ::ng-deep .mat-mdc-text-field-wrapper {
  background-color: #f8f9fa;
}

.search-field input {
  height: 20px;
}

.filters-group {
  display: flex;
  flex-wrap: wrap;
  gap: 16px;
  flex: 1;
}

.filters-group mat-form-field {
  width: 180px;
}

.date-range-group {
  display: flex;
  gap: 16px;
}

.date-range-group mat-form-field {
  width: 160px;
}

.actions-group {
  display: flex;
  gap: 12px;
  margin-left: auto;
}

.refresh-button {
  height: 40px;
  background-color: #007bff;
  transition: background-color 0.2s ease;
}

.refresh-button:hover {
  background-color: #0056b3;
}

.create-button {
  height: 40px;
  padding: 0 20px;
  background-color: #007bff;
  transition: background-color 0.2s ease;
}

.create-button:hover {
  background-color: #0056b3;
}

.actions-group .mat-icon {
  margin-right: 8px;
}

/* Table Container */
.table-container {
  position: relative;
  min-height: 400px;
  overflow: auto;
}

/* Scrollbar styling */
.table-container::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

.table-container::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 4px;
}

.table-container::-webkit-scrollbar-thumb {
  background: #ddd;
  border-radius: 4px;
}

.table-container::-webkit-scrollbar-thumb:hover {
  background: #ccc;
}

/* Loading Overlay */
.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.9);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  gap: 16px;
}

.loading-overlay span {
  color: rgba(0, 0, 0, 0.6);
  font-size: 14px;
}

/* Table Styles */
table {
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
}

table.loading {
  opacity: 0.6;
}

/* Header Styles */
.mat-mdc-header-row {
  background-color: #f8f9fa;
  min-height: 48px;
  border-bottom: 1px solid rgba(0, 0, 0, 0.12);
}

.mat-mdc-header-cell {
  color: rgba(0, 0, 0, 0.6);
  font-size: 12px;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  padding: 0 16px;
  white-space: nowrap;
  border-bottom: 1px solid rgba(0, 0, 0, 0.12);
}

.mat-mdc-header-cell:first-of-type {
  padding-left: 24px;
}

.mat-mdc-header-cell:last-of-type {
  padding-right: 24px;
}

/* Sort header styling */
.mat-sort-header-container {
  justify-content: flex-start;
}

.mat-sort-header-arrow {
  color: rgba(0, 0, 0, 0.38);
}

/* Cell Styles */
.mat-mdc-cell {
  font-size: 14px;
  color: rgba(0, 0, 0, 0.87);
  padding: 0 16px;
  border-bottom: 1px solid rgba(0, 0, 0, 0.08);
  height: 52px;
}

.mat-mdc-cell:first-of-type {
  padding-left: 24px;
}

.mat-mdc-cell:last-of-type {
  padding-right: 24px;
}

/* Row Styles */
.job-row {
  min-height: 52px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.job-row:hover {
  background-color: #fafafa;
}

.job-row:hover .job-id {
  color: #0056b3;
}

.job-row:active {
  background-color: #e3f2fd;
}

/* Column Styles */
.job-id {
  font-weight: 600;
  color: #007bff;
  transition: color 0.2s ease;
}

.mat-column-actions {
  width: 48px;
  padding-left: 0;
}

.mat-column-id {
  width: 120px;
}

.mat-column-collectionDate {
  width: 120px;
}

.mat-column-status,
.mat-column-driver {
  width: 140px;
}

/* Status Chips */
.status-chip {
  display: inline-block;
  padding: 4px 12px;
  border-radius: 16px;
  font-size: 12px;
  font-weight: 500;
  text-transform: capitalize;
  line-height: 1.5;
  white-space: nowrap;
}

.status-chip.status-unallocated {
  background-color: #ffebee;
  color: #dc3545;
}

.status-chip.status-in-progress {
  background-color: #fff3e0;
  color: #f57c00;
}

.status-chip.status-completed {
  background-color: #e8f5e9;
  color: #28a745;
}

.status-chip.status-cancelled {
  background-color: #f5f5f5;
  color: #616161;
}

/* Empty State */
.empty-state {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  width: 100%;
  padding: 0 24px;
  box-sizing: border-box;
}

.empty-state .empty-icon {
  font-size: 48px;
  width: 48px;
  height: 48px;
  color: rgba(0, 0, 0, 0.38);
  margin-bottom: 16px;
}

.empty-state h3 {
  margin: 0 0 8px;
  font-size: 16px;
  color: rgba(0, 0, 0, 0.87);
}

.empty-state p {
  margin: 0 0 24px;
  color: rgba(0, 0, 0, 0.6);
  font-size: 14px;
}

.empty-state button {
  min-width: 160px;
}

.empty-state .mat-icon {
  margin-right: 8px;
}

/* Duplicate button styling - match styles.scss */
.mat-menu-item .mat-icon:contains('content_copy') {
  color: #3f51b5;
}

/* Responsive Design */
@media screen and (max-width: 1200px) {
  .filters-section {
    flex-direction: column;
  }

  .search-field {
    width: 100%;
  }

  .filters-group {
    width: 100%;
  }

  .filters-group mat-form-field {
    flex: 1;
    min-width: 150px;
  }

  .date-range-group {
    width: 100%;
  }

  .date-range-group mat-form-field {
    flex: 1;
  }
}

@media screen and (max-width: 960px) {
  :host {
    padding: 16px;
    padding-top: 80px; /* Adjusted for smaller screens */
  }

  .filters-actions-wrapper {
    flex-direction: column;
  }

  .actions-group {
    width: 100%;
  }

  .actions-group button {
    flex: 1;
  }

  .mat-column-vehicle,
  .mat-column-collectionAddress,
  .mat-column-deliveryAddress {
    display: none;
  }
}

@media screen and (max-width: 768px) {
  :host {
    margin-left: 60px; /* Collapsed sidebar width */
    padding-top: 72px; /* Account for smaller topbar on mobile */
  }
}

@media screen and (max-width: 600px) {
  :host {
    padding: 8px;
    padding-top: 72px; /* Maintain topbar spacing */
  }

  .header-wrapper {
    padding: 16px 16px 0;
  }

  .filters-actions-wrapper {
    padding: 16px;
  }

  .filters-group {
    flex-direction: column;
  }

  .filters-group mat-form-field {
    width: 100% !important;
  }

  .date-range-group {
    flex-direction: column;
  }

  .actions-group {
    flex-direction: column;
    gap: 8px;
  }

  /* Hide less important columns on mobile */
  .mat-column-creationDate,
  .mat-column-customerName {
    display: none;
  }
}

/* Print Styles */
@media print {
  :host {
    padding: 0;
    background: white;
    margin-left: 0; /* No sidebar in print */
    padding-top: 0; /* No topbar in print */
  }

  .mat-mdc-card {
    box-shadow: none !important;
  }

  .filters-actions-wrapper,
  .mat-mdc-paginator,
  .mat-column-actions {
    display: none !important;
  }

  .table-container {
    overflow: visible;
  }

  .job-row {
    break-inside: avoid;
  }

  /* Ensure good contrast for printing */
  .status-chip {
    border: 1px solid rgba(0, 0, 0, 0.2);
  }
}


--- ./src/app/pages/jobs/job-list/job-list.component.html ---
<mat-card class="mat-elevation-z3">
  <!-- Header -->
  <div class="header-wrapper">
    <div class="header-title">
      <h1>Jobs</h1>
      <p class="subtitle">{{ dataSource.filteredData.length }} total jobs</p>
    </div>
  </div>

  <!-- Filters and Actions Bar -->
  <div class="filters-actions-wrapper">
    <div class="filters-section">
      <mat-form-field appearance="outline" class="search-field">
        <mat-label>Search jobs</mat-label>
        <input matInput [formControl]="searchControl" placeholder="Search by ID, make, model, or registration" />
        <mat-icon matSuffix>search</mat-icon>
      </mat-form-field>

      <div class="filters-group" [formGroup]="filterForm">
        <mat-form-field appearance="outline">
          <mat-label>Status</mat-label>
          <mat-select formControlName="status">
            <mat-option value="All">All</mat-option>
            <mat-option *ngFor="let status of statusOptions" [value]="status">
              {{ status | titlecase }}
            </mat-option>
          </mat-select>
        </mat-form-field>

        <mat-form-field appearance="outline">
          <mat-label>Driver</mat-label>
          <mat-select formControlName="driver">
            <mat-option value="All">All</mat-option>
            <mat-option *ngFor="let driver of drivers" [value]="driver">
              {{ driver }}
            </mat-option>
          </mat-select>
        </mat-form-field>

        <div class="date-range-group">
          <mat-form-field appearance="outline">
            <mat-label>Start Date</mat-label>
            <input matInput [matDatepicker]="startPicker" formControlName="startDate" />
            <mat-datepicker-toggle matSuffix [for]="startPicker"></mat-datepicker-toggle>
            <mat-datepicker #startPicker></mat-datepicker>
          </mat-form-field>

          <mat-form-field appearance="outline">
            <mat-label>End Date</mat-label>
            <input matInput [matDatepicker]="endPicker" formControlName="endDate" />
            <mat-datepicker-toggle matSuffix [for]="endPicker"></mat-datepicker-toggle>
            <mat-datepicker #endPicker></mat-datepicker>
          </mat-form-field>
        </div>
      </div>
    </div>

    <div class="actions-group">
      <button mat-flat-button color="primary" (click)="refreshJobs()" class="refresh-button" matTooltip="Refresh jobs list">
        <mat-icon>refresh</mat-icon>
      </button>
      <button mat-flat-button color="primary" (click)="createNewJob()" class="create-button">
        <mat-icon>add</mat-icon>
        New Job
      </button>
    </div>
  </div>

  <!-- Table Container -->
  <div class="table-container">
    <!-- Loading Overlay -->
    <div class="loading-overlay" *ngIf="isLoading">
      <mat-spinner diameter="40"></mat-spinner>
      <span>Loading jobs...</span>
    </div>

    <!-- Table -->
    <table mat-table [dataSource]="dataSource" matSort [class.loading]="isLoading">
      <!-- Job ID Column -->
      <ng-container matColumnDef="id">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Job ID</th>
        <td mat-cell *matCellDef="let job" class="job-id">{{ job.id }}</td>
      </ng-container>

      <!-- Reg Column -->
      <ng-container matColumnDef="regNumber">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Registration</th>
        <td mat-cell *matCellDef="let job">{{ job.registration || 'N/A' }}</td>
      </ng-container>

      <!-- Make Column -->
      <ng-container matColumnDef="make">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Make</th>
        <td mat-cell *matCellDef="let job">{{ job.make || 'N/A' }}</td>
      </ng-container>

      <!-- Model Column -->
      <ng-container matColumnDef="model">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Model</th>
        <td mat-cell *matCellDef="let job">{{ job.model || 'N/A' }}</td>
      </ng-container>

      <!-- Collection Date Column -->
      <ng-container matColumnDef="collectionDate">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Created Date</th>
        <td mat-cell *matCellDef="let job">
          {{ formatCreationDate(job.createdAt) }}
        </td>
      </ng-container>

      <!-- Status Column -->
      <ng-container matColumnDef="status">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Status</th>
        <td mat-cell *matCellDef="let job">
          <span class="status-chip" [ngClass]="getStatusClass(job.status)">
            {{ job.status | titlecase }}
          </span>
        </td>
      </ng-container>

      <!-- Driver Column -->
      <ng-container matColumnDef="driver">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Driver</th>
        <td mat-cell *matCellDef="let job">
          {{ getDriverName(job.driverId) }}
        </td>
      </ng-container>

      <!-- Actions Column -->
      <ng-container matColumnDef="actions">
        <th mat-header-cell *matHeaderCellDef></th>
        <td mat-cell *matCellDef="let job">
          <button mat-icon-button [matMenuTriggerFor]="menu">
            <mat-icon>more_vert</mat-icon>
          </button>
          <mat-menu #menu="matMenu" xPosition="before">
            <button mat-menu-item (click)="viewJobDetails(job)">
              <mat-icon>visibility</mat-icon>
              <span>View Details</span>
            </button>
            <button mat-menu-item (click)="editJob(job, $event)">
              <mat-icon>edit</mat-icon>
              <span>Edit</span>
            </button>
            <button mat-menu-item (click)="duplicateJob(job, $event)">
              <mat-icon>content_copy</mat-icon>
              <span>Duplicate</span>
            </button>
            <button mat-menu-item *ngIf="job.status === 'unallocated'" (click)="allocateJob(job, $event)">
              <mat-icon>assignment_ind</mat-icon>
              <span>Allocate to Me</span>
            </button>
          </mat-menu>
        </td>
      </ng-container>

      <!-- Header and Data Rows -->
      <tr mat-header-row *matHeaderRowDef="displayedColumns; sticky: true"></tr>
      <tr mat-row *matRowDef="let row; columns: displayedColumns" (click)="viewJobDetails(row)" class="job-row"></tr>
    </table>

    <!-- Empty State -->
    <div class="empty-state" *ngIf="!isLoading && dataSource.filteredData.length === 0">
      <mat-icon class="empty-icon">work_outline</mat-icon>
      <h3>No jobs found</h3>
      <p>Try adjusting your filters or create a new job</p>
      <button mat-flat-button color="primary" (click)="createNewJob()">
        <mat-icon>add</mat-icon>
        New Job
      </button>
    </div>
  </div>

  <!-- Paginator -->
  <mat-paginator [pageSize]="25" [pageSizeOptions]="[10, 25, 50, 100]" showFirstLastButtons> </mat-paginator>
</mat-card>


--- ./src/app/pages/jobs/job-edit/job-edit.component.scss ---
.edit-job-container {
  min-height: 100vh;
  background-color: #f8f9fa;
  padding: 24px;
  margin-left: 250px; /* Account for sidebar */
  padding-top: 88px; /* Account for topbar height (64px) + some padding */
}

.edit-job-content {
  max-width: 800px;
  margin: 0 auto;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* Loading Overlay */
.loading-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.9);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  gap: 16px;
}

.loading-overlay span {
  color: rgba(0, 0, 0, 0.6);
  font-size: 14px;
  margin-top: 8px;
}

/* Header */
.form-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 24px;
  border-bottom: 1px solid #eee;
}

.form-header h1 {
  margin: 0;
  font-size: 24px;
  color: #333;
}

.header-actions {
  display: flex;
  gap: 10px;
}

.action-btn {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  border-radius: 4px;
  cursor: pointer;
  font-weight: 500;
  transition: all 0.2s ease;
}

.action-btn.secondary-btn {
  border: 1px solid #ddd;
  background-color: white;
  color: #666;
}

.action-btn.secondary-btn:hover {
  border-color: #dc3545;
  color: #dc3545;
}

.action-btn.primary-btn {
  background-color: #007bff;
  color: white;
  border: none;
}

.action-btn.primary-btn:hover {
  background-color: #0056b3;
}

.action-btn.primary-btn:disabled {
  background-color: #b3d7ff;
  cursor: not-allowed;
}

.action-btn .material-icons {
  font-size: 18px;
}

/* Form */
.job-form {
  padding: 24px;
}

.form-section {
  margin-bottom: 32px;
  padding-bottom: 32px;
  border-bottom: 1px solid #eee;
}

.form-section:last-child {
  border-bottom: none;
  margin-bottom: 0;
  padding-bottom: 0;
}

.form-section h2 {
  font-size: 18px;
  color: #333;
  margin: 0 0 20px 0;
}

.form-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 16px;
}

.form-group {
  margin-bottom: 20px;
}

.form-group.full-width {
  grid-column: 1 / -1;
}

.form-group label {
  display: block;
  margin-bottom: 8px;
  color: #666;
  font-size: 14px;
}

.form-group input,
.form-group select,
.form-group textarea {
  width: 100%;
  padding: 10px 12px;
  border: 1px solid #ddd;
  border-radius: 4px;
  background-color: white;
  color: #333;
  font-family: 'UberMove', sans-serif;
  font-size: 14px;
  font-weight: 400;
}

.form-group input::placeholder,
.form-group select::placeholder,
.form-group textarea::placeholder {
  color: #999;
  font-weight: 300;
}

.form-group input:focus,
.form-group select:focus,
.form-group textarea:focus {
  outline: none;
  border-color: #007bff;
  box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
}

.form-group input.ng-touched.ng-invalid,
.form-group select.ng-touched.ng-invalid,
.form-group textarea.ng-touched.ng-invalid {
  border-color: #dc3545;
}

.form-group input.ng-touched.ng-invalid:focus,
.form-group select.ng-touched.ng-invalid:focus,
.form-group textarea.ng-touched.ng-invalid:focus {
  box-shadow: 0 0 0 3px rgba(220, 53, 69, 0.1);
}

.form-group textarea {
  resize: vertical;
  min-height: 100px;
}

.form-group select {
  appearance: none;
  background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
  background-repeat: no-repeat;
  background-position: right 12px center;
  background-size: 16px;
  padding-right: 40px;
}

.error-message {
  display: block;
  color: #dc3545;
  font-size: 12px;
  margin-top: 4px;
  min-height: 20px;
}

/* Previous Selections */
.previous-selections {
  margin-top: 20px;
}

.previous-selections h3 {
  font-size: 15px;
  color: #555;
  margin-bottom: 10px;
}

.selection-pills {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 16px;
}

.selection-pill {
  background-color: #f0f0f0;
  padding: 8px 12px;
  border-radius: 20px;
  font-size: 14px;
  cursor: pointer;
  transition: background-color 0.2s;
}

.selection-pill:hover {
  background-color: #e0e0e0;
}

/* Journey Type Section */
.journey-type-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.split-journey-toggle {
  display: flex;
  align-items: center;
  gap: 12px;
}

.toggle-btn {
  display: flex;
  align-items: center;
  gap: 8px;
  background: none;
  border: none;
  color: #333;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  padding: 6px 12px;
  border-radius: 4px;
  transition: background-color 0.2s;
}

.toggle-btn:hover {
  background-color: #f0f0f0;
}

.toggle-btn .material-icons {
  color: #007bff;
  font-size: 20px;
}

.journey-info {
  display: flex;
  align-items: center;
  gap: 4px;
  color: #666;
  font-size: 13px;
}

.info-icon {
  color: #007bff;
  font-size: 16px;
}

/* Journey Visualization */
.journey-visualization {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 16px;
  background-color: #f8f9fa;
  border-radius: 8px;
  margin-bottom: 20px;
  flex-wrap: wrap;
  gap: 8px;
}

.journey-step {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  padding: 12px;
  border-radius: 8px;
  min-width: 120px;
}

.journey-step.primary {
  background-color: #e3f2fd;
}

.journey-step.secondary {
  background-color: #fff8e1;
}

.step-icon {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  border-radius: 50%;
  background-color: white;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.journey-step.primary .step-icon {
  color: #1976d2;
}

.journey-step.secondary .step-icon {
  color: #f57c00;
}

.step-icon .material-icons {
  font-size: 20px;
}

.step-label {
  font-size: 12px;
  font-weight: 500;
  color: #555;
}

.journey-arrow {
  display: flex;
  align-items: center;
  color: #999;
}

.journey-arrow .material-icons {
  font-size: 20px;
}

/* Checkbox Group */
.checkbox-group {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 8px;
}

.checkbox-group input[type='checkbox'] {
  width: auto;
}

/* Form Actions */
.form-actions {
  display: flex;
  justify-content: flex-end;
  padding-top: 32px;
  margin-top: 32px;
  border-top: 1px solid #eee;
  gap: 16px;
}

.cancel-btn {
  padding: 12px 24px;
  background-color: white;
  color: #666;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
}

.cancel-btn:hover {
  border-color: #dc3545;
  color: #dc3545;
}

.submit-btn {
  padding: 12px 24px;
  background-color: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.submit-btn:hover {
  background-color: #0056b3;
}

.submit-btn:disabled {
  background-color: #b3d7ff;
  cursor: not-allowed;
}

/* Responsive Design */
@media (max-width: 1200px) {
  .form-grid {
    gap: 12px;
  }

  .form-header {
    padding: 20px;
  }

  .journey-visualization {
    flex-wrap: wrap;
    justify-content: center;
  }
}

@media (max-width: 768px) {
  .edit-job-container {
    margin-left: 60px; /* Collapsed sidebar width */
    padding: 16px;
    padding-top: 80px; /* Adjusted top padding for collapsed topbar */
  }

  .form-grid {
    grid-template-columns: 1fr;
  }

  .form-header {
    flex-direction: column;
    align-items: flex-start;
    gap: 16px;
    padding: 16px;
  }

  .header-actions {
    width: 100%;
    justify-content: space-between;
  }

  .job-form {
    padding: 16px;
  }

  .form-section {
    margin-bottom: 24px;
    padding-bottom: 24px;
  }

  .form-section h2 {
    font-size: 16px;
    margin-bottom: 16px;
  }

  .form-group {
    margin-bottom: 16px;
  }

  .form-group input,
  .form-group select,
  .form-group textarea {
    font-size: 16px; /* Prevent zoom on iOS */
    padding: 12px;
  }

  .journey-type-header {
    flex-direction: column;
    align-items: flex-start;
    gap: 12px;
  }

  .split-journey-toggle {
    width: 100%;
  }

  .journey-visualization {
    flex-direction: column;
    align-items: stretch;
  }

  .journey-step {
    width: 100%;
    flex-direction: row;
    justify-content: flex-start;
    min-width: 0;
  }

  .journey-arrow {
    transform: rotate(90deg);
    margin: 4px 0;
  }

  .form-actions {
    padding-top: 24px;
    margin-top: 24px;
    flex-direction: column-reverse;
  }

  .form-actions button {
    width: 100%;
  }
}

@media (max-width: 600px) {
  .edit-job-container {
    padding: 8px;
    padding-top: 72px; /* Further adjusted for smaller screens */
  }

  .form-header {
    padding: 12px;
  }

  .job-form {
    padding: 12px;
  }
}

/* Print Styles */
@media print {
  .edit-job-container {
    margin-left: 0; /* No sidebar in print */
    padding: 0;
    padding-top: 0; /* No topbar in print */
    background: white;
  }

  .edit-job-content {
    box-shadow: none;
    max-width: none;
  }

  .header-actions,
  .form-actions,
  .split-journey-toggle {
    display: none;
  }

  .form-header {
    padding: 16px;
    border-bottom: 1px solid #000;
  }

  .form-section {
    page-break-inside: avoid;
    break-inside: avoid;
  }

  .form-grid {
    display: block;
  }

  .form-group {
    margin-bottom: 10px;
  }

  /* Enhance print readability */
  .form-group label {
    font-weight: bold;
    margin-bottom: 4px;
    color: #000;
  }

  .form-group input,
  .form-group select,
  .form-group textarea {
    border: 1px solid #999;
    background: #fff;
    color: #000;
  }
}


--- ./src/app/pages/jobs/job-edit/job-edit.component.html ---
<div class="edit-job-container">
  <!-- Loading Spinner -->
  <div class="loading-overlay" *ngIf="isLoading">
    <mat-spinner diameter="40"></mat-spinner>
    <span>Loading...</span>
  </div>

  <div class="edit-job-content">
    <div class="form-header">
      <h1>Edit Job</h1>
      <div class="header-actions">
        <button type="button" class="action-btn secondary-btn" (click)="onCancel()">
          <span class="material-icons">close</span>
          Cancel
        </button>
        <button type="button" class="action-btn primary-btn" (click)="onSubmit()" [disabled]="!jobForm.valid || isSubmitting || jobForm.pristine">
          <span class="material-icons">save</span>
          {{ isSubmitting ? 'Saving...' : 'Save Changes' }}
        </button>
      </div>
    </div>

    <form [formGroup]="jobForm" class="job-form">
      <!-- Customer Information Section -->
      <div class="form-section">
        <h2>Customer Information</h2>
        <div class="form-grid">
          <div class="form-group full-width">
            <label for="customerId">Customer</label>
            <select id="customerId" formControlName="customerId" (change)="onCustomerSelected($event)">
              <option value="">Select a customer</option>
              <option *ngFor="let customer of customers" [value]="customer.id">
                {{ customer.name }}
                {{ customer.city ? '- ' + customer.city : '' }}
              </option>
            </select>
            <span class="error-message">{{ getErrorMessage('customerId') }}</span>
          </div>
        </div>
      </div>

      <!-- Vehicle Information Section -->
      <div class="form-section">
        <h2>Vehicle Information</h2>
        <div class="form-grid">
          <div class="form-group">
            <label for="vehicleMake">Make</label>
            <select id="vehicleMake" formControlName="vehicleMake">
              <option value="">Select make</option>
              <option *ngFor="let make of vehicleMakes" [value]="make.id">
                {{ make.displayName }}
              </option>
            </select>
            <span class="error-message">{{ getErrorMessage('vehicleMake') }}</span>
          </div>

          <div class="form-group">
            <label for="vehicleModel">Model</label>
            <select id="vehicleModel" formControlName="vehicleModel">
              <option value="">Select model</option>
              <option *ngFor="let model of availableModels" [value]="model.id">
                {{ model.name }}
              </option>
            </select>
            <span class="error-message">{{ getErrorMessage('vehicleModel') }}</span>
          </div>

          <div class="form-group">
            <label for="vehicleType">Type</label>
            <select id="vehicleType" formControlName="vehicleType">
              <option value="">Select type</option>
              <option *ngFor="let type of vehicleTypes" [value]="type">
                {{ type }}
              </option>
            </select>
            <span class="error-message">{{ getErrorMessage('vehicleType') }}</span>
          </div>

          <div class="form-group">
            <label for="registration">Registration (UPPERCASE, NO SPACES)</label>
            <input id="registration" type="text" formControlName="registration" style="text-transform: uppercase" />
            <span class="error-message">{{ getErrorMessage('registration') }}</span>
          </div>

          <div class="form-group">
            <label for="chassisNumber">Chassis Number (optional)</label>
            <input id="chassisNumber" type="text" formControlName="chassisNumber" style="text-transform: uppercase" />
            <span class="error-message">{{ getErrorMessage('chassisNumber') }}</span>
          </div>

          <div class="form-group">
            <label for="color">Color (optional)</label>
            <input id="color" type="text" formControlName="color" />
          </div>

          <div class="form-group">
            <label for="year">Year (optional)</label>
            <input id="year" type="number" formControlName="year" />
          </div>
        </div>

        <div class="previous-selections" *ngIf="previousSelections.length > 0">
          <h3>Previously Used Vehicles</h3>
          <div class="selection-pills">
            <div *ngFor="let item of previousSelections" class="selection-pill" (click)="applyPreviousSelection(item)">
              {{ item.makeName }} {{ item.modelName }} ({{ item.registration }})
            </div>
          </div>
        </div>
      </div>

      <!-- Journey Type Selection -->
      <div class="form-section">
        <div class="journey-type-header">
          <h2>Journey Type</h2>
          <div class="split-journey-toggle">
            <button type="button" class="toggle-btn" (click)="toggleSplitJourney()">
              <span class="material-icons">{{ jobForm.get('isSplitJourney')?.value ? 'check_box' : 'check_box_outline_blank' }}</span>
              Split Journey
            </button>
            <div class="journey-info" *ngIf="jobForm.get('isSplitJourney')?.value">
              <span class="material-icons info-icon">info</span>
              <span class="info-text">Split journey enables multiple collection and delivery points</span>
            </div>
          </div>
        </div>

        <!-- Journey Visualization -->
        <div class="journey-visualization">
          <div class="journey-step primary">
            <div class="step-icon">
              <span class="material-icons">location_on</span>
            </div>
            <div class="step-label">Primary Collection</div>
          </div>
          <div class="journey-arrow">
            <span class="material-icons">arrow_forward</span>
          </div>
          <div class="journey-step secondary" *ngIf="jobForm.get('isSplitJourney')?.value">
            <div class="step-icon">
              <span class="material-icons">add_location</span>
            </div>
            <div class="step-label">Secondary Collection</div>
          </div>
          <div class="journey-arrow" *ngIf="jobForm.get('isSplitJourney')?.value">
            <span class="material-icons">arrow_forward</span>
          </div>
          <div class="journey-step secondary" *ngIf="jobForm.get('isSplitJourney')?.value">
            <div class="step-icon">
              <span class="material-icons">add_location</span>
            </div>
            <div class="step-label">Secondary Delivery</div>
          </div>
          <div class="journey-arrow">
            <span class="material-icons">arrow_forward</span>
          </div>
          <div class="journey-step primary">
            <div class="step-icon">
              <span class="material-icons">flag</span>
            </div>
            <div class="step-label">Final Delivery</div>
          </div>
        </div>
      </div>

      <!-- Primary Collection Details Section -->
      <div class="form-section">
        <h2>Primary Collection Details</h2>
        <div class="form-grid">
          <div class="form-group full-width">
            <label for="collectionAddress">Address</label>
            <input id="collectionAddress" type="text" formControlName="collectionAddress" />
            <span class="error-message">{{ getErrorMessage('collectionAddress') }}</span>
          </div>

          <div class="form-group">
            <label for="collectionCity">City</label>
            <input id="collectionCity" type="text" formControlName="collectionCity" />
          </div>

          <div class="form-group">
            <label for="collectionPostcode">Postcode</label>
            <input id="collectionPostcode" type="text" formControlName="collectionPostcode" />
          </div>

          <div class="form-group">
            <label for="collectionContactName">Contact Name</label>
            <input id="collectionContactName" type="text" formControlName="collectionContactName" />
          </div>

          <div class="form-group">
            <label for="collectionContactPhone">Contact Phone</label>
            <input id="collectionContactPhone" type="text" formControlName="collectionContactPhone" />
          </div>

          <div class="form-group full-width">
            <label for="collectionNotes">Notes</label>
            <textarea id="collectionNotes" formControlName="collectionNotes" rows="2"></textarea>
          </div>
        </div>
      </div>

      <!-- Secondary Collection Details Section - Only shown for split journeys -->
      <div class="form-section" *ngIf="jobForm.get('isSplitJourney')?.value">
        <h2>Secondary Collection Details</h2>
        <div class="form-grid">
          <div class="form-group full-width">
            <label for="secondaryCollectionAddress">Address</label>
            <input id="secondaryCollectionAddress" type="text" formControlName="secondaryCollectionAddress" />
            <span class="error-message">{{ getErrorMessage('secondaryCollectionAddress') }}</span>
          </div>

          <div class="form-group">
            <label for="secondaryCollectionCity">City</label>
            <input id="secondaryCollectionCity" type="text" formControlName="secondaryCollectionCity" />
          </div>

          <div class="form-group">
            <label for="secondaryCollectionPostcode">Postcode</label>
            <input id="secondaryCollectionPostcode" type="text" formControlName="secondaryCollectionPostcode" />
          </div>

          <div class="form-group">
            <label for="secondaryCollectionContactName">Contact Name</label>
            <input id="secondaryCollectionContactName" type="text" formControlName="secondaryCollectionContactName" />
          </div>

          <div class="form-group">
            <label for="secondaryCollectionContactPhone">Contact Phone</label>
            <input id="secondaryCollectionContactPhone" type="text" formControlName="secondaryCollectionContactPhone" />
          </div>

          <div class="form-group full-width">
            <label for="secondaryCollectionNotes">Notes</label>
            <textarea id="secondaryCollectionNotes" formControlName="secondaryCollectionNotes" rows="2"></textarea>
          </div>
        </div>
      </div>

      <!-- Secondary Delivery Details Section - Only shown for split journeys -->
      <div class="form-section" *ngIf="jobForm.get('isSplitJourney')?.value">
        <h2>Secondary Delivery Details</h2>
        <div class="form-grid">
          <div class="form-group full-width">
            <label for="secondaryDeliveryAddress">Address</label>
            <input id="secondaryDeliveryAddress" type="text" formControlName="secondaryDeliveryAddress" />
            <span class="error-message">{{ getErrorMessage('secondaryDeliveryAddress') }}</span>
          </div>

          <div class="form-group">
            <label for="secondaryDeliveryCity">City</label>
            <input id="secondaryDeliveryCity" type="text" formControlName="secondaryDeliveryCity" />
          </div>

          <div class="form-group">
            <label for="secondaryDeliveryPostcode">Postcode</label>
            <input id="secondaryDeliveryPostcode" type="text" formControlName="secondaryDeliveryPostcode" />
          </div>

          <div class="form-group">
            <label for="secondaryDeliveryContactName">Contact Name</label>
            <input id="secondaryDeliveryContactName" type="text" formControlName="secondaryDeliveryContactName" />
          </div>

          <div class="form-group">
            <label for="secondaryDeliveryContactPhone">Contact Phone</label>
            <input id="secondaryDeliveryContactPhone" type="text" formControlName="secondaryDeliveryContactPhone" />
          </div>

          <div class="form-group full-width">
            <label for="secondaryDeliveryNotes">Notes</label>
            <textarea id="secondaryDeliveryNotes" formControlName="secondaryDeliveryNotes" rows="2"></textarea>
          </div>
        </div>
      </div>

      <!-- Final Delivery Details Section -->
      <div class="form-section">
        <h2>Final Delivery Details</h2>
        <div class="form-grid">
          <div class="form-group full-width">
            <label for="deliveryAddress">Address</label>
            <input id="deliveryAddress" type="text" formControlName="deliveryAddress" />
            <span class="error-message">{{ getErrorMessage('deliveryAddress') }}</span>
          </div>

          <div class="form-group">
            <label for="deliveryCity">City</label>
            <input id="deliveryCity" type="text" formControlName="deliveryCity" />
          </div>

          <div class="form-group">
            <label for="deliveryPostcode">Postcode</label>
            <input id="deliveryPostcode" type="text" formControlName="deliveryPostcode" />
          </div>

          <div class="form-group">
            <label for="deliveryContactName">Contact Name</label>
            <input id="deliveryContactName" type="text" formControlName="deliveryContactName" />
          </div>

          <div class="form-group">
            <label for="deliveryContactPhone">Contact Phone</label>
            <input id="deliveryContactPhone" type="text" formControlName="deliveryContactPhone" />
          </div>

          <div class="form-group full-width">
            <label for="deliveryNotes">Notes</label>
            <textarea id="deliveryNotes" formControlName="deliveryNotes" rows="2"></textarea>
          </div>
        </div>
      </div>

      <!-- Additional Details Section -->
      <div class="form-section">
        <h2>Additional Information</h2>
        <div class="form-grid">
          <div class="form-group full-width">
            <label for="notes">Job Notes</label>
            <textarea id="notes" formControlName="notes" rows="4"></textarea>
          </div>
        </div>
      </div>

      <!-- Form Actions Bottom -->
      <div class="form-actions">
        <button type="button" class="cancel-btn" (click)="onCancel()">Cancel</button>
        <button type="submit" class="submit-btn" [disabled]="!jobForm.valid || isSubmitting || jobForm.pristine" (click)="onSubmit()">
          {{ isSubmitting ? 'Saving...' : 'Save Changes' }}
        </button>
      </div>
    </form>
  </div>
</div>


--- ./src/app/pages/jobs/job-edit/job-edit.component.ts ---
import { Component, OnInit, OnDestroy } from '@angular/core';
import { FormBuilder, FormGroup, Validators, FormArray } from '@angular/forms';
import { ActivatedRoute, Router } from '@angular/router';
import { Observable, Subscription, forkJoin, of } from 'rxjs';
import { finalize, switchMap, catchError, tap, map } from 'rxjs/operators';
import { JobService } from '../../../services/job.service';
import { AuthService } from '../../../services/auth.service';
import { VehicleService, VehicleMake, VehicleModel } from '../../../services/vehicle.service';
import { CustomerService } from '../../../services/customer.service';
import { Customer } from '../../../interfaces/customer.interface';
import { MatSnackBar } from '@angular/material/snack-bar';
import { MatDialog } from '@angular/material/dialog';
import { ConfirmationDialogComponent } from '../../../dialogs/confirmation-dialog.component';
import { Job } from '../../../interfaces/job.interface';

@Component({
  selector: 'app-job-edit',
  templateUrl: './job-edit.component.html',
  styleUrls: ['./job-edit.component.scss'],
  standalone: false,
})
export class JobEditComponent implements OnInit, OnDestroy {
  jobForm!: FormGroup;
  jobId: string = '';
  job: Job | null = null;
  isSubmitting = false;
  isLoading = true;

  // Reference data
  customers: Customer[] = [];
  vehicleMakes: VehicleMake[] = [];
  availableModels: VehicleModel[] = [];
  allModels: VehicleModel[] = [];
  vehicleTypes: string[] = [];

  // Previous selections for easy re-use
  previousSelections: any[] = [];

  private subscriptions: Subscription[] = [];

  constructor(
    private fb: FormBuilder,
    private router: Router,
    private route: ActivatedRoute,
    private jobService: JobService,
    private authService: AuthService,
    private vehicleService: VehicleService,
    private customerService: CustomerService,
    private snackBar: MatSnackBar,
    private dialog: MatDialog
  ) {
    this.createForm();
  }

  ngOnInit() {
    // Get the job ID from the route
    const routeSub = this.route.params.subscribe((params) => {
      this.jobId = params['id'];
      this.loadJobDetails();
    });
    this.subscriptions.push(routeSub);

    // Check for access permissions
    this.checkPermissions();
  }

  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }

  private loadJobDetails() {
    this.isLoading = true;

    // Load job details and reference data in parallel
    const dataSub = this.jobService
      .getJobById(this.jobId)
      .pipe(
        switchMap((job) => {
          if (!job) {
            return of({ job: null, refData: null });
          }

          this.job = job;

          // Load all reference data in parallel
          return forkJoin({
            customers: this.customerService.getCustomers(),
            makes: this.vehicleService.getVehicleMakes(),
            models: this.vehicleService.getVehicleModels(),
            types: this.vehicleService.getVehicleTypes(),
          }).pipe(
            map((refData) => {
              return { job, refData };
            })
          );
        })
      )
      .subscribe({
        next: (result) => {
          if (!result.job) {
            this.showSnackbar('Job not found');
            this.router.navigate(['/jobs']);
            return;
          }

          if (result.refData) {
            this.customers = result.refData.customers;
            this.vehicleMakes = result.refData.makes;
            this.allModels = result.refData.models;
            this.vehicleTypes = result.refData.types;

            // Pre-fill form with job data
            this.populateFormWithJobData(result.job);
          }

          this.isLoading = false;
        },
        error: (error) => {
          console.error('Error loading job details:', error);
          this.showSnackbar('Error loading job details');
          this.isLoading = false;
          this.router.navigate(['/jobs']);
        },
      });

    this.subscriptions.push(dataSub);
    this.loadPreviousVehicleSelections();
  }

  private createForm() {
    this.jobForm = this.fb.group({
      // Customer Information
      customerId: ['', Validators.required],

      // Vehicle Information
      vehicleMake: ['', Validators.required],
      vehicleModel: ['', Validators.required],
      vehicleType: ['', Validators.required],
      registration: ['', [Validators.required, Validators.pattern(/^[A-Z0-9]+$/)]],
      chassisNumber: ['', Validators.pattern(/^[A-Z0-9]+$/)],
      color: [''],
      year: [''],

      // Primary Collection Details
      collectionAddress: ['', Validators.required],
      collectionCity: [''],
      collectionPostcode: [''],
      collectionContactName: [''],
      collectionContactPhone: [''],
      collectionNotes: [''],

      // Final Delivery Details
      deliveryAddress: ['', Validators.required],
      deliveryCity: [''],
      deliveryPostcode: [''],
      deliveryContactName: [''],
      deliveryContactPhone: [''],
      deliveryNotes: [''],

      // Job Settings
      isSplitJourney: [false],

      // Secondary Collection Details
      secondaryCollectionAddress: [''],
      secondaryCollectionCity: [''],
      secondaryCollectionPostcode: [''],
      secondaryCollectionContactName: [''],
      secondaryCollectionContactPhone: [''],
      secondaryCollectionNotes: [''],

      // Secondary Delivery Details
      secondaryDeliveryAddress: [''],
      secondaryDeliveryCity: [''],
      secondaryDeliveryPostcode: [''],
      secondaryDeliveryContactName: [''],
      secondaryDeliveryContactPhone: [''],
      secondaryDeliveryNotes: [''],

      // General notes
      notes: [''],
    });

    // Set up form listeners
    this.setupFormListeners();
  }

  private setupFormListeners() {
    // Listen to make changes to update models
    const makeSub = this.jobForm.get('vehicleMake')?.valueChanges.subscribe((makeId) => {
      this.updateAvailableModels(makeId);
    });

    if (makeSub) this.subscriptions.push(makeSub);

    // Listen to model changes to update vehicle type
    const modelSub = this.jobForm.get('vehicleModel')?.valueChanges.subscribe((modelId) => {
      this.updateVehicleType(modelId);
    });

    if (modelSub) this.subscriptions.push(modelSub);

    // Listen to split journey toggle to update validation
    const splitJourneySub = this.jobForm.get('isSplitJourney')?.valueChanges.subscribe((isSplit) => {
      this.updateSplitJourneyValidation(isSplit);
    });

    if (splitJourneySub) this.subscriptions.push(splitJourneySub);
  }

  private updateSplitJourneyValidation(isSplit: boolean) {
    // Get the form controls for secondary addresses
    const secondaryCollectionAddress = this.jobForm.get('secondaryCollectionAddress');
    const secondaryDeliveryAddress = this.jobForm.get('secondaryDeliveryAddress');

    if (isSplit) {
      // If it's a split journey, make secondary addresses required
      secondaryCollectionAddress?.setValidators([Validators.required]);
      secondaryDeliveryAddress?.setValidators([Validators.required]);
    } else {
      // Otherwise, remove validators
      secondaryCollectionAddress?.clearValidators();
      secondaryDeliveryAddress?.clearValidators();

      // Reset secondary address values
      secondaryCollectionAddress?.setValue('');
      secondaryDeliveryAddress?.setValue('');
      this.jobForm.get('secondaryCollectionCity')?.setValue('');
      this.jobForm.get('secondaryCollectionPostcode')?.setValue('');
      this.jobForm.get('secondaryCollectionContactName')?.setValue('');
      this.jobForm.get('secondaryCollectionContactPhone')?.setValue('');
      this.jobForm.get('secondaryCollectionNotes')?.setValue('');
      this.jobForm.get('secondaryDeliveryCity')?.setValue('');
      this.jobForm.get('secondaryDeliveryPostcode')?.setValue('');
      this.jobForm.get('secondaryDeliveryContactName')?.setValue('');
      this.jobForm.get('secondaryDeliveryContactPhone')?.setValue('');
      this.jobForm.get('secondaryDeliveryNotes')?.setValue('');
    }

    // Update validation status
    secondaryCollectionAddress?.updateValueAndValidity();
    secondaryDeliveryAddress?.updateValueAndValidity();
  }

  private updateAvailableModels(makeId: string) {
    if (!makeId) {
      this.availableModels = [];
      return;
    }

    // If we already loaded all models, filter them locally for faster performance
    this.availableModels = this.allModels.filter((model) => model.makeId === makeId && model.isActive);
  }

  private updateVehicleType(modelId: string) {
    if (!modelId) {
      return;
    }

    const selectedModel = this.allModels.find((model) => model.id === modelId);

    if (selectedModel) {
      this.jobForm.get('vehicleType')?.setValue(selectedModel.type);
    }
  }

  private populateFormWithJobData(job: Job) {
    if (!job) return;

    // Find the corresponding make ID
    let makeId = '';
    if (job.make) {
      const make = this.vehicleMakes.find((m) => m.displayName === job.make);
      if (make) {
        makeId = make.id;
      }
    }

    // Update available models based on the make
    if (makeId) {
      this.updateAvailableModels(makeId);
    }

    // Find the corresponding model ID
    let modelId = '';
    if (job.model && makeId) {
      // Wait for available models to be updated
      setTimeout(() => {
        const model = this.availableModels.find((m) => m.name === job.model);
        if (model) {
          modelId = model.id;
        }

        // Check if this is a split journey
        const isSplitJourney = job['isSplitJourney'] || false;

        // Now patch the form with all values including model
        this.jobForm.patchValue({
          customerId: job['customerId'] || '',
          vehicleMake: makeId,
          vehicleModel: modelId,
          vehicleType: job['vehicleType'] || '',
          registration: job['registration'] || '',
          chassisNumber: job['chassisNumber'] || '',
          color: job.color || '',
          year: job.year || '',
          collectionAddress: job.collectionAddress || '',
          collectionCity: job['collectionCity'] || '',
          collectionPostcode: job.collectionPostcode || '',
          collectionContactName: job['collectionContactName'] || '',
          collectionContactPhone: job['collectionContactPhone'] || '',
          collectionNotes: job['collectionNotes'] || '',
          deliveryAddress: job.deliveryAddress || '',
          deliveryCity: job['deliveryCity'] || '',
          deliveryPostcode: job.deliveryPostcode || '',
          deliveryContactName: job['deliveryContactName'] || '',
          deliveryContactPhone: job['deliveryContactPhone'] || '',
          deliveryNotes: job['deliveryNotes'] || '',
          isSplitJourney: isSplitJourney,
          secondaryCollectionAddress: job['secondaryCollectionAddress'] || '',
          secondaryCollectionCity: job['secondaryCollectionCity'] || '',
          secondaryCollectionPostcode: job['secondaryCollectionPostcode'] || '',
          secondaryCollectionContactName: job['secondaryCollectionContactName'] || '',
          secondaryCollectionContactPhone: job['secondaryCollectionContactPhone'] || '',
          secondaryCollectionNotes: job['secondaryCollectionNotes'] || '',
          secondaryDeliveryAddress: job['secondaryDeliveryAddress'] || '',
          secondaryDeliveryCity: job['secondaryDeliveryCity'] || '',
          secondaryDeliveryPostcode: job['secondaryDeliveryPostcode'] || '',
          secondaryDeliveryContactName: job['secondaryDeliveryContactName'] || '',
          secondaryDeliveryContactPhone: job['secondaryDeliveryContactPhone'] || '',
          secondaryDeliveryNotes: job['secondaryDeliveryNotes'] || '',
          notes: typeof job.notes === 'string' ? job.notes : '',
        });

        // Make sure split journey validation is updated
        this.updateSplitJourneyValidation(isSplitJourney);
      }, 100);
    } else {
      // If no model ID, just patch everything else
      // Check if this is a split journey
      const isSplitJourney = job['isSplitJourney'] || false;

      this.jobForm.patchValue({
        customerId: job['customerId'] || '',
        vehicleMake: makeId,
        vehicleType: job['vehicleType'] || '',
        registration: job['registration'] || '',
        chassisNumber: job['chassisNumber'] || '',
        color: job.color || '',
        year: job.year || '',
        collectionAddress: job.collectionAddress || '',
        collectionCity: job['collectionCity'] || '',
        collectionPostcode: job.collectionPostcode || '',
        collectionContactName: job['collectionContactName'] || '',
        collectionContactPhone: job['collectionContactPhone'] || '',
        collectionNotes: job['collectionNotes'] || '',
        deliveryAddress: job.deliveryAddress || '',
        deliveryCity: job['deliveryCity'] || '',
        deliveryPostcode: job.deliveryPostcode || '',
        deliveryContactName: job['deliveryContactName'] || '',
        deliveryContactPhone: job['deliveryContactPhone'] || '',
        deliveryNotes: job['deliveryNotes'] || '',
        isSplitJourney: isSplitJourney,
        secondaryCollectionAddress: job['secondaryCollectionAddress'] || '',
        secondaryCollectionCity: job['secondaryCollectionCity'] || '',
        secondaryCollectionPostcode: job['secondaryCollectionPostcode'] || '',
        secondaryCollectionContactName: job['secondaryCollectionContactName'] || '',
        secondaryCollectionContactPhone: job['secondaryCollectionContactPhone'] || '',
        secondaryCollectionNotes: job['secondaryCollectionNotes'] || '',
        secondaryDeliveryAddress: job['secondaryDeliveryAddress'] || '',
        secondaryDeliveryCity: job['secondaryDeliveryCity'] || '',
        secondaryDeliveryPostcode: job['secondaryDeliveryPostcode'] || '',
        secondaryDeliveryContactName: job['secondaryDeliveryContactName'] || '',
        secondaryDeliveryContactPhone: job['secondaryDeliveryContactPhone'] || '',
        secondaryDeliveryNotes: job['secondaryDeliveryNotes'] || '',
        notes: typeof job.notes === 'string' ? job.notes : '',
      });

      // Make sure split journey validation is updated
      this.updateSplitJourneyValidation(isSplitJourney);
    }
  }

  private checkPermissions() {
    const permissionSub = this.authService.hasPermission('canEditJobs').subscribe((hasPermission) => {
      if (!hasPermission) {
        this.showSnackbar('You do not have permission to edit jobs');
        this.router.navigate(['/jobs']);
      }
    });

    this.subscriptions.push(permissionSub);
  }

  private loadPreviousVehicleSelections() {
    // Retrieve previous selections from localStorage
    const savedSelections = localStorage.getItem('previousVehicleSelections');

    if (savedSelections) {
      try {
        this.previousSelections = JSON.parse(savedSelections);
      } catch (e) {
        console.error('Error parsing saved vehicle selections:', e);
        this.previousSelections = [];
      }
    }
  }

  getMakeDisplayName(makeId: string): string {
    const make = this.vehicleMakes.find((m) => m.id === makeId);
    return make ? make.displayName : '';
  }

  /**
   * Auto-populate customer address information when a customer is selected
   */
  onCustomerSelected(event: Event) {
    const select = event.target as HTMLSelectElement;
    const customerId = select?.value;

    if (!customerId) return;

    const selectedCustomer = this.customers.find((c) => c.id === customerId);

    if (selectedCustomer && selectedCustomer.address) {
      // Auto-populate the collection address with customer info
      this.jobForm.patchValue({
        collectionAddress: selectedCustomer.address || '',
        collectionCity: selectedCustomer.city || '',
        collectionPostcode: selectedCustomer.postcode || '',
        collectionContactName: selectedCustomer.name || '',
        collectionContactPhone: selectedCustomer.phone || '',
      });
    }
  }

  /**
   * Apply previously used vehicle details
   */
  applyPreviousSelection(selection: any) {
    this.jobForm.patchValue({
      vehicleMake: selection.makeId,
      vehicleModel: selection.modelId,
      registration: selection.registration,
      chassisNumber: selection.chassisNumber || '',
      color: selection.color || '',
      year: selection.year || '',
    });

    // Make sure models list is updated
    this.updateAvailableModels(selection.makeId);

    // Delay setting the model to ensure the models list is populated
    setTimeout(() => {
      this.jobForm.patchValue({
        vehicleModel: selection.modelId,
      });
    }, 100);
  }

  /**
   * Toggle split journey mode
   */
  toggleSplitJourney() {
    const currentValue = this.jobForm.get('isSplitJourney')?.value;
    this.jobForm.get('isSplitJourney')?.setValue(!currentValue);

    // If turning on split journey, show a dialog with information
    if (!currentValue) {
      this.showSplitJourneyInfo();
    }
  }

  /**
   * Show information dialog about split journey
   */
  showSplitJourneyInfo() {
    const dialogRef = this.dialog.open(ConfirmationDialogComponent, {
      data: {
        title: 'Split Journey',
        message: 'You have enabled split journey mode. This allows you to specify additional collection and delivery points. Please fill in all required address fields.',
        confirmText: 'Got it',
        cancelText: 'Disable Split Journey',
        icon: 'call_split',
      },
      width: '400px',
    });

    dialogRef.afterClosed().subscribe((result) => {
      if (result === false) {
        this.jobForm.get('isSplitJourney')?.setValue(false);
      }
    });
  }

  onCancel() {
    // Show confirmation dialog if there are changes
    if (this.jobForm.dirty) {
      const dialogRef = this.dialog.open(ConfirmationDialogComponent, {
        data: {
          title: 'Discard Changes',
          message: 'Are you sure you want to discard your changes?',
          confirmText: 'Discard',
          cancelText: 'Continue Editing',
          confirmColor: 'warn',
        },
        width: '400px',
      });

      dialogRef.afterClosed().subscribe((result) => {
        if (result) {
          this.router.navigate(['/jobs', this.jobId]);
        }
      });
    } else {
      this.router.navigate(['/jobs', this.jobId]);
    }
  }

  onSubmit() {
    if (this.jobForm.invalid) {
      this.markFormGroupTouched(this.jobForm);
      this.showSnackbar('Please complete all required fields');
      return;
    }

    this.isSubmitting = true;

    const formValue = this.jobForm.value;

    // Get make and model display names
    const selectedMake = this.vehicleMakes.find((m) => m.id === formValue.vehicleMake);
    const selectedModel = this.availableModels.find((m) => m.id === formValue.vehicleModel);

    // Customer info
    const selectedCustomer = this.customers.find((c) => c.id === formValue.customerId);

    // Prepare job data for update
    const jobData: Partial<Job> = {
      vehicleId: formValue.chassisNumber || formValue.registration, // Using reg/chassis as vehicle ID
      make: selectedMake?.displayName || '',
      model: selectedModel?.name || '',
      registration: formValue.registration.toUpperCase(),

      // Customer info
      customerId: formValue.customerId,
      customerName: selectedCustomer?.name || '',
      customerContact: selectedCustomer?.name || '',
      customerContactPhone: selectedCustomer?.phone || '',

      // Primary Collection
      collectionAddress: formValue.collectionAddress,
      collectionCity: formValue.collectionCity,
      collectionPostcode: formValue.collectionPostcode,
      collectionContactName: formValue.collectionContactName,
      collectionContactPhone: formValue.collectionContactPhone,
      collectionNotes: formValue.collectionNotes,

      // Final Delivery
      deliveryAddress: formValue.deliveryAddress,
      deliveryCity: formValue.deliveryCity,
      deliveryPostcode: formValue.deliveryPostcode,
      deliveryContactName: formValue.deliveryContactName,
      deliveryContactPhone: formValue.deliveryContactPhone,
      deliveryNotes: formValue.deliveryNotes,

      // Vehicle details
      color: formValue.color,
      year: formValue.year,
      chassisNumber: formValue.chassisNumber ? formValue.chassisNumber.toUpperCase() : '',
      vehicleType: formValue.vehicleType,

      // Split journey flag
      isSplitJourney: formValue.isSplitJourney,

      // Only include secondary addresses if this is a split journey
      ...(formValue.isSplitJourney && {
        // Secondary Collection
        secondaryCollectionAddress: formValue.secondaryCollectionAddress,
        secondaryCollectionCity: formValue.secondaryCollectionCity,
        secondaryCollectionPostcode: formValue.secondaryCollectionPostcode,
        secondaryCollectionContactName: formValue.secondaryCollectionContactName,
        secondaryCollectionContactPhone: formValue.secondaryCollectionContactPhone,
        secondaryCollectionNotes: formValue.secondaryCollectionNotes,

        // Secondary Delivery
        secondaryDeliveryAddress: formValue.secondaryDeliveryAddress,
        secondaryDeliveryCity: formValue.secondaryDeliveryCity,
        secondaryDeliveryPostcode: formValue.secondaryDeliveryPostcode,
        secondaryDeliveryContactName: formValue.secondaryDeliveryContactName,
        secondaryDeliveryContactPhone: formValue.secondaryDeliveryContactPhone,
        secondaryDeliveryNotes: formValue.secondaryDeliveryNotes,
      }),

      // Notes
      notes: formValue.notes,
    };

    // Save the vehicle selection for future use
    this.saveToRecentSelections();

    // Update the job
    this.jobService
      .updateJob(this.jobId, jobData)
      .pipe(finalize(() => (this.isSubmitting = false)))
      .subscribe({
        next: () => {
          this.showSnackbar('Job updated successfully');
          this.router.navigate(['/jobs', this.jobId]);
        },
        error: (error) => {
          console.error('Error updating job:', error);
          this.showSnackbar(`Error updating job: ${error.message}`);
        },
      });
  }

  /**
   * Save current vehicle information to previous selections
   */
  saveToRecentSelections() {
    const formValue = this.jobForm.value;

    // Only save if we have the minimum required information
    if (!formValue.vehicleMake || !formValue.vehicleModel || !formValue.registration) {
      return;
    }

    const selectedMake = this.vehicleMakes.find((m) => m.id === formValue.vehicleMake);
    const selectedModel = this.availableModels.find((m) => m.id === formValue.vehicleModel);

    if (!selectedMake || !selectedModel) {
      return;
    }

    const vehicleSelection = {
      makeId: formValue.vehicleMake,
      makeName: selectedMake.displayName,
      modelId: formValue.vehicleModel,
      modelName: selectedModel.name,
      registration: formValue.registration,
      chassisNumber: formValue.chassisNumber || '',
      color: formValue.color || '',
      year: formValue.year || '',
      timestamp: new Date().toISOString(),
    };

    // Get existing selections
    let selections = [];
    try {
      const savedData = localStorage.getItem('previousVehicleSelections');
      selections = savedData ? JSON.parse(savedData) : [];
    } catch (e) {
      console.error('Error retrieving previous vehicle selections:', e);
      selections = [];
    }

    // Check if this registration already exists
    const existingIndex = selections.findIndex((s: { registration: string }) => s.registration.toLowerCase() === vehicleSelection.registration.toLowerCase());

    if (existingIndex >= 0) {
      // Update existing entry
      selections[existingIndex] = vehicleSelection;
    } else {
      // Add new entry
      selections.unshift(vehicleSelection);

      // Keep max 10 entries
      if (selections.length > 10) {
        selections = selections.slice(0, 10);
      }
    }

    // Save back to localStorage
    localStorage.setItem('previousVehicleSelections', JSON.stringify(selections));

    // Update the component state
    this.previousSelections = selections;
  }

  private markFormGroupTouched(formGroup: FormGroup) {
    Object.values(formGroup.controls).forEach((control) => {
      control.markAsTouched();

      if (control instanceof FormGroup) {
        this.markFormGroupTouched(control);
      }
    });
  }

  getErrorMessage(controlName: string): string {
    const control = this.jobForm.get(controlName);

    if (!control || !control.errors || !control.touched) {
      return '';
    }

    if (control.errors['required']) {
      return 'This field is required';
    }

    if (control.errors['pattern']) {
      if (controlName === 'registration' || controlName === 'chassisNumber') {
        return 'Must be uppercase with no spaces';
      }
      return 'Invalid format';
    }

    return 'Invalid value';
  }

  showSnackbar(message: string): void {
    this.snackBar.open(message, 'Close', {
      duration: 5000,
      horizontalPosition: 'center',
      verticalPosition: 'bottom',
    });
  }
}


--- ./src/app/pages/jobs/job-details/job-details.component.scss ---
/* Enhanced job-details.component.scss with better address styling, status flow, and topbar spacing */

.job-details-page {
  min-height: 100vh;
  background-color: var(--background-color);
  margin-left: 250px; /* Account for sidebar */
  padding-top: 64px; /* Account for topbar height */
}

/* Loading Overlay */
.loading-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.9);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.loading-overlay mat-spinner {
  margin-bottom: 16px;
}

.loading-overlay span {
  color: rgba(0, 0, 0, 0.6);
  font-size: 14px;
}

/* Sticky Header */
.sticky-header {
  position: sticky;
  top: 64px; /* Start right below the topbar */
  background-color: white;
  border-bottom: 1px solid #eee;
  z-index: 99; /* Less than topbar z-index (100) */
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.header-content {
  padding: 20px 24px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.header-left {
  display: flex;
  align-items: center;
  gap: 24px;
}

.back-btn {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  border: none;
  background: none;
  color: #666;
  cursor: pointer;
  font-size: 14px;
  transition: color 0.2s ease;
}

.back-btn:hover {
  color: #007bff;
}

.back-btn .material-icons {
  font-size: 20px;
}

.job-identifier {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 4px 0;
}

.job-details-header {
  display: flex;
  flex-direction: column;
}

.job-id-wrapper {
  display: flex;
  align-items: center;
  margin-bottom: 4px;
}

.job-id {
  font-size: 18px;
  font-weight: 600;
  color: var(--primary-color);
}

.vehicle-summary {
  font-size: 14px;
  color: #666;
  margin-top: 4px;
}

.vehicle-badge {
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #f8f9fa;
  border-radius: 50%;
  overflow: hidden;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  margin-right: 10px;
  flex-shrink: 0;
}

.vehicle-badge img {
  max-width: 80%;
  max-height: 80%;
  object-fit: contain;
  display: block;
  margin: 0 auto;
  /* Add a slight fade-in effect when image loads */
  transition: opacity 0.2s ease-in-out;
}

/* Journey Type Badge */
.journey-type-badge {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 3px 8px 3px 3px;
  border-radius: 16px;
  font-size: 12px;
  font-weight: 500;
  margin-left: 8px;
}

.journey-type-badge.normal {
  background-color: #e3f2fd;
  color: #0d47a1;
}

.journey-type-badge.split {
  background-color: #fff8e1;
  color: #f57f17;
}

.journey-type-badge .material-icons {
  font-size: 16px;
  background: white;
  border-radius: 50%;
  padding: 2px;
}

.header-actions {
  display: flex;
  gap: 12px;
}

.action-btn {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  border: 1px solid #ddd;
  border-radius: 4px;
  background-color: white;
  color: #666;
  cursor: pointer;
  transition: all 0.2s ease;
}

.action-btn:hover {
  border-color: #007bff;
  color: #007bff;
}

.action-btn .material-icons {
  font-size: 18px;
}

/* Tab Navigation */
.tab-navigation {
  padding: 0 24px;
  display: flex;
  gap: 32px;
  border-top: 1px solid #eee;
}

.tab-navigation button {
  padding: 16px 8px;
  background: none;
  border: none;
  color: #666;
  font-weight: 500;
  cursor: pointer;
  position: relative;
  transition: color 0.2s ease;
}

.tab-navigation button:hover {
  color: #333;
}

.tab-navigation button.active {
  color: #007bff;
}

.tab-navigation button.active::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 2px;
  background-color: #007bff;
}

/* Main Content Area */
.main-content {
  padding: 24px;
}

.tab-content {
  max-width: 1400px;
  margin: 0 auto;
}

/* Two Column Layout */
.two-column-layout {
  display: grid;
  grid-template-columns: 1.5fr 1fr;
  gap: 24px;
}

@media (max-width: 1024px) {
  .two-column-layout {
    grid-template-columns: 1fr;
  }
}

/* Info Cards */
.info-card {
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  margin-bottom: 24px;
  overflow: hidden;
}

.info-card h2 {
  padding: 16px 20px;
  margin: 0;
  font-size: 18px;
  color: #333;
  border-bottom: 1px solid #eee;
  background-color: #f8f9fa;
}

.card-content {
  padding: 20px;
}

.info-row {
  display: flex;
  padding: 8px 0;
  border-bottom: 1px solid #f5f5f5;
}

.info-row:last-child {
  border-bottom: none;
}

.info-row .label {
  width: 140px;
  color: #666;
  font-size: 14px;
  font-weight: 500;
}

.info-row .value {
  flex: 1;
  color: #333;
  font-weight: 400;
}

/* Vehicle information card with logo */
.vehicle-card-content {
  display: flex;
  gap: 20px;
}

.vehicle-brand-logo {
  width: 80px;
  height: 80px;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #f8f9fa;
  border-radius: 8px;
  padding: 10px;
  overflow: hidden;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
  align-self: flex-start;
  flex-shrink: 0;
}

.vehicle-brand-logo img {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
  display: block;
}

.vehicle-details {
  flex: 1;
}

/* Enhanced Address Section */
.info-card.addresses-card h2 {
  background-color: #e3f2fd;
  color: #0d47a1;
  border-bottom: 1px solid #bbdefb;
}

.address-section {
  padding: 16px;
  border-radius: 6px;
  margin-bottom: 16px;
  border-left: 4px solid;
  background-color: #fafafa;
  transition: all 0.2s ease;
}

.address-section:last-child {
  margin-bottom: 0;
}

.address-section:hover {
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.address-section.collection {
  border-color: #fb8c00;
  background-color: #fff8e1;
}

.address-section.delivery {
  border-color: #43a047;
  background-color: #e8f5e9;
}

.address-section h3 {
  display: flex;
  align-items: center;
  gap: 8px;
  margin: 0 0 12px 0;
  font-size: 16px;
  font-weight: 600;
}

.address-section.collection h3 {
  color: #e65100;
}

.address-section.delivery h3 {
  color: #2e7d32;
}

.address-section p {
  margin: 6px 0;
  line-height: 1.5;
  color: #333;
}

.address-section p strong {
  display: inline-block;
  width: 80px;
  color: #555;
}

.address-section .address-main {
  font-weight: 500;
  margin-bottom: 12px;
}

.address-section .instructions {
  margin-top: 12px;
  padding: 10px;
  background-color: rgba(0, 0, 0, 0.03);
  border-radius: 4px;
  font-style: italic;
  color: #555;
}

/* Status Badge with enhanced styling */
.status-badge {
  display: inline-flex;
  align-items: center;
  padding: 6px 16px;
  border-radius: 20px;
  font-size: 14px;
  font-weight: 500;
  text-transform: capitalize;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.status-badge.status-unassigned,
.status-badge.status-unallocated {
  background-color: #e0e0e0;
  color: #616161;
}

.status-badge.status-assigned,
.status-badge.status-allocated {
  background-color: #e1f5fe;
  color: #0288d1;
}

.status-badge.status-awaiting-collection {
  background-color: #fff8e1;
  color: #ff8f00;
}

.status-badge.status-collected {
  background-color: #ffecb3;
  color: #ff6f00;
}

.status-badge.status-in-transit {
  background-color: #e8f5e9;
  color: #2e7d32;
}

.status-badge.status-delivered {
  background-color: #d1f8ec;
  color: #00796b;
}

.status-badge.status-complete,
.status-badge.status-completed {
  background-color: #c8e6c9;
  color: #388e3c;
}

.status-badge.status-cancelled {
  background-color: #ffebee;
  color: #c62828;
}

/* Status Flow Visualization */
.status-flow {
  padding: 16px;
  margin-top: 8px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: relative;
  overflow-x: auto;
}

.status-flow::-webkit-scrollbar {
  height: 4px;
}

.status-flow::-webkit-scrollbar-track {
  background: #f1f1f1;
}

.status-flow::-webkit-scrollbar-thumb {
  background: #ccc;
  border-radius: 4px;
}

.status-step {
  flex: 1;
  min-width: 100px;
  text-align: center;
  position: relative;
  padding-bottom: 20px;
  z-index: 2;
}

.status-step .step-circle {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background-color: #e0e0e0;
  border: 2px solid #bdbdbd;
  margin: 0 auto 8px;
  position: relative;
  z-index: 3;
}

.status-step .step-label {
  font-size: 12px;
  color: #757575;
  font-weight: 500;
  margin: 0;
  white-space: nowrap;
}

.status-step.active .step-circle {
  background-color: #2196f3;
  border-color: #1976d2;
}

.status-step.active .step-label {
  color: #1976d2;
  font-weight: 600;
}

.status-step.completed .step-circle {
  background-color: #4caf50;
  border-color: #388e3c;
}

.status-step.completed .step-circle::after {
  content: '✓';
  color: white;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 12px;
}

.status-step.completed .step-label {
  color: #388e3c;
}

.status-flow-line {
  position: absolute;
  height: 2px;
  background-color: #e0e0e0;
  top: 11px;
  left: 60px;
  right: 60px;
  z-index: 1;
}

.status-flow-progress {
  position: absolute;
  height: 2px;
  background-color: #4caf50;
  top: 11px;
  left: 60px;
  z-index: 2;
  transition: width 0.3s ease;
}

/* Enhanced Status Card */
.status-card {
  overflow: hidden;
}

.status-card.status-unallocated {
  border-left: 4px solid #9e9e9e;
}

.status-card.status-allocated {
  border-left: 4px solid #29b6f6;
}

.status-card.status-awaiting-collection {
  border-left: 4px solid #ffa726;
}

.status-card.status-collected {
  border-left: 4px solid #ff9800;
}

.status-card.status-in-transit {
  border-left: 4px solid #66bb6a;
}

.status-card.status-delivered {
  border-left: 4px solid #26a69a;
}

.status-card.status-completed {
  border-left: 4px solid #4caf50;
}

.status-card.status-cancelled {
  border-left: 4px solid #e53935;
}

.current-status {
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 24px 20px;
  position: relative;
  overflow: hidden;
}

.current-status::after {
  content: '';
  position: absolute;
  top: 0;
  bottom: 0;
  right: 0;
  width: 50px;
  background: linear-gradient(90deg, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 1) 100%);
  z-index: 1;
  pointer-events: none;
}

.status-indicator {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background-color: currentColor;
  flex-shrink: 0;
  box-shadow: 0 0 0 4px rgba(0, 0, 0, 0.05);
}

.status-details {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.status-text {
  font-size: 24px;
  font-weight: 600;
  text-transform: capitalize;
}

.current-driver {
  font-size: 14px;
  color: #666;
}

.status-date {
  font-size: 14px;
  color: #666;
  font-style: italic;
}

/* Status Change */
.status-change {
  padding: 0 20px 20px;
}

.status-change h3 {
  font-size: 16px;
  margin-bottom: 12px;
  color: #555;
}

.status-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.status-button {
  padding: 8px 16px;
  border: 1px solid #ddd;
  border-radius: 4px;
  background-color: white;
  color: #666;
  cursor: pointer;
  font-size: 14px;
  transition: all 0.2s ease;
}

.status-button:hover {
  border-color: #007bff;
  color: #007bff;
  background-color: #f0f7ff;
}

.status-button.active {
  background-color: #007bff;
  border-color: #007bff;
  color: white;
}

/* Enhanced Timeline Tab */
.timeline-view {
  max-width: 800px;
  margin: 0 auto;
  padding: 24px;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.timeline-header {
  margin-bottom: 32px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.timeline-header h2 {
  font-size: 24px;
  color: #333;
  margin: 0;
}

.timeline-meta {
  display: flex;
  gap: 16px;
  font-size: 14px;
  color: #666;
}

.timeline-meta .meta-item {
  display: flex;
  align-items: center;
  gap: 4px;
}

.timeline-meta .meta-item .material-icons {
  font-size: 16px;
}

/* Timeline Container */
.timeline-container {
  position: relative;
  padding-left: 20px;
}

.timeline-container::before {
  content: '';
  position: absolute;
  top: 0;
  bottom: 0;
  left: 20px;
  width: 2px;
  background-color: #e0e0e0;
  z-index: 0;
}

.timeline-event {
  display: flex;
  gap: 20px;
  margin-bottom: 32px;
  position: relative;
  z-index: 1;
}

.timeline-event:last-child {
  margin-bottom: 0;
}

.timeline-event:hover .timeline-content {
  transform: translateX(4px);
}

.timeline-marker {
  position: relative;
  z-index: 2;
}

.timeline-icon {
  width: 40px;
  height: 40px;
  background-color: #e3f2fd;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  border: 2px solid white;
}

.timeline-icon .material-icons {
  color: #007bff;
  font-size: 20px;
}

.timeline-content {
  flex: 1;
  background-color: white;
  padding: 16px;
  border-radius: 8px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
  transition: transform 0.2s ease;
}

.event-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 8px;
}

.event-status {
  font-size: 18px;
  font-weight: 600;
  color: #333;
  margin: 0;
}

.event-time {
  font-size: 14px;
  color: #666;
  padding: 2px 8px;
  background-color: #f8f9fa;
  border-radius: 4px;
  white-space: nowrap;
}

.event-description {
  font-size: 14px;
  line-height: 1.5;
  color: #555;
  margin: 0 0 12px 0;
}

.event-metadata {
  display: flex;
  gap: 16px;
  border-top: 1px solid #f0f0f0;
  padding-top: 8px;
}

.metadata-item {
  display: flex;
  align-items: center;
  gap: 4px;
  color: #666;
  font-size: 13px;
}

.metadata-item .material-icons {
  font-size: 16px;
}

/* Custom timeline colors by status */
.timeline-event.status-created .timeline-icon {
  background-color: #e8eaf6;
}

.timeline-event.status-created .timeline-icon .material-icons {
  color: #3f51b5;
}

.timeline-event.status-assigned .timeline-icon {
  background-color: #e1f5fe;
}

.timeline-event.status-assigned .timeline-icon .material-icons {
  color: #03a9f4;
}

.timeline-event.status-collection-started .timeline-icon {
  background-color: #fff8e1;
}

.timeline-event.status-collection-started .timeline-icon .material-icons {
  color: #ffa000;
}

.timeline-event.status-collection-completed .timeline-icon {
  background-color: #ffe0b2;
}

.timeline-event.status-collection-completed .timeline-icon .material-icons {
  color: #ff9800;
}

.timeline-event.status-delivery-started .timeline-icon {
  background-color: #e8f5e9;
}

.timeline-event.status-delivery-started .timeline-icon .material-icons {
  color: #43a047;
}

.timeline-event.status-delivery-completed .timeline-icon {
  background-color: #d7ffd9;
}

.timeline-event.status-delivery-completed .timeline-icon .material-icons {
  color: #2e7d32;
}

/* Notes Section */
.notes-container {
  border-top: 1px solid #eee;
  padding-top: 20px;
  margin-top: 20px;
}

.notes-list {
  margin-bottom: 20px;
}

.note {
  background-color: #f8f9fa;
  border-radius: 8px;
  padding: 16px;
  margin-bottom: 16px;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
  border-left: 3px solid #ccc;
  transition: all 0.2s ease;
}

.note:hover {
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  transform: translateY(-2px);
}

.note-header {
  display: flex;
  justify-content: space-between;
  margin-bottom: 8px;
  font-size: 13px;
}

.note-author {
  font-weight: 600;
  color: #333;
}

.note-date {
  color: #666;
  background-color: rgba(0, 0, 0, 0.03);
  padding: 2px 6px;
  border-radius: 4px;
}

.note-content {
  font-size: 14px;
  color: #333;
  line-height: 1.5;
}

.empty-notes {
  text-align: center;
  padding: 20px;
  color: #666;
  font-style: italic;
  background-color: #f9f9f9;
  border-radius: 8px;
}

.add-note-form {
  margin-top: 16px;
}

.add-note-form textarea {
  width: 100%;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 12px;
  font-family: inherit;
  font-size: 14px;
  resize: vertical;
  margin-bottom: 12px;
  min-height: 80px;
  transition: all 0.2s ease;
}

.add-note-form textarea:focus {
  outline: none;
  border-color: #007bff;
  box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
}

.add-note-button {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  background-color: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  transition: background-color 0.2s ease;
}

.add-note-button:hover {
  background-color: #0056b3;
}

.add-note-button:disabled {
  background-color: #ccc;
  cursor: not-allowed;
}

/* Expenses Tab */
.expenses-view {
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  padding: 24px;
}

.expenses-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
}

.expenses-header h2 {
  margin: 0;
  font-size: 20px;
  color: #333;
}

.add-expense-button {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  background-color: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  transition: background-color 0.2s ease;
}

.add-expense-button:hover {
  background-color: #0056b3;
}

.empty-expenses {
  text-align: center;
  padding: 40px 0;
}

.empty-expenses .material-icons {
  font-size: 48px;
  color: #ccc;
  margin-bottom: 16px;
}

.empty-expenses p {
  color: #666;
  font-size: 16px;
}

/* Not Found Message */
.not-found {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
  min-height: 400px;
}

.not-found mat-icon {
  font-size: 48px;
  color: #dc3545;
  margin-bottom: 16px;
}

.not-found h2 {
  font-size: 24px;
  color: #333;
  margin-bottom: 8px;
}

.not-found p {
  color: #666;
  margin-bottom: 24px;
}

.not-found button {
  padding: 8px 24px;
  background-color: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.not-found button:hover {
  background-color: #0056b3;
}

/* Journey Flow Visualization */
.journey-flow {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 16px;
  background-color: #f8f9fa;
  border-radius: 8px;
  margin-bottom: 20px;
  flex-wrap: wrap;
  gap: 8px;
}

.journey-flow .journey-step {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  padding: 12px;
  border-radius: 8px;
  min-width: 110px;
}

.journey-flow .journey-step:nth-child(1),
.journey-flow .journey-step:nth-child(7) {
  background-color: #e3f2fd;
}

.journey-flow .journey-step:nth-child(3),
.journey-flow .journey-step:nth-child(5) {
  background-color: #fff8e1;
}

.step-icon {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  border-radius: 50%;
  background-color: white;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.journey-flow .journey-step:nth-child(1) .step-icon,
.journey-flow .journey-step:nth-child(7) .step-icon {
  color: #1976d2;
}

.journey-flow .journey-step:nth-child(3) .step-icon,
.journey-flow .journey-step:nth-child(5) .step-icon {
  color: #f57c00;
}

.step-icon .material-icons {
  font-size: 20px;
}

.step-label {
  font-size: 12px;
  font-weight: 500;
  color: #555;
  text-align: center;
}

.journey-arrow {
  display: flex;
  align-items: center;
  color: #999;
}

.journey-arrow .material-icons {
  font-size: 20px;
}

/* Secondary address styling */
.address-section.secondary {
  background-color: #fffde7;
  border-left-color: #fbc02d;
}

.address-section.collection.secondary h3 {
  color: #f57f17;
}

.address-section.delivery.secondary h3 {
  color: #ff6f00;
}

/* Responsive Adjustments */
@media (max-width: 1024px) {
  .header-content {
    flex-direction: column;
    align-items: flex-start;
    gap: 16px;
  }

  .header-left {
    flex-direction: column;
    align-items: flex-start;
    width: 100%;
  }

  .header-actions {
    width: 100%;
    justify-content: flex-end;
  }

  .tab-navigation {
    overflow-x: auto;
    padding: 0 16px;
    gap: 24px;
    width: 100%;
  }

  .tab-navigation::-webkit-scrollbar {
    display: none;
  }

  .main-content {
    padding: 16px;
  }

  .status-flow {
    padding: 16px 8px;
  }

  .info-row {
    flex-direction: column;
    gap: 4px;
  }

  .info-row .label {
    width: auto;
  }

  .vehicle-card-content {
    flex-direction: column;
    align-items: center;
  }

  .vehicle-brand-logo {
    margin-bottom: 16px;
  }

  /* Split journey responsive adjustments */
  .journey-flow {
    flex-direction: column;
    align-items: stretch;
  }

  .journey-flow .journey-step {
    width: 100%;
    flex-direction: row;
    justify-content: flex-start;
    min-width: 0;
  }

  .journey-flow .journey-arrow {
    transform: rotate(90deg);
    margin: 4px 0;
  }

  .step-label {
    text-align: left;
    margin-left: 12px;
  }
}

@media (max-width: 768px) {
  .job-details-page {
    margin-left: 60px; /* Collapsed sidebar width */
  }

  .sticky-header {
    top: 60px; /* Adjust for smaller topbar on mobile */
  }

  .header-content {
    padding: 16px;
  }

  .header-actions {
    flex-direction: column;
    gap: 8px;
  }

  .header-actions button {
    width: 100%;
  }

  .timeline-event {
    gap: 16px;
  }

  .timeline-icon {
    width: 32px;
    height: 32px;
  }

  .timeline-icon .material-icons {
    font-size: 16px;
  }

  .event-header {
    flex-direction: column;
    gap: 4px;
  }

  .event-metadata {
    flex-direction: column;
    gap: 8px;
  }

  .address-section {
    padding: 12px;
  }

  .address-section p strong {
    width: 70px;
    font-size: 13px;
  }

  .job-identifier {
    flex-wrap: wrap;
  }
}

/* Print Styles */
@media print {
  .job-details-page {
    margin-left: 0; /* No sidebar in print */
    padding-top: 0; /* No topbar in print */
  }

  .sticky-header {
    position: static;
    box-shadow: none;
    top: 0;
  }

  .header-actions,
  .tab-navigation {
    display: none;
  }

  .main-content {
    padding: 0;
  }

  .info-card {
    box-shadow: none;
    border: 1px solid #eee;
    break-inside: avoid;
  }

  .timeline-view {
    box-shadow: none;
    border: 1px solid #eee;
  }

  .status-flow {
    overflow: visible;
  }

  .status-badge,
  .note {
    box-shadow: none;
  }
}


--- ./src/app/pages/jobs/job-details/job-details.component.html ---
<div class="job-details-page">
  <!-- Loading Overlay -->
  <div class="loading-overlay" *ngIf="isLoading">
    <mat-spinner diameter="40"></mat-spinner>
    <span>Loading job details...</span>
  </div>

  <!-- Not Found Message -->
  <div class="not-found" *ngIf="!isLoading && !job">
    <mat-icon>error_outline</mat-icon>
    <h2>Job Not Found</h2>
    <p>The job you are looking for does not exist or has been removed.</p>
    <button (click)="goBack()">Back to Jobs</button>
  </div>

  <div *ngIf="job">
    <!-- Sticky Header -->
    <div class="sticky-header">
      <div class="header-content">
        <div class="header-left">
          <div class="job-identifier">
            <div class="vehicle-badge" *ngIf="job.make">
              <img [src]="getVehicleLogo(job.make)" [alt]="job.make + ' logo'" (error)="handleImageError($event)" />
            </div>
            <div class="job-details-header">
              <div class="job-id-wrapper">
                <span class="job-id">{{ job.id }}</span>
                <!-- Journey Type Badge -->
                <span class="journey-type-badge" [ngClass]="job['isSplitJourney'] ? 'split' : 'normal'">
                  <span class="material-icons">{{ job['isSplitJourney'] ? 'call_split' : 'arrow_forward' }}</span>
                  {{ job['isSplitJourney'] ? 'Split Journey' : 'Direct Journey' }}
                </span>
              </div>
              <div class="vehicle-summary" *ngIf="job.make && job.model">
                {{ job.make }} {{ job.model }}
                {{ job['registration'] ? '(' + job['registration'] + ')' : '' }}
              </div>
            </div>
            <span class="status-badge" [ngClass]="job.status ? 'status-' + job.status.toLowerCase().replace(' ', '-') : ''">
              {{ job.status | titlecase }}
            </span>
          </div>
        </div>

        <div class="header-actions">
          <button class="action-btn" *ngIf="hasEditPermission || isAdmin" [routerLink]="['/jobs', job.id, 'edit']">
            <span class="material-icons">edit</span>
            Edit
          </button>
          <button class="action-btn" (click)="duplicateJob()">
            <span class="material-icons">content_copy</span>
            Duplicate
          </button>
          <button class="action-btn" (click)="printJobDetails()">
            <span class="material-icons">print</span>
            Print
          </button>
        </div>
      </div>

      <!-- Tab Navigation -->
      <div class="tab-navigation">
        <button [class.active]="activeTab === 'details'" (click)="setActiveTab('details')">Details</button>
        <button [class.active]="activeTab === 'timeline'" (click)="setActiveTab('timeline')">Timeline</button>
        <button [class.active]="activeTab === 'expenses'" (click)="setActiveTab('expenses')">Expenses</button>
      </div>
    </div>

    <!-- Main Content Area -->
    <div class="main-content">
      <div class="tab-content" [ngSwitch]="activeTab">
        <!-- Details Tab -->
        <div *ngSwitchCase="'details'" class="details-tab">
          <div class="two-column-layout">
            <div class="left-column">
              <!-- Customer Card -->
              <div class="info-card">
                <h2>Customer Information</h2>
                <div class="card-content">
                  <div class="info-row">
                    <span class="label">Customer</span>
                    <span class="value">{{ job.customerName || 'N/A' }}</span>
                  </div>
                  <div class="info-row">
                    <span class="label">Contact Name</span>
                    <span class="value">{{ job['customerContact'] || 'N/A' }}</span>
                  </div>
                  <div class="info-row">
                    <span class="label">Phone</span>
                    <span class="value">{{ job['customerContactPhone'] || 'N/A' }}</span>
                  </div>
                </div>
              </div>

              <!-- Vehicle Card -->
              <div class="info-card">
                <h2>Vehicle Information</h2>
                <div class="card-content vehicle-card-content">
                  <div class="vehicle-details">
                    <div class="info-row">
                      <span class="label">Make</span>
                      <span class="value">{{ job.make || 'N/A' }}</span>
                    </div>
                    <div class="info-row">
                      <span class="label">Model</span>
                      <span class="value">{{ job.model || 'N/A' }}</span>
                    </div>
                    <div class="info-row">
                      <span class="label">Registration</span>
                      <span class="value">{{ job['registration'] || 'N/A' }}</span>
                    </div>
                    <div class="info-row">
                      <span class="label">Type</span>
                      <span class="value">{{ job['vehicleType'] || 'N/A' }}</span>
                    </div>
                    <div class="info-row">
                      <span class="label">Color</span>
                      <span class="value">{{ job.color || 'N/A' }}</span>
                    </div>
                    <div class="info-row">
                      <span class="label">Year</span>
                      <span class="value">{{ job.year || 'N/A' }}</span>
                    </div>
                    <div class="info-row">
                      <span class="label">Chassis Number</span>
                      <span class="value">{{ job['chassisNumber'] || 'N/A' }}</span>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Addresses Card -->
              <div class="info-card addresses-card">
                <h2>Addresses</h2>
                <div class="card-content">
                  <!-- Journey Visualization for Split Journeys -->
                  <div class="journey-flow" *ngIf="job['isSplitJourney']">
                    <div class="journey-step">
                      <div class="step-icon">
                        <span class="material-icons">location_on</span>
                      </div>
                      <div class="step-label">Primary Collection</div>
                    </div>
                    <div class="journey-arrow">
                      <span class="material-icons">arrow_forward</span>
                    </div>
                    <div class="journey-step">
                      <div class="step-icon">
                        <span class="material-icons">add_location</span>
                      </div>
                      <div class="step-label">Secondary Collection</div>
                    </div>
                    <div class="journey-arrow">
                      <span class="material-icons">arrow_forward</span>
                    </div>
                    <div class="journey-step">
                      <div class="step-icon">
                        <span class="material-icons">add_location</span>
                      </div>
                      <div class="step-label">Secondary Delivery</div>
                    </div>
                    <div class="journey-arrow">
                      <span class="material-icons">arrow_forward</span>
                    </div>
                    <div class="journey-step">
                      <div class="step-icon">
                        <span class="material-icons">flag</span>
                      </div>
                      <div class="step-label">Final Delivery</div>
                    </div>
                  </div>

                  <!-- Primary Collection -->
                  <div class="address-section collection">
                    <h3>
                      <span class="material-icons">location_on</span>
                      {{ job['isSplitJourney'] ? 'Primary Collection' : 'Collection' }}
                    </h3>
                    <p class="address-main">
                      {{ job.collectionAddress || 'Not specified' }}
                    </p>
                    <p *ngIf="job['collectionCity']"><strong>City:</strong> {{ job['collectionCity'] }}</p>
                    <p *ngIf="job['collectionPostcode']"><strong>Postcode:</strong> {{ job['collectionPostcode'] }}</p>
                    <p *ngIf="job['collectionContactName']"><strong>Contact:</strong> {{ job['collectionContactName'] }}</p>
                    <p *ngIf="job['collectionContactPhone']"><strong>Phone:</strong> {{ job['collectionContactPhone'] }}</p>
                    <p *ngIf="job['collectionNotes']" class="instructions">
                      <span class="material-icons">info</span>
                      {{ job['collectionNotes'] }}
                    </p>
                  </div>

                  <!-- Secondary Collection - Only if Split Journey -->
                  <div class="address-section collection secondary" *ngIf="job['isSplitJourney']">
                    <h3>
                      <span class="material-icons">add_location</span>
                      Secondary Collection
                    </h3>
                    <p class="address-main">
                      {{ job['secondaryCollectionAddress'] || 'Not specified' }}
                    </p>
                    <p *ngIf="job['secondaryCollectionCity']"><strong>City:</strong> {{ job['secondaryCollectionCity'] }}</p>
                    <p *ngIf="job['secondaryCollectionPostcode']"><strong>Postcode:</strong> {{ job['secondaryCollectionPostcode'] }}</p>
                    <p *ngIf="job['secondaryCollectionContactName']"><strong>Contact:</strong> {{ job['secondaryCollectionContactName'] }}</p>
                    <p *ngIf="job['secondaryCollectionContactPhone']"><strong>Phone:</strong> {{ job['secondaryCollectionContactPhone'] }}</p>
                    <p *ngIf="job['secondaryCollectionNotes']" class="instructions">
                      <span class="material-icons">info</span>
                      {{ job['secondaryCollectionNotes'] }}
                    </p>
                  </div>

                  <!-- Secondary Delivery - Only if Split Journey -->
                  <div class="address-section delivery secondary" *ngIf="job['isSplitJourney']">
                    <h3>
                      <span class="material-icons">add_location</span>
                      Secondary Delivery
                    </h3>
                    <p class="address-main">
                      {{ job['secondaryDeliveryAddress'] || 'Not specified' }}
                    </p>
                    <p *ngIf="job['secondaryDeliveryCity']"><strong>City:</strong> {{ job['secondaryDeliveryCity'] }}</p>
                    <p *ngIf="job['secondaryDeliveryPostcode']"><strong>Postcode:</strong> {{ job['secondaryDeliveryPostcode'] }}</p>
                    <p *ngIf="job['secondaryDeliveryContactName']"><strong>Contact:</strong> {{ job['secondaryDeliveryContactName'] }}</p>
                    <p *ngIf="job['secondaryDeliveryContactPhone']"><strong>Phone:</strong> {{ job['secondaryDeliveryContactPhone'] }}</p>
                    <p *ngIf="job['secondaryDeliveryNotes']" class="instructions">
                      <span class="material-icons">info</span>
                      {{ job['secondaryDeliveryNotes'] }}
                    </p>
                  </div>

                  <!-- Final Delivery -->
                  <div class="address-section delivery">
                    <h3>
                      <span class="material-icons">flag</span>
                      {{ job['isSplitJourney'] ? 'Final Delivery' : 'Delivery' }}
                    </h3>
                    <p class="address-main">
                      {{ job.deliveryAddress || 'Not specified' }}
                    </p>
                    <p *ngIf="job['deliveryCity']"><strong>City:</strong> {{ job['deliveryCity'] }}</p>
                    <p *ngIf="job['deliveryPostcode']"><strong>Postcode:</strong> {{ job['deliveryPostcode'] }}</p>
                    <p *ngIf="job['deliveryContactName']"><strong>Contact:</strong> {{ job['deliveryContactName'] }}</p>
                    <p *ngIf="job['deliveryContactPhone']"><strong>Phone:</strong> {{ job['deliveryContactPhone'] }}</p>
                    <p *ngIf="job['deliveryNotes']" class="instructions">
                      <span class="material-icons">info</span>
                      {{ job['deliveryNotes'] }}
                    </p>
                  </div>
                </div>
              </div>
            </div>

            <div class="right-column">
              <!-- Status Card - Moved to top -->
              <div class="info-card status-card" [ngClass]="job.status ? 'status-' + job.status.toLowerCase().replace(' ', '-') : ''">
                <h2>Current Status</h2>
                <div class="current-status">
                  <span class="status-indicator"></span>
                  <div class="status-details">
                    <span class="status-text">{{ job.status | titlecase }}</span>
                    <span class="current-driver" *ngIf="job.driverId"> Driver: {{ getDriverName() }} </span>
                    <span class="status-date" *ngIf="job['statusUpdatedAt']"> Updated: {{ formatUKDateTime(job['statusUpdatedAt']) }} </span>
                  </div>
                </div>

                <!-- Status flow visualization -->
                <div class="status-flow">
                  <div class="status-flow-line"></div>
                  <div class="status-flow-progress" [style.width.%]="getStatusFlowProgress()"></div>

                  <div
                    *ngFor="let step of getStatusFlow()"
                    class="status-step"
                    [ngClass]="{
                      active: step.active,
                      completed: step.completed
                    }">
                    <div class="step-circle"></div>
                    <p class="step-label">{{ step.label }}</p>
                  </div>
                </div>

                <!-- Status Change section -->
                <div class="status-change" *ngIf="hasEditPermission || isAdmin || job.driverId === currentUser?.id">
                  <h3>Change Status</h3>
                  <div class="status-buttons">
                    <button *ngFor="let status of allowedStatuses" [class.active]="job.status === status" (click)="updateJobStatus(status)" class="status-button">
                      {{ status | titlecase }}
                    </button>
                  </div>
                </div>
              </div>
              <!-- Notes Section -->
              <div class="info-card">
                <h2>Notes</h2>
                <div class="card-content">
                  <div class="notes-container">
                    <div class="notes-list">
                      <div *ngIf="jobNotes.length === 0" class="empty-notes">
                        <p>No notes available for this job</p>
                      </div>
                      <div *ngFor="let note of jobNotes" class="note">
                        <div class="note-header">
                          <span class="note-author">{{ note.author }}</span>
                          <span class="note-date">{{ formatUKDateTime(note.date) }}</span>
                        </div>
                        <div class="note-content">{{ note.content }}</div>
                      </div>
                    </div>

                    <!-- Add Note Form -->
                    <div class="add-note-form" *ngIf="hasEditPermission || isAdmin || job.driverId === currentUser?.id">
                      <textarea [(ngModel)]="newNote" placeholder="Add a note..." rows="2"></textarea>
                      <button class="add-note-button" [disabled]="!newNote.trim()" (click)="addNote()">
                        <span class="material-icons">add</span>
                        Add Note
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Timeline Tab -->
        <div *ngSwitchCase="'timeline'" class="timeline-tab">
          <div class="timeline-view">
            <div class="timeline-header">
              <h2>Job Timeline</h2>
              <div class="timeline-meta">
                <div class="meta-item">
                  <span class="material-icons">event</span>
                  <span>Created: {{ formatUKDate(job.createdAt) }}</span>
                </div>
                <div class="meta-item" *ngIf="job.updatedAt !== job.createdAt">
                  <span class="material-icons">update</span>
                  <span>Last Update: {{ formatUKDate(job.updatedAt) }}</span>
                </div>
              </div>
            </div>

            <!-- Timeline container -->
            <div class="timeline-container">
              <!-- Created event -->
              <div class="timeline-event status-created">
                <div class="timeline-marker">
                  <div class="timeline-icon">
                    <span class="material-icons">add_circle</span>
                  </div>
                </div>
                <div class="timeline-content">
                  <div class="event-header">
                    <h3 class="event-status">Job Created</h3>
                    <time class="event-time">{{ formatUKDateTime(job.createdAt) }}</time>
                  </div>
                  <p class="event-description" *ngIf="job['description']">
                    {{ job['description'] }}
                  </p>
                  <div class="event-metadata">
                    <span class="metadata-item">
                      <span class="material-icons">person</span>
                      {{ job.createdBy || 'System' }}
                    </span>
                    <span class="metadata-item" *ngIf="job['jobReference']">
                      <span class="material-icons">bookmark</span>
                      Ref: {{ job['jobReference'] }}
                    </span>
                  </div>
                </div>
              </div>

              <!-- Allocated event -->
              <div class="timeline-event status-assigned" *ngIf="job.allocatedAt">
                <div class="timeline-marker">
                  <div class="timeline-icon">
                    <span class="material-icons">assignment_ind</span>
                  </div>
                </div>
                <div class="timeline-content">
                  <div class="event-header">
                    <h3 class="event-status">Job Allocated</h3>
                    <time class="event-time">{{ formatUKDateTime(job.allocatedAt) }}</time>
                  </div>
                  <div class="event-metadata">
                    <span class="metadata-item">
                      <span class="material-icons">person</span>
                      Driver: {{ getDriverName() }}
                    </span>
                  </div>
                </div>
              </div>

              <!-- Collection start event -->
              <div class="timeline-event status-collection-started" *ngIf="job.collectionStartTime">
                <div class="timeline-marker">
                  <div class="timeline-icon">
                    <span class="material-icons">departure_board</span>
                  </div>
                </div>
                <div class="timeline-content">
                  <div class="event-header">
                    <h3 class="event-status">Collection Started</h3>
                    <time class="event-time">{{ formatUKDateTime(job.collectionStartTime) }}</time>
                  </div>
                  <div class="event-metadata">
                    <span class="metadata-item">
                      <span class="material-icons">person</span>
                      {{ getDriverName() }}
                    </span>
                    <span class="metadata-item" *ngIf="job.collectionAddress">
                      <span class="material-icons">location_on</span>
                      {{ job.collectionAddress }}
                    </span>
                  </div>
                </div>
              </div>

              <!-- Collection complete event -->
              <div class="timeline-event status-collection-completed" *ngIf="job.collectionCompleteTime">
                <div class="timeline-marker">
                  <div class="timeline-icon">
                    <span class="material-icons">check_circle</span>
                  </div>
                </div>
                <div class="timeline-content">
                  <div class="event-header">
                    <h3 class="event-status">Collection Completed</h3>
                    <time class="event-time">{{ formatUKDateTime(job.collectionCompleteTime) }}</time>
                  </div>
                  <div class="event-metadata">
                    <span class="metadata-item">
                      <span class="material-icons">person</span>
                      {{ getDriverName() }}
                    </span>
                  </div>
                </div>
              </div>

              <!-- Delivery start event -->
              <div class="timeline-event status-delivery-started" *ngIf="job.deliveryStartTime">
                <div class="timeline-marker">
                  <div class="timeline-icon">
                    <span class="material-icons">local_shipping</span>
                  </div>
                </div>
                <div class="timeline-content">
                  <div class="event-header">
                    <h3 class="event-status">Delivery Started</h3>
                    <time class="event-time">{{ formatUKDateTime(job.deliveryStartTime) }}</time>
                  </div>
                  <div class="event-metadata">
                    <span class="metadata-item">
                      <span class="material-icons">person</span>
                      {{ getDriverName() }}
                    </span>
                    <span class="metadata-item" *ngIf="job.deliveryAddress">
                      <span class="material-icons">flag</span>
                      {{ job.deliveryAddress }}
                    </span>
                  </div>
                </div>
              </div>

              <!-- Delivery complete event -->
              <div class="timeline-event status-delivery-completed" *ngIf="job.deliveryCompleteTime">
                <div class="timeline-marker">
                  <div class="timeline-icon">
                    <span class="material-icons">done_all</span>
                  </div>
                </div>
                <div class="timeline-content">
                  <div class="event-header">
                    <h3 class="event-status">Delivery Completed</h3>
                    <time class="event-time">{{ formatUKDateTime(job.deliveryCompleteTime) }}</time>
                  </div>
                  <div class="event-metadata">
                    <span class="metadata-item">
                      <span class="material-icons">person</span>
                      {{ getDriverName() }}
                    </span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Expenses Tab -->
        <div *ngSwitchCase="'expenses'" class="expenses-tab">
          <div class="expenses-view">
            <div class="expenses-header">
              <h2>Job Expenses</h2>
              <button mat-flat-button color="primary" class="add-expense-button" *ngIf="hasEditPermission || isAdmin || job.driverId === currentUser?.id">
                <span class="material-icons">add</span>
                Add Expense
              </button>
            </div>

            <!-- Expenses List -->
            <div class="empty-expenses" *ngIf="!isLoading">
              <span class="material-icons">currency_pound</span>
              <p>No expenses found for this job</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>


--- ./src/app/pages/jobs/job-details/job-details.component.ts ---
import { Component, OnDestroy, OnInit, ChangeDetectorRef } from '@angular/core';
import { MatDialog } from '@angular/material/dialog';
import { MatSnackBar } from '@angular/material/snack-bar';
import { ActivatedRoute, Router } from '@angular/router';
import { Observable, Subscription, combineLatest, forkJoin, of } from 'rxjs';
import { catchError, switchMap, tap } from 'rxjs/operators';
import { ConfirmationDialogComponent } from '../../../dialogs/confirmation-dialog.component';
import { AuthService } from '../../../services/auth.service';
import { JobService } from '../../../services/job.service';
import { Job } from '../../../interfaces/job.interface';
import { UserProfile } from '../../../interfaces/user-profile.interface';
import { DriverSelectionDialogComponent } from '../../../dialogs/driver-selection-dialog.component';
import { JobDuplicateDialogComponent } from '../../../dialogs/job-duplicate-dialog.component';

// Interface for notes
interface Note {
  author: string;
  content: string;
  date: Date;
  id?: string;
}

// Interface for note data to be saved in Firestore
interface NoteData {
  author: string;
  content: string;
  date: string | Date;
  id?: string;
}

// Interface for driver information
interface DriverInfo {
  id: string;
  name: string;
  phoneNumber?: string;
}

@Component({
  selector: 'app-job-details',
  templateUrl: './job-details.component.html',
  styleUrls: ['./job-details.component.scss'],
  standalone: false,
})
export class JobDetailsComponent implements OnInit, OnDestroy {
  jobId: string = '';
  job: Job | null = null;
  activeTab: 'details' | 'timeline' | 'expenses' = 'details';
  isLoading = true;
  hasEditPermission = false;
  hasAllocatePermission = false;
  isAdmin = false;
  currentUser: UserProfile | null = null;
  private isDestroyed = false;

  driverInfo: DriverInfo | null = null;

  jobNotes: Note[] = [];
  newNote: string = '';

  allowedStatuses: ('unallocated' | 'allocated' | 'collected' | 'delivered' | 'completed')[] = ['unallocated', 'allocated', 'collected', 'delivered', 'completed'];

  private subscriptions: Subscription[] = [];

  constructor(
    private route: ActivatedRoute,
    private router: Router,
    private jobService: JobService,
    private authService: AuthService,
    private dialog: MatDialog,
    private snackBar: MatSnackBar,
    private cdr: ChangeDetectorRef
  ) {}

  /**
   * Initialize the component by subscribing to route params and checking permissions
   */
  ngOnInit() {
    const routeSub = this.route.params.subscribe((params) => {
      this.jobId = params['id'];
      this.loadJobDetails();
    });

    this.subscriptions.push(routeSub);

    this.checkUserPermissions();
  }

  /**
   * Clean up subscriptions when the component is destroyed
   */
  ngOnDestroy() {
    this.isDestroyed = true;
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }

  /**
   * Load job details and driver information
   */
  private loadJobDetails() {
    this.isLoading = true;

    const jobSub = this.jobService
      .getJobById(this.jobId)
      .pipe(
        switchMap((job) => {
          if (!job) {
            return of({ job: null, driverInfo: null });
          }

          if (job.driverId) {
            return this.authService.getUserById(job.driverId).pipe(
              catchError(() => of(null)),
              switchMap((driverProfile) => {
                const driver: DriverInfo | null = driverProfile
                  ? {
                      id: driverProfile.id,
                      name: driverProfile.name || `${driverProfile.firstName || ''} ${driverProfile.lastName || ''}`.trim() || 'Unknown Driver',
                      phoneNumber: driverProfile.phoneNumber,
                    }
                  : null;

                return of({ job, driverInfo: driver });
              })
            );
          } else {
            return of({ job, driverInfo: null });
          }
        })
      )
      .subscribe({
        next: (result) => {
          this.job = result.job;
          this.driverInfo = result.driverInfo;
          this.isLoading = false;
          this.cdr.detectChanges();

          if (this.job && this.job.notes) {
            this.processJobNotes(this.job);
          }
        },
        error: (error) => {
          this.isLoading = false;
          console.error('Error loading job details:', error);
          this.showSnackbar('Error loading job details');
          this.cdr.detectChanges();
        },
      });

    this.subscriptions.push(jobSub);
  }

  /**
   * Process job notes from various possible formats
   */
  private processJobNotes(job: Job) {
    const rawNotes: Note[] = [];

    if (Array.isArray(job.notes)) {
      rawNotes.push(...(job.notes as Note[]));
    } else if (typeof job.notes === 'string') {
      rawNotes.push({
        author: job.createdBy || 'System',
        content: job.notes,
        date: job.createdAt,
      });
    } else if (typeof job.notes === 'object' && job.notes !== null) {
      try {
        const notesObject = job.notes as Record<string, any>;
        const noteEntries = Object.entries(notesObject).map(([id, noteData]) => {
          const note: Note = {
            author: (noteData as any).author || 'Unknown',
            content: (noteData as any).content || '',
            date: new Date((noteData as any).date || new Date()),
          };
          return note;
        });

        rawNotes.push(...noteEntries);
      } catch (error) {
        console.error('Error processing notes:', error);
      }
    }

    if (rawNotes.length === 0) {
      this.jobNotes = [];
      return;
    }

    const authorIds = new Set<string>();

    rawNotes.forEach((note) => {
      if (typeof note.author === 'string' && note.author !== 'System' && note.author !== 'Unknown' && note.author.length > 20) {
        authorIds.add(note.author);
      }
    });

    if (authorIds.size === 0) {
      this.jobNotes = rawNotes;
      return;
    }

    const authorMap = new Map<string, string>();
    const authorRequests: Observable<any>[] = [];

    Array.from(authorIds).forEach((authorId) => {
      const request = this.authService.getUserById(authorId).pipe(
        tap((user) => {
          if (user) {
            const authorName = user.name || `${user.firstName || ''} ${user.lastName || ''}`.trim() || 'Unknown User';
            authorMap.set(authorId, authorName);
          }
        }),
        catchError(() => {
          authorMap.set(authorId, 'Unknown User');
          return of(null);
        })
      );
      authorRequests.push(request);
    });

    if (authorRequests.length > 0) {
      const authorSub = forkJoin(authorRequests).subscribe({
        next: () => {
          this.jobNotes = rawNotes.map((note) => {
            if (authorMap.has(note.author)) {
              return {
                ...note,
                author: authorMap.get(note.author) || note.author,
              };
            }
            return note;
          });
          this.cdr.detectChanges();
        },
        error: (error) => {
          console.error('Error fetching note author names:', error);
          this.jobNotes = rawNotes;
          this.cdr.detectChanges();
        },
        complete: () => {
          if (authorSub) {
            this.subscriptions.push(authorSub);
          }
        },
      });
    } else {
      this.jobNotes = rawNotes;
    }
  }

  /**
   * Check user permissions and set flags
   */
  private checkUserPermissions() {
    const permissionsSub = combineLatest([
      this.authService.getUserProfile(),
      this.authService.hasPermission('canEditJobs'),
      this.authService.hasPermission('canAllocateJobs'),
      this.authService.hasPermission('isAdmin'),
    ]).subscribe(([user, canEdit, canAllocate, isAdmin]) => {
      this.currentUser = user;
      this.hasEditPermission = canEdit;
      this.hasAllocatePermission = canAllocate;
      this.isAdmin = isAdmin;
      this.cdr.detectChanges();
    });

    this.subscriptions.push(permissionsSub);
  }

  /**
   * Set the active tab for the job details view
   * @param tab The tab to activate
   */
  setActiveTab(tab: 'details' | 'timeline' | 'expenses') {
    this.activeTab = tab;
    this.cdr.detectChanges();
  }

  /**
   * Get CSS class for job status
   * @param status The job status
   * @returns CSS class name
   */
  getStatusClass(status: string): string {
    const statusMap: Record<string, string> = {
      unallocated: 'status-unallocated',
      allocated: 'status-allocated',
      collected: 'status-collected',
      delivered: 'status-delivered',
      completed: 'status-completed',
    };
    return statusMap[status] || 'status-default';
  }

  /**
   * Get Material icon for timeline event
   * @param status The job status
   * @returns Icon name
   */
  getTimelineIcon(status: string): string {
    const iconMap: Record<string, string> = {
      unallocated: 'assignment',
      allocated: 'assignment_ind',
      collected: 'local_shipping',
      'in-transit': 'directions_car',
      delivered: 'check_circle',
      completed: 'done_all',
    };
    return iconMap[status] || 'radio_button_unchecked';
  }

  /**
   * Check if an event is the last in the timeline
   * @param event The timeline event
   * @returns True if it's the last event
   */
  isLastEvent(event: any): boolean {
    return this.job?.['timeline']?.indexOf(event) === this.job?.['timeline']?.length - 1;
  }

  /**
   * Navigate back to the jobs list
   */
  goBack() {
    this.router.navigate(['/jobs']);
  }

  /**
   * Navigate to the job edit page if the user has permission
   */
  editJob(job: Job, event: Event): void {
    event.stopPropagation(); // Prevent row click event
    this.router.navigate(['/jobs', job.id, 'edit']);
  }

  /**
   * Trigger the browser's print function
   */
  printJobDetails() {
    window.print();
  }

  /**
   * Add a new note to the job
   */
  addNote() {
    if (!this.newNote.trim() || !this.job) return;

    const newNote: Note = {
      author: this.currentUser?.name || 'User',
      content: this.newNote.trim(),
      date: new Date(),
    };

    const notesList: Note[] = [...(this.jobNotes || []), newNote];

    this.isLoading = true;

    const notesData: NoteData[] = notesList.map((note) => ({
      author: note.author,
      content: note.content,
      date: note.date,
    }));

    this.jobService.updateJob(this.job.id, { notes: notesData }).subscribe({
      next: () => {
        this.jobNotes = notesList;
        this.newNote = '';
        this.isLoading = false;
        this.showSnackbar('Note added successfully');
        this.cdr.detectChanges();
      },
      error: (error) => {
        console.error('Error adding note:', error);
        this.isLoading = false;
        this.showSnackbar('Error adding note');
        this.cdr.detectChanges();
      },
    });
  }

  /**
   * Update the job status
   * @param newStatus The new status to set
   */
  updateJobStatus(newStatus: 'unallocated' | 'allocated' | 'collected' | 'delivered' | 'completed') {
    if (!this.job) return;

    if (this.job.status === newStatus) return;

    this.isLoading = true;
    this.cdr.detectChanges();

    switch (newStatus) {
      case 'allocated':
        if (!this.hasAllocatePermission && !this.isAdmin) {
          this.showSnackbar('You do not have permission to allocate jobs');
          this.isLoading = false;
          this.cdr.detectChanges();
          return;
        }

        this.showDriverSelectionDialog();
        break;

      case 'unallocated':
        if (!this.hasEditPermission && !this.isAdmin) {
          this.showSnackbar('You do not have permission to unallocate jobs');
          this.isLoading = false;
          this.cdr.detectChanges();
          return;
        }

        this.jobService.unallocateJob(this.job.id).subscribe({
          next: () => {
            this.loadJobDetails();
            this.showSnackbar('Job unallocated successfully');
            this.cdr.detectChanges();
          },
          error: (error) => {
            console.error('Error unallocating job:', error);
            this.isLoading = false;
            this.showSnackbar('Error unallocating job');
            this.cdr.detectChanges();
          },
        });
        break;

      case 'collected':
        this.startCollection();
        break;

      case 'delivered':
        this.startDelivery();
        break;

      case 'completed':
        this.completeJob();
        break;
    }
  }

  /**
   * Show driver selection dialog and allocate job to selected driver
   */
  private showDriverSelectionDialog(): void {
    const dialogRef = this.dialog.open(DriverSelectionDialogComponent, {
      data: {
        jobId: this.job!.id,
        jobTitle: `${this.job!.make} ${this.job!.model} (${this.job!['registration'] || 'No Reg'})`,
      },
      width: '450px',
      panelClass: ['custom-dialog-container', 'allocation-dialog'],
    });

    dialogRef.afterClosed().subscribe((driver) => {
      if (this.isDestroyed) return;

      if (driver) {
        this.allocateJobToDriver(driver.id);
      } else {
        this.isLoading = false;
        this.cdr.detectChanges();
      }
    });
  }

  /**
   * Allocate job to a specific driver
   * @param driverId The ID of the driver to allocate to
   */
  private allocateJobToDriver(driverId: string): void {
    if (!this.job) {
      this.isLoading = false;
      this.cdr.detectChanges();
      return;
    }

    const jobData: Partial<Job> = {
      status: 'allocated',
      driverId: driverId,
      allocatedAt: new Date(),
      updatedAt: new Date(),
      updatedBy: this.currentUser?.id,
    };

    this.jobService.updateJob(this.job.id, jobData).subscribe({
      next: () => {
        this.loadJobDetails();
        this.showSnackbar('Job allocated successfully');
        this.cdr.detectChanges();
      },
      error: (error) => {
        console.error('Error allocating job to driver:', error);
        this.isLoading = false;
        this.showSnackbar('Error allocating job to driver');
        this.cdr.detectChanges();
      },
    });
  }

  /**
   * Start the collection process for a job
   */
  startCollection() {
    if (!this.job) return;

    const dialogRef = this.dialog.open(ConfirmationDialogComponent, {
      data: {
        title: 'Start Collection',
        message: 'Are you ready to start the collection process for this job?',
        confirmText: 'Start Collection',
        cancelText: 'Cancel',
        icon: 'departure_board',
        confirmColor: 'primary',
      },
      width: '400px',
      panelClass: ['custom-dialog-container', 'collection-dialog'],
    });

    const dialogSub = dialogRef.afterClosed().subscribe((result) => {
      if (this.isDestroyed) return;

      if (result) {
        this.isLoading = true;
        this.cdr.detectChanges();

        const collectionSub = this.jobService.startCollection(this.job!.id).subscribe({
          next: () => {
            this.loadJobDetails();
            this.showSnackbar('Collection started successfully');
            this.cdr.detectChanges();
          },
          error: (error) => {
            console.error('Error starting collection:', error);
            this.isLoading = false;
            this.showSnackbar('Error starting collection: ' + error.message);
            this.cdr.detectChanges();
          },
        });

        this.subscriptions.push(collectionSub);
      } else {
        this.isLoading = false;
        this.cdr.detectChanges();
      }
    });

    this.subscriptions.push(dialogSub);
  }

  /**
   * Start the delivery process for a job
   */
  startDelivery() {
    if (!this.job) return;

    const dialogRef = this.dialog.open(ConfirmationDialogComponent, {
      data: {
        title: 'Start Delivery',
        message: 'Are you ready to start the delivery process for this job?',
        confirmText: 'Start Delivery',
        cancelText: 'Cancel',
        icon: 'local_shipping',
        confirmColor: 'primary',
      },
      width: '400px',
      panelClass: ['custom-dialog-container', 'delivery-dialog'],
    });

    dialogRef.afterClosed().subscribe((result) => {
      if (this.isDestroyed) return;

      if (result) {
        this.isLoading = true;
        this.cdr.detectChanges();

        this.jobService.startDelivery(this.job!.id).subscribe({
          next: () => {
            this.loadJobDetails();
            this.showSnackbar('Delivery started successfully');

            this.cdr.detectChanges();
          },
          error: (error) => {
            console.error('Error starting delivery:', error);
            this.isLoading = false;
            this.showSnackbar('Error starting delivery');
            this.cdr.detectChanges();
          },
        });
      } else {
        this.isLoading = false;
        this.cdr.detectChanges();
      }
    });
  }

  /**
   * Mark the job as completed
   */
  completeJob() {
    if (!this.job) return;

    const dialogRef = this.dialog.open(ConfirmationDialogComponent, {
      data: {
        title: 'Complete Job',
        message: 'Are you sure you want to mark this job as completed?',
        confirmText: 'Complete Job',
        cancelText: 'Cancel',
        icon: 'check_circle',
        confirmColor: 'primary',
      },
      width: '400px',
      panelClass: ['custom-dialog-container'],
    });

    dialogRef.afterClosed().subscribe((result) => {
      if (this.isDestroyed) return;

      if (result) {
        this.isLoading = true;
        this.cdr.detectChanges();

        this.jobService
          .updateJob(this.job!.id, {
            status: 'completed',
            updatedAt: new Date(),
          })
          .subscribe({
            next: () => {
              this.loadJobDetails();
              this.showSnackbar('Job marked as completed');
              this.cdr.detectChanges();
            },
            error: (error) => {
              console.error('Error completing job:', error);
              this.isLoading = false;
              this.showSnackbar('Error completing job');
              this.cdr.detectChanges();
            },
          });
      } else {
        this.isLoading = false;
        this.cdr.detectChanges();
      }
    });
  }

  /**
   * Get the name of the assigned driver
   * @returns Driver name or 'Unassigned'/'Unknown Driver'
   */
  getDriverName(): string {
    if (this.driverInfo) {
      return this.driverInfo.name;
    }

    if (!this.job?.driverId) {
      return 'Unassigned';
    }

    return 'Unknown Driver';
  }

  /**
   * Format a date for display
   * @param date The date to format
   * @returns Formatted date string
   */
  formatDate(date: Date | undefined): string {
    if (!date) return 'N/A';

    if (typeof date === 'string') {
      return new Date(date).toLocaleString();
    }

    if (date && typeof date === 'object' && 'toDate' in date) {
      const timestamp = date as unknown as { toDate: () => Date };
      return timestamp.toDate().toLocaleString();
    }

    return date.toLocaleString();
  }

  /**
   * Format date to UK format (DD/MM/YYYY)
   * @param date The date to format
   * @returns Formatted date string
   */
  formatUKDate(date: Date | undefined): string {
    if (!date) return 'N/A';

    if (typeof date === 'string') {
      date = new Date(date);
    }

    if (date && typeof date === 'object' && 'toDate' in date) {
      const timestamp = date as unknown as { toDate: () => Date };
      date = timestamp.toDate();
    }

    const day = date.getDate().toString().padStart(2, '0');
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const year = date.getFullYear();

    return `${day}/${month}/${year}`;
  }

  /**
   * Format date and time to UK format (DD/MM/YYYY HH:MM)
   * @param date The date to format
   * @returns Formatted date-time string
   */
  formatUKDateTime(date: Date | undefined): string {
    if (!date) return 'N/A';

    if (typeof date === 'string') {
      date = new Date(date);
    }

    if (date && typeof date === 'object' && 'toDate' in date) {
      const timestamp = date as unknown as { toDate: () => Date };
      date = timestamp.toDate();
    }

    const day = date.getDate().toString().padStart(2, '0');
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const year = date.getFullYear();
    const hours = date.getHours().toString().padStart(2, '0');
    const minutes = date.getMinutes().toString().padStart(2, '0');

    return `${day}/${month}/${year} ${hours}:${minutes}`;
  }

  /**
   * Get the progress percentage for the status flow display
   * @returns Progress percentage
   */
  getStatusFlowProgress(): number {
    if (!this.job) return 0;

    const statusOrder = ['unallocated', 'allocated', 'collected', 'delivered', 'completed'];

    const currentStatusIndex = statusOrder.indexOf(this.job.status);
    if (currentStatusIndex === -1) return 0;

    return (currentStatusIndex / (statusOrder.length - 1)) * 100;
  }

  /**
   * Get status steps for the status flow visualization
   * @returns Array of status steps
   */
  getStatusFlow() {
    if (!this.job) return [];

    const statusOrder = [
      { key: 'unallocated', label: 'Unallocated' },
      { key: 'allocated', label: 'Allocated' },
      { key: 'collected', label: 'Collected' },
      { key: 'delivered', label: 'Delivered' },
      { key: 'completed', label: 'Completed' },
    ];

    const currentStatusIndex = statusOrder.findIndex((s) => s.key === this.job?.status);

    return statusOrder.map((status, index) => {
      return {
        ...status,
        active: index === currentStatusIndex,
        completed: index < currentStatusIndex,
      };
    });
  }

  /**
   * Get vehicle brand logo path with improved filename normalization
   * @param make The vehicle manufacturer name
   * @returns Path to the logo image
   */
  getVehicleLogo(make: string): string {
    if (!make) return 'assets/images/car-logos/default.png';

    const specialCases: Record<string, string> = {
      'mercedes-benz': 'mercedes',
      'mercedes benz': 'mercedes',
      vw: 'volkswagen',
      'range rover': 'land_rover',
      'jaguar land rover': 'jaguar',
      'rolls-royce': 'rolls_royce',
      'rolls royce': 'rolls_royce',
      bmw: 'bmw',
      audi: 'audi',
      toyota: 'toyota',
      honda: 'honda',
      nissan: 'nissan',
      ford: 'ford',
      chevrolet: 'chevrolet',
      hyundai: 'hyundai',
      kia: 'kia',
      mazda: 'mazda',
      subaru: 'subaru',
      lexus: 'lexus',
      jeep: 'jeep',
      tesla: 'tesla',
      porsche: 'porsche',
      ferrari: 'ferrari',
      lamborghini: 'lamborghini',
      bentley: 'bentley',
      maserati: 'maserati',
      bugatti: 'bugatti',
      mini: 'mini',
    };

    const normalized = make.toLowerCase().trim();

    if (specialCases[normalized]) {
      return `assets/images/car-logos/${specialCases[normalized]}.png`;
    }

    const normalizedFilename = normalized
      .replace(/\s+/g, '_')
      .replace(/-/g, '_')
      .replace(/[^a-z0-9_]/g, '');

    return `assets/images/car-logos/${normalizedFilename}.png`;
  }

  /**
   * Handle image loading error by setting a default image
   * @param event The error event
   */
  handleImageError(event: Event): void {
    const imgElement = event.target as HTMLImageElement;
    imgElement.src = 'assets/images/car-logos/default.png';
  }

  /**
   * Show a snackbar notification
   * @param message The message to display
   */
  showSnackbar(message: string): void {
    this.snackBar.open(message, 'Close', {
      duration: 3000,
      horizontalPosition: 'center',
      verticalPosition: 'bottom',
    });
  }

  /**
   * Add this import to the top of your job-details.component.ts file:
   * import { JobDuplicateDialogComponent } from '../../../dialogs/job-duplicate-dialog.component';
   *
   * Then add this method to your JobDetailsComponent class:
   */

  /**
   * Duplicate the current job
   */
  duplicateJob(): void {
    if (!this.job) return;

    const dialogRef = this.dialog.open(JobDuplicateDialogComponent, {
      data: {
        jobId: this.job.id,
        registrationNumber: this.job['registration'],
        makeModel: this.job.make && this.job.model ? `${this.job.make} ${this.job.model}` : undefined,
      },
      width: '400px',
      panelClass: ['custom-dialog-container', 'duplication-dialog'],
    });

    dialogRef.afterClosed().subscribe((result) => {
      if (this.isDestroyed) return;

      if (result) {
        this.isLoading = true;
        this.cdr.detectChanges();

        this.jobService.duplicateJob(this.job!.id).subscribe({
          next: (newJobId) => {
            this.isLoading = false;
            this.showSnackbar('Job duplicated successfully');
            this.router.navigate(['/jobs', newJobId]);
          },
          error: (error) => {
            console.error('Error duplicating job:', error);
            this.isLoading = false;
            this.showSnackbar('Error duplicating job: ' + error.message);
            this.cdr.detectChanges();
          },
        });
      }
    });
  }
}


--- ./src/app/services/firebase.service.ts ---
import { Injectable } from '@angular/core';
import { Firestore, collection, doc, getDoc, getDocs, addDoc, updateDoc, query, where, orderBy, deleteDoc } from '@angular/fire/firestore';
import { Observable, from, of } from 'rxjs';
import { map, catchError } from 'rxjs/operators';

@Injectable({
  providedIn: 'root',
})
export class FirebaseService {
  constructor(private firestore: Firestore) {}

  /**
   * Get all documents from a collection
   */
  getCollection<T>(collectionName: string): Observable<T[]> {
    const collectionRef = collection(this.firestore, collectionName);
    return from(getDocs(collectionRef)).pipe(
      map((snapshot) => {
        return snapshot.docs.map((doc) => {
          return { id: doc.id, ...doc.data() } as unknown as T;
        });
      }),
      catchError((error) => {
        console.error(`Error fetching collection ${collectionName}:`, error);
        return of([] as T[]);
      })
    );
  }

  /**
   * Get a specific document by ID
   */
  getDocument<T>(collectionName: string, documentId: string): Observable<T | null> {
    const docRef = doc(this.firestore, `${collectionName}/${documentId}`);
    return from(getDoc(docRef)).pipe(
      map((docSnap) => {
        if (docSnap.exists()) {
          return { id: docSnap.id, ...docSnap.data() } as unknown as T;
        } else {
          return null;
        }
      }),
      catchError((error) => {
        console.error(`Error fetching document ${documentId} from ${collectionName}:`, error);
        return of(null);
      })
    );
  }

  /**
   * Add a new document to a collection
   */
  addDocument<T>(collectionName: string, data: any): Observable<string> {
    const collectionRef = collection(this.firestore, collectionName);
    return from(addDoc(collectionRef, data)).pipe(
      map((docRef) => docRef.id),
      catchError((error) => {
        console.error(`Error adding document to ${collectionName}:`, error);
        throw error;
      })
    );
  }

  /**
   * Update an existing document
   */
  updateDocument(collectionName: string, documentId: string, data: any): Observable<void> {
    const docRef = doc(this.firestore, `${collectionName}/${documentId}`);
    return from(updateDoc(docRef, data)).pipe(
      catchError((error) => {
        console.error(`Error updating document ${documentId} in ${collectionName}:`, error);
        throw error;
      })
    );
  }

  /**
   * Query a collection with filtering
   */
  queryCollection<T>(
    collectionName: string,
    fieldPath: string,
    operator: '==' | '!=' | '<' | '<=' | '>' | '>=',
    value: any,
    orderByField?: string,
    orderDirection?: 'asc' | 'desc'
  ): Observable<T[]> {
    const collectionRef = collection(this.firestore, collectionName);

    let q = query(collectionRef, where(fieldPath, operator, value));

    if (orderByField) {
      q = query(q, orderBy(orderByField, orderDirection || 'asc'));
    }

    return from(getDocs(q)).pipe(
      map((snapshot) => {
        return snapshot.docs.map((doc) => {
          return { id: doc.id, ...doc.data() } as unknown as T;
        });
      }),
      catchError((error) => {
        console.error(`Error querying collection ${collectionName}:`, error);
        return of([] as T[]);
      })
    );
  }

  /**
   * Delete a document from a collection
   */
  deleteDocument(collectionName: string, documentId: string): Observable<void> {
    const docRef = doc(this.firestore, `${collectionName}/${documentId}`);

    return from(deleteDoc(docRef)).pipe(
      catchError((error) => {
        console.error(`Error deleting document ${documentId} from ${collectionName}:`, error);
        throw error;
      })
    );
  }
}


--- ./src/app/services/auth.service.ts ---
import { Injectable } from '@angular/core';
import {
  Auth,
  User,
  UserCredential,
  createUserWithEmailAndPassword,
  onAuthStateChanged,
  sendPasswordResetEmail,
  signInWithEmailAndPassword,
  signOut,
  updateProfile,
} from '@angular/fire/auth';
import { Firestore, collection, doc, getDoc, getDocs, query, setDoc, where, serverTimestamp, orderBy, limit } from '@angular/fire/firestore';
import { BehaviorSubject, Observable, from, of } from 'rxjs';
import { catchError, map, switchMap, tap } from 'rxjs/operators';
import { UserPermissionKey, UserProfile } from '../interfaces/user-profile.interface';

@Injectable({
  providedIn: 'root',
})
export class AuthService {
  private userSubject = new BehaviorSubject<User | null>(null);
  public user$ = this.userSubject.asObservable();

  private userProfileSubject = new BehaviorSubject<UserProfile | null>(null);
  public userProfile$ = this.userProfileSubject.asObservable();

  constructor(private auth: Auth, private firestore: Firestore) {
    // Initialize auth state listener
    onAuthStateChanged(this.auth, (user) => {
      this.userSubject.next(user);

      // If user is logged in, fetch their profile
      if (user) {
        this.fetchUserProfile(user.uid).subscribe();
      } else {
        this.userProfileSubject.next(null);
      }
    });
  }

  /**
   * Sign in with email and password
   */
  signIn(email: string, password: string): Observable<UserCredential> {
    return from(signInWithEmailAndPassword(this.auth, email, password)).pipe(
      tap((userCredential) => {
        this.userSubject.next(userCredential.user);
        this.fetchUserProfile(userCredential.user.uid).subscribe();
      }),
      catchError((error) => {
        console.error('Sign in error:', error);
        throw error;
      })
    );
  }

  /**
   * Sign up with email and password, and create a user profile
   */
  signUp(email: string, password: string, userData: { firstName: string; lastName: string }): Observable<void> {
    return from(createUserWithEmailAndPassword(this.auth, email, password)).pipe(
      switchMap(async (userCredential) => {
        // Update user profile with display name
        const displayName = `${userData.firstName} ${userData.lastName}`.trim();
        await updateProfile(userCredential.user, { displayName });

        // Create user document in Firestore
        const userDocRef = doc(this.firestore, `users/${userCredential.user.uid}`);
        return setDoc(userDocRef, {
          email: userCredential.user.email,
          firstName: userData.firstName,
          lastName: userData.lastName,
          name: displayName,
          role: 'user', // Default role
          isActive: true,
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp(),
          permissions: {
            // Default permissions
            canViewUnallocated: false,
            canAllocateJobs: false,
            canApproveExpenses: false,
            canCreateJobs: false,
            canEditJobs: false,
            canManageUsers: false,
            canViewReports: false,
            isAdmin: false,
          },
        });
      }),
      catchError((error) => {
        console.error('Sign up error:', error);
        throw error;
      })
    );
  }

  /**
   * Send password reset email
   */
  resetPassword(email: string): Observable<void> {
    return from(sendPasswordResetEmail(this.auth, email)).pipe(
      catchError((error) => {
        console.error('Password reset error:', error);
        throw error;
      })
    );
  }

  /**
   * Sign out
   */
  signOut(): Observable<void> {
    return from(signOut(this.auth)).pipe(
      tap(() => {
        this.userSubject.next(null);
        this.userProfileSubject.next(null);
      }),
      catchError((error) => {
        console.error('Sign out error:', error);
        throw error;
      })
    );
  }

  /**
   * Get the current user's profile
   */
  getUserProfile(): Observable<UserProfile | null> {
    return this.userProfile$;
  }

  /**
   * Get all users in the system
   */
  getAllUsers(): Observable<UserProfile[]> {
    const usersRef = collection(this.firestore, 'users');
    const q = query(usersRef, orderBy('lastName'));

    return from(getDocs(q)).pipe(
      map((snapshot) => {
        return snapshot.docs.map((doc) => {
          return this.convertFirebaseUserToProfile(doc.id, doc.data());
        });
      }),
      catchError((error) => {
        console.error('Error fetching users:', error);
        return of([]);
      })
    );
  }

  /**
   * Get a user by email
   */
  getUserByEmail(email: string): Observable<UserProfile | null> {
    if (!email) {
      return of(null);
    }

    const usersRef = collection(this.firestore, 'users');
    const q = query(usersRef, where('email', '==', email), limit(1));

    return from(getDocs(q)).pipe(
      map((snapshot) => {
        if (snapshot.empty) {
          return null;
        }

        const doc = snapshot.docs[0];
        return this.convertFirebaseUserToProfile(doc.id, doc.data());
      }),
      catchError((error) => {
        console.error('Error fetching user by email:', error);
        return of(null);
      })
    );
  }

  /**
   * Get the current user
   */
  get currentUser(): User | null {
    return this.auth.currentUser;
  }

  /**
   * Get the current user's ID
   */
  get currentUserId(): string | null {
    return this.auth.currentUser?.uid || null;
  }

  /**
   * Get a user profile by ID
   */
  getUserById(userId: string): Observable<UserProfile | null> {
    if (!userId) {
      return of(null);
    }

    const userDocRef = doc(this.firestore, `users/${userId}`);

    return from(getDoc(userDocRef)).pipe(
      map((docSnap) => {
        if (docSnap.exists()) {
          const profile = this.convertFirebaseUserToProfile(userId, docSnap.data());
          return profile;
        } else {
          return null;
        }
      }),
      catchError((error) => {
        console.error('Error fetching user profile by ID:', error);
        return of(null);
      })
    );
  }

  /**
   * Check if the current user has a specific permission
   */
  hasPermission(permission: string | UserPermissionKey): Observable<boolean> {
    return this.userProfile$.pipe(
      map((profile) => {
        if (!profile) return false;

        // Admin always has all permissions
        if (profile.permissions?.isAdmin) return true;

        // Check specific permission
        return !!profile.permissions?.[permission as keyof typeof profile.permissions];
      })
    );
  }

  /**
   * Check if the current user has any of the specified permissions
   */
  hasAnyPermission(permissions: string[] | UserPermissionKey[]): Observable<boolean> {
    return this.userProfile$.pipe(
      map((profile) => {
        if (!profile) return false;

        // Admin always has all permissions
        if (profile.permissions?.isAdmin) return true;

        // Check if user has any of the required permissions
        return permissions.some((permission) => profile.permissions && (profile.permissions[permission as keyof typeof profile.permissions] as boolean));
      })
    );
  }

  /**
   * Get all drivers (users with role = 'driver')
   */
  getDrivers(): Observable<UserProfile[]> {
    const usersRef = collection(this.firestore, 'users');
    const q = query(usersRef, where('role', '==', 'driver'));

    return from(getDocs(q)).pipe(
      map((snapshot) => {
        return snapshot.docs.map((doc) => {
          return this.convertFirebaseUserToProfile(doc.id, doc.data());
        });
      }),
      catchError((error) => {
        console.error('Error fetching drivers:', error);
        return of([]);
      })
    );
  }

  /**
   * Get all users with a specific role
   */
  getUsersByRole(role: string): Observable<UserProfile[]> {
    const usersRef = collection(this.firestore, 'users');
    const q = query(usersRef, where('role', '==', role), where('isActive', '==', true));

    return from(getDocs(q)).pipe(
      map((snapshot) => {
        return snapshot.docs.map((doc) => {
          return this.convertFirebaseUserToProfile(doc.id, doc.data());
        });
      }),
      catchError((error) => {
        console.error(`Error fetching users with role ${role}:`, error);
        return of([]);
      })
    );
  }

  /**
   * Update user profile
   */
  updateUserProfile(userId: string, profileData: Partial<UserProfile>): Observable<void> {
    const userDocRef = doc(this.firestore, `users/${userId}`);

    // Remove id from the profileData to avoid overwriting it
    const { id, ...updateData } = profileData;

    // Add updatedAt timestamp
    const data = {
      ...updateData,
      updatedAt: serverTimestamp(),
    };

    return from(setDoc(userDocRef, data, { merge: true })).pipe(
      tap(() => {
        // Refresh the user profile if it's the current user
        if (this.auth.currentUser?.uid === userId) {
          this.fetchUserProfile(userId).subscribe();
        }
      }),
      catchError((error) => {
        console.error('Error updating user profile:', error);
        throw error;
      })
    );
  }

  /**
   * Check if the user is authenticated
   */
  isAuthenticated(): Observable<boolean> {
    return this.user$.pipe(map((user) => !!user));
  }

  /**
   * Check if the current user is an admin
   */
  isAdmin(): Observable<boolean> {
    return this.userProfile$.pipe(map((profile) => !!profile?.permissions?.isAdmin));
  }

  /**
   * Fetch user profile from Firestore
   */
  private fetchUserProfile(uid: string): Observable<UserProfile | null> {
    const userDocRef = doc(this.firestore, `users/${uid}`);

    return from(getDoc(userDocRef)).pipe(
      map((docSnap) => {
        if (docSnap.exists()) {
          const profile = this.convertFirebaseUserToProfile(uid, docSnap.data());
          this.userProfileSubject.next(profile);
          return profile;
        } else {
          this.userProfileSubject.next(null);
          return null;
        }
      }),
      catchError((error) => {
        console.error('Error fetching user profile:', error);
        this.userProfileSubject.next(null);
        return of(null);
      })
    );
  }

  /**
   * Convert Firebase user data to UserProfile interface
   */
  private convertFirebaseUserToProfile(uid: string, data: any): UserProfile {
    // Handle Firebase timestamps
    const convertTimestamp = (timestamp: any): Date | undefined => {
      if (!timestamp) return undefined;

      // Firebase timestamp object with toDate() method
      if (timestamp && typeof timestamp === 'object' && 'toDate' in timestamp) {
        return timestamp.toDate();
      }

      // String or number timestamp
      if (timestamp) {
        return new Date(timestamp);
      }

      return undefined;
    };

    return {
      id: uid,
      email: data.email || '',
      name: data.name || `${data.firstName || ''} ${data.lastName || ''}`.trim(),
      firstName: data.firstName || '',
      lastName: data.lastName || '',
      phoneNumber: data.phoneNumber || '',
      role: data.role || '',
      isActive: data.isActive !== false,
      permissions: data.permissions || {},
      createdAt: convertTimestamp(data.createdAt),
      updatedAt: convertTimestamp(data.updatedAt),
    };
  }
}


--- ./src/app/services/driver.service.ts ---
import { Injectable } from '@angular/core';
import { Auth } from '@angular/fire/auth';
import { Firestore, collection, deleteDoc, doc, getDocs, orderBy, query, serverTimestamp, setDoc, updateDoc, where } from '@angular/fire/firestore';
import { BehaviorSubject, Observable, from, of, throwError } from 'rxjs';
import { catchError, map, switchMap, tap } from 'rxjs/operators';

import { Job } from '../interfaces/job.interface';
import { ROLE_PERMISSION_PRESETS, UserProfile, UserRole } from '../interfaces/user-profile.interface';
import { Expense } from '../shared/models/expense.model';
import { AuthService } from './auth.service';
import { BaseFirebaseService } from './base-firebase.service';
import { NotificationService } from './notification.service';

export interface DriverNote {
  id: string;
  driverId: string;
  content: string;
  date: Date;
  authorId: string;
  authorName: string;
}

export interface DriverStats {
  totalJobs: number;
  pendingJobs: number;
  completedJobs: number;
  pendingExpenses: number;
}

@Injectable({
  providedIn: 'root',
})
export class DriverService extends BaseFirebaseService {
  private driversSubject = new BehaviorSubject<UserProfile[]>([]);
  private loadingSubject = new BehaviorSubject<boolean>(false);

  public drivers$ = this.driversSubject.asObservable();
  public loading$ = this.loadingSubject.asObservable();

  constructor(
    protected override firestore: Firestore,
    protected override auth: Auth,
    private authService: AuthService,
    private notificationService: NotificationService
  ) {
    super();
  }

  /**
   * Get all drivers
   */
  getAllDrivers(): Observable<UserProfile[]> {
    this.loadingSubject.next(true);

    const usersRef = collection(this.firestore, 'users');
    const q = query(usersRef, orderBy('lastName'));

    return from(getDocs(q)).pipe(
      map((snapshot) => {
        const drivers = snapshot.docs.map((doc) => {
          return this.convertFirebaseUserToProfile(doc.id, doc.data());
        });
        this.driversSubject.next(drivers);
        return drivers;
      }),
      tap(() => this.loadingSubject.next(false)),
      catchError((error) => {
        console.error('Error fetching drivers:', error);
        this.loadingSubject.next(false);
        return of([]);
      })
    );
  }

  /**
   * Get drivers by role
   */
  getDriversByRole(role: UserRole): Observable<UserProfile[]> {
    this.loadingSubject.next(true);

    const usersRef = collection(this.firestore, 'users');
    const q = query(usersRef, where('role', '==', role), where('isActive', '==', true), orderBy('lastName'));

    return from(getDocs(q)).pipe(
      map((snapshot) => {
        const drivers = snapshot.docs.map((doc) => {
          return this.convertFirebaseUserToProfile(doc.id, doc.data());
        });
        return drivers;
      }),
      tap(() => this.loadingSubject.next(false)),
      catchError((error) => {
        console.error(`Error fetching drivers with role ${role}:`, error);
        this.loadingSubject.next(false);
        return of([]);
      })
    );
  }

  /**
   * Get active drivers
   */
  getActiveDrivers(): Observable<UserProfile[]> {
    this.loadingSubject.next(true);

    const usersRef = collection(this.firestore, 'users');
    const q = query(usersRef, where('isActive', '==', true), orderBy('lastName'));

    return from(getDocs(q)).pipe(
      map((snapshot) => {
        const drivers = snapshot.docs.map((doc) => {
          return this.convertFirebaseUserToProfile(doc.id, doc.data());
        });
        return drivers;
      }),
      tap(() => this.loadingSubject.next(false)),
      catchError((error) => {
        console.error('Error fetching active drivers:', error);
        this.loadingSubject.next(false);
        return of([]);
      })
    );
  }

  /**
   * Get driver by ID
   */
  getDriverById(driverId: string): Observable<UserProfile | null> {
    this.loadingSubject.next(true);

    if (!driverId) {
      this.loadingSubject.next(false);
      return of(null);
    }

    return this.authService.getUserById(driverId).pipe(
      tap(() => this.loadingSubject.next(false)),
      catchError((error) => {
        console.error(`Error fetching driver ${driverId}:`, error);
        this.loadingSubject.next(false);
        return of(null);
      })
    );
  }

  /**
   * Create a new driver
   */
  createDriver(email: string, password: string, userData: Partial<UserProfile>, sendCredentials: boolean = true): Observable<string> {
    this.loadingSubject.next(true);

    return this.authService
      .signUp(email, password, {
        firstName: userData.firstName || '',
        lastName: userData.lastName || '',
      })
      .pipe(
        switchMap(() => {
          return this.authService.getUserByEmail(email);
        }),
        switchMap((user) => {
          if (!user) {
            throw new Error('Failed to create user');
          }

          // Apply role permissions
          const role = (userData.role as UserRole) || UserRole.DRIVER;
          const permissions = ROLE_PERMISSION_PRESETS[role];

          // Update the user profile with additional information
          return this.authService
            .updateUserProfile(user.id, {
              ...userData,
              name: `${userData.firstName} ${userData.lastName}`.trim(),
              role: role,
              isActive: true,
              permissions: permissions,
              createdAt: new Date(),
              updatedAt: new Date(),
            })
            .pipe(
              map(() => {
                // Handle sending credentials email if requested
                if (sendCredentials) {
                  console.log('Sending credentials email to:', email);
                  // In a real app, implement email sending logic here
                }
                return user.id;
              })
            );
        }),
        tap(() => this.loadingSubject.next(false)),
        catchError((error) => {
          console.error('Error creating driver:', error);
          this.loadingSubject.next(false);
          return throwError(() => new Error(`Failed to create driver: ${error.message}`));
        })
      );
  }

  /**
   * Update an existing driver
   */
  updateDriver(driverId: string, userData: Partial<UserProfile>): Observable<void> {
    this.loadingSubject.next(true);

    if (!driverId) {
      this.loadingSubject.next(false);
      return throwError(() => new Error('Driver ID is required'));
    }

    // If role is changing, apply the new role's permissions
    let updatedData = { ...userData };
    if (userData.role) {
      const role = userData.role as UserRole;
      updatedData.permissions = ROLE_PERMISSION_PRESETS[role];
    }

    // Update name if first or last name is provided
    if (userData.firstName || userData.lastName) {
      updatedData.name = `${userData.firstName || ''} ${userData.lastName || ''}`.trim();
    }

    // Add updated timestamp
    updatedData.updatedAt = new Date();

    return this.authService.updateUserProfile(driverId, updatedData).pipe(
      tap(() => this.loadingSubject.next(false)),
      catchError((error) => {
        console.error(`Error updating driver ${driverId}:`, error);
        this.loadingSubject.next(false);
        return throwError(() => new Error(`Failed to update driver: ${error.message}`));
      })
    );
  }

  /**
   * Update driver permissions
   */
  updateDriverPermissions(driverId: string, role: UserRole): Observable<void> {
    this.loadingSubject.next(true);

    if (!driverId) {
      this.loadingSubject.next(false);
      return throwError(() => new Error('Driver ID is required'));
    }

    // Get permissions preset for the role
    const permissions = ROLE_PERMISSION_PRESETS[role];
    if (!permissions) {
      this.loadingSubject.next(false);
      return throwError(() => new Error('Invalid role specified'));
    }

    return this.authService
      .updateUserProfile(driverId, {
        role: role,
        permissions: permissions,
        updatedAt: new Date(),
      })
      .pipe(
        tap(() => this.loadingSubject.next(false)),
        catchError((error) => {
          console.error(`Error updating driver permissions ${driverId}:`, error);
          this.loadingSubject.next(false);
          return throwError(() => new Error(`Failed to update driver permissions: ${error.message}`));
        })
      );
  }

  /**
   * Deactivate driver (soft delete)
   */
  deactivateDriver(driverId: string): Observable<void> {
    this.loadingSubject.next(true);

    if (!driverId) {
      this.loadingSubject.next(false);
      return throwError(() => new Error('Driver ID is required'));
    }

    return this.authService
      .updateUserProfile(driverId, {
        isActive: false,
        updatedAt: new Date(),
      })
      .pipe(
        tap(() => this.loadingSubject.next(false)),
        catchError((error) => {
          console.error(`Error deactivating driver ${driverId}:`, error);
          this.loadingSubject.next(false);
          return throwError(() => new Error(`Failed to deactivate driver: ${error.message}`));
        })
      );
  }

  /**
   * Get driver statistics
   */
  getDriverStats(driverId: string): Observable<DriverStats> {
    this.loadingSubject.next(true);

    if (!driverId) {
      this.loadingSubject.next(false);
      return of({
        totalJobs: 0,
        pendingJobs: 0,
        completedJobs: 0,
        pendingExpenses: 0,
      });
    }

    // Get jobs collection
    const jobsRef = collection(this.firestore, 'jobs');
    const jobsQuery = query(jobsRef, where('driverId', '==', driverId));

    // Get expenses collection
    const expensesRef = collection(this.firestore, 'expenses');
    const expensesQuery = query(expensesRef, where('driverId', '==', driverId));

    // Execute both queries
    return from(Promise.all([getDocs(jobsQuery), getDocs(expensesQuery)])).pipe(
      map(([jobsSnapshot, expensesSnapshot]) => {
        // Extract jobs
        const jobs = jobsSnapshot.docs.map((doc) => doc.data() as Job);

        // Extract expenses
        const expenses = expensesSnapshot.docs.map((doc) => doc.data() as Expense);

        // Calculate statistics
        const totalJobs = jobs.length;
        const pendingJobs = jobs.filter((job) => job.status === 'allocated' || job.status === 'collected').length;
        const completedJobs = jobs.filter((job) => job.status === 'delivered' || job.status === 'completed').length;
        const pendingExpenses = expenses.filter((expense) => expense.status === 'Pending').length;

        return {
          totalJobs,
          pendingJobs,
          completedJobs,
          pendingExpenses,
        };
      }),
      tap(() => this.loadingSubject.next(false)),
      catchError((error) => {
        console.error(`Error fetching driver stats for ${driverId}:`, error);
        this.loadingSubject.next(false);
        return of({
          totalJobs: 0,
          pendingJobs: 0,
          completedJobs: 0,
          pendingExpenses: 0,
        });
      })
    );
  }

  /**
   * Get driver notes
   */
  getDriverNotes(driverId: string): Observable<DriverNote[]> {
    this.loadingSubject.next(true);

    if (!driverId) {
      this.loadingSubject.next(false);
      return of([]);
    }

    const notesRef = collection(this.firestore, 'driverNotes');
    const q = query(notesRef, where('driverId', '==', driverId), orderBy('date', 'desc'));

    return from(getDocs(q)).pipe(
      map((snapshot) => {
        const notes = snapshot.docs.map((doc) => {
          const data = doc.data();
          return {
            id: doc.id,
            driverId: data['driverId'] || '',
            content: data['content'] || '',
            date: this.convertTimestamp(data['date']) || new Date(),
            authorId: data['authorId'] || '',
            authorName: data['authorName'] || 'Unknown User',
          } as DriverNote;
        });
        return notes;
      }),
      tap(() => this.loadingSubject.next(false)),
      catchError((error) => {
        console.error(`Error fetching notes for driver ${driverId}:`, error);
        this.loadingSubject.next(false);
        return of([]);
      })
    );
  }

  /**
   * Add note to driver
   */
  addDriverNote(driverId: string, content: string, authorId: string, authorName: string): Observable<string> {
    this.loadingSubject.next(true);

    if (!driverId) {
      this.loadingSubject.next(false);
      return throwError(() => new Error('Driver ID is required'));
    }

    if (!content) {
      this.loadingSubject.next(false);
      return throwError(() => new Error('Note content is required'));
    }

    const notesRef = collection(this.firestore, 'driverNotes');
    const noteData = {
      driverId,
      content,
      date: serverTimestamp(),
      authorId,
      authorName,
    };

    return from(addDoc(notesRef, noteData).then((docRef) => docRef.id)).pipe(
      tap(() => this.loadingSubject.next(false)),
      catchError((error) => {
        console.error(`Error adding note to driver ${driverId}:`, error);
        this.loadingSubject.next(false);
        return throwError(() => new Error(`Failed to add note: ${error.message}`));
      })
    );

    // Helper function for adding a document (not available directly in Angular Fire)
    function addDoc(ref: any, data: any): Promise<any> {
      const newDocRef = doc(ref);
      return setDoc(newDocRef, data).then(() => newDocRef);
    }
  }

  /**
   * Update driver note
   */
  updateDriverNote(noteId: string, content: string): Observable<void> {
    this.loadingSubject.next(true);

    if (!noteId) {
      this.loadingSubject.next(false);
      return throwError(() => new Error('Note ID is required'));
    }

    if (!content) {
      this.loadingSubject.next(false);
      return throwError(() => new Error('Note content is required'));
    }

    const noteRef = doc(this.firestore, `driverNotes/${noteId}`);
    const updateData = {
      content,
      updatedAt: serverTimestamp(),
    };

    return from(updateDoc(noteRef, updateData)).pipe(
      tap(() => this.loadingSubject.next(false)),
      catchError((error) => {
        console.error(`Error updating note ${noteId}:`, error);
        this.loadingSubject.next(false);
        return throwError(() => new Error(`Failed to update note: ${error.message}`));
      })
    );
  }

  /**
   * Delete driver note
   */
  deleteDriverNote(noteId: string): Observable<void> {
    this.loadingSubject.next(true);

    if (!noteId) {
      this.loadingSubject.next(false);
      return throwError(() => new Error('Note ID is required'));
    }

    const noteRef = doc(this.firestore, `driverNotes/${noteId}`);

    return from(deleteDoc(noteRef)).pipe(
      tap(() => this.loadingSubject.next(false)),
      catchError((error) => {
        console.error(`Error deleting note ${noteId}:`, error);
        this.loadingSubject.next(false);
        return throwError(() => new Error(`Failed to delete note: ${error.message}`));
      })
    );
  }

  /**
   * Search for drivers by name or email
   */
  searchDrivers(searchTerm: string): Observable<UserProfile[]> {
    if (!searchTerm || searchTerm.trim().length < 2) {
      return of([]);
    }

    const searchTermLower = searchTerm.toLowerCase().trim();

    // Firebase doesn't support text search, so we'll fetch all users and filter
    return this.getAllDrivers().pipe(
      map((drivers) => {
        return drivers.filter((driver) => {
          const nameMatch = driver.name?.toLowerCase().includes(searchTermLower);
          const emailMatch = driver.email?.toLowerCase().includes(searchTermLower);
          const firstNameMatch = driver.firstName?.toLowerCase().includes(searchTermLower);
          const lastNameMatch = driver.lastName?.toLowerCase().includes(searchTermLower);
          const phoneMatch = driver.phoneNumber?.includes(searchTerm) || driver.phone?.includes(searchTerm);

          return nameMatch || emailMatch || firstNameMatch || lastNameMatch || phoneMatch;
        });
      })
    );
  }

  /**
   * Convert Firebase user data to UserProfile interface
   */
  private convertFirebaseUserToProfile(uid: string, data: any): UserProfile {
    return {
      id: uid,
      email: data.email || '',
      name: data.name || `${data.firstName || ''} ${data.lastName || ''}`.trim(),
      firstName: data.firstName || '',
      lastName: data.lastName || '',
      phoneNumber: data.phoneNumber || data.phone || '',
      phone: data.phoneNumber || data.phone || '',
      role: data.role || UserRole.DRIVER,
      status: data.isActive ? 'active' : 'inactive',
      isActive: data.isActive !== false,
      company: data.company || '',
      type: data.type || 'customer',
      lastActivity: this.convertTimestamp(data.lastActivity) || this.convertTimestamp(data.updatedAt),
      createdAt: this.convertTimestamp(data.createdAt),
      updatedAt: this.convertTimestamp(data.updatedAt),
      permissions: data.permissions || {},
      licenseNumber: data.licenseNumber,
      licenseExpiry: this.convertTimestamp(data.licenseExpiry),
      vehicleType: data.vehicleType,
      areaCoverage: data.areaCoverage,
      availability: data.availability,
      notes: '',
    };
  }
}


--- ./src/app/services/vehicle.service.ts ---
import { Injectable } from '@angular/core';
import { Auth } from '@angular/fire/auth';
import {
  Firestore,
  collection,
  doc,
  getDoc,
  getDocs,
  addDoc,
  setDoc,
  updateDoc,
  query,
  where,
  orderBy,
  deleteDoc,
  serverTimestamp,
  DocumentReference,
  Timestamp,
  limit,
} from '@angular/fire/firestore';
import { Observable, BehaviorSubject, from, of, throwError } from 'rxjs';
import { catchError, map, tap, switchMap } from 'rxjs/operators';
import { BaseFirebaseService } from './base-firebase.service';
import { NotificationService } from './notification.service';

export interface VehicleMake {
  id: string;
  name: string;
  displayName: string;
  type: string;
  vehicleTypes: string[];
  icon?: string;
  isActive: boolean;
}

export interface VehicleModel {
  id: string;
  name: string;
  makeId: string;
  type: string;
  isActive: boolean;
}

export interface Vehicle {
  id: string;
  registration: string;
  chassisNumber: string;
  makeId: string;
  makeName: string;
  modelId: string;
  modelName: string;
  type: string;
  color: string;
  year: number;
  firstProcessedDate: Date;
  lastProcessedDate: Date;
  mileage: number;
  fuelType?: string;
  transmission?: string;
  engineSize?: string;
  vin?: string;
  photos?: VehiclePhoto[];
  conditionReports?: ConditionReport[];
  jobCount: number;
  jobHistory: string[];
  notes?: string;
}

export interface VehiclePhoto {
  id: string;
  url: string;
  type: string;
  takenBy: string;
  takenAt: Date;
  jobId: string;
  notes?: string;
}

export interface ConditionReport {
  id: string;
  jobId: string;
  createdBy: string;
  createdAt: Date;
  damageNotes?: string;
  mileage: number;
  fuelLevel: string;
  cleanliness: string;
  interiorCondition: string;
  exteriorCondition: string;
  additionalNotes?: string;
}

@Injectable({
  providedIn: 'root',
})
export class VehicleService extends BaseFirebaseService {
  private vehiclesSubject = new BehaviorSubject<Vehicle[]>([]);
  private loadingSubject = new BehaviorSubject<boolean>(false);

  public vehicles$ = this.vehiclesSubject.asObservable();
  public loading$ = this.loadingSubject.asObservable();

  constructor(protected override firestore: Firestore, protected override auth: Auth, private notificationService: NotificationService) {
    super();
  }

  /**
   * Get all vehicles
   */
  getVehicles(): Observable<Vehicle[]> {
    this.loadingSubject.next(true);

    const vehiclesRef = collection(this.firestore, 'vehicles');
    const q = query(vehiclesRef, orderBy('lastProcessedDate', 'desc'));

    return from(getDocs(q)).pipe(
      map((snapshot) => {
        const vehicles = snapshot.docs.map((doc) => {
          return this.convertFirebaseVehicleToModel(doc.id, doc.data());
        });
        this.vehiclesSubject.next(vehicles);
        return vehicles;
      }),
      tap(() => this.loadingSubject.next(false)),
      catchError((error) => {
        console.error('Error fetching vehicles:', error);
        this.loadingSubject.next(false);
        this.vehiclesSubject.next([]);
        return of([]);
      })
    );
  }

  /**
   * Get vehicle by ID
   */
  getVehicleById(vehicleId: string): Observable<Vehicle | null> {
    this.loadingSubject.next(true);

    if (!vehicleId) {
      this.loadingSubject.next(false);
      return of(null);
    }

    const vehicleRef = doc(this.firestore, `vehicles/${vehicleId}`);

    return from(getDoc(vehicleRef)).pipe(
      map((docSnap) => {
        if (docSnap.exists()) {
          return this.convertFirebaseVehicleToModel(docSnap.id, docSnap.data());
        } else {
          return null;
        }
      }),
      tap(() => this.loadingSubject.next(false)),
      catchError((error) => {
        console.error(`Error fetching vehicle ${vehicleId}:`, error);
        this.loadingSubject.next(false);
        return of(null);
      })
    );
  }

  /**
   * Create a new vehicle
   */
  createVehicle(vehicleData: Omit<Vehicle, 'id'>): Observable<string> {
    this.loadingSubject.next(true);

    // Get the current user ID
    const userId = this.currentUserId;
    if (!userId) {
      this.loadingSubject.next(false);
      return throwError(() => new Error('User not authenticated'));
    }

    // Prepare vehicle data
    const newVehicleData = {
      ...vehicleData,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
      createdBy: userId,
      updatedBy: userId,
      // Keep the existing dates from vehicleData but convert to server timestamp
      // if firstProcessedDate is already provided in vehicleData, use it instead of creating a new one
      firstProcessedDate: serverTimestamp(),
      lastProcessedDate: serverTimestamp(),
      // Note: jobCount, jobHistory, photos, and conditionReports are expected to be
      // provided by the caller now
    };

    // Use registration number as document ID
    const docId = vehicleData.registration?.toUpperCase();
    if (!docId) {
      this.loadingSubject.next(false);
      return throwError(() => new Error('Registration number is required'));
    }

    const vehicleRef = doc(this.firestore, `vehicles/${docId}`);

    return from(setDoc(vehicleRef, newVehicleData)).pipe(
      map(() => {
        // Refresh the vehicles list
        this.refreshVehiclesList();

        // Add notification
        this.notificationService.addNotification({
          type: 'success',
          title: 'Vehicle Created',
          message: `Vehicle ${vehicleData.registration} has been added to the system`,
          actionUrl: `/vehicles/${docId}`,
        });

        return docId;
      }),
      tap(() => this.loadingSubject.next(false)),
      catchError((error) => {
        console.error('Error creating vehicle:', error);
        this.loadingSubject.next(false);
        return throwError(() => error);
      })
    );
  }

  /**
   * Update an existing vehicle
   */
  updateVehicle(vehicleId: string, data: Partial<Omit<Vehicle, 'id'>>): Observable<void> {
    this.loadingSubject.next(true);

    // Get the current user ID
    const userId = this.currentUserId;
    if (!userId) {
      this.loadingSubject.next(false);
      return throwError(() => new Error('User not authenticated'));
    }

    const vehicleRef = doc(this.firestore, `vehicles/${vehicleId}`);

    // Add updater and timestamp
    const vehicleUpdateData = {
      ...data,
      updatedAt: serverTimestamp(),
      updatedBy: userId,
      lastProcessedDate: serverTimestamp(),
    };

    return from(updateDoc(vehicleRef, vehicleUpdateData)).pipe(
      tap(() => {
        // Refresh the vehicles list
        this.refreshVehiclesList();

        // Add notification
        this.notificationService.addNotification({
          type: 'info',
          title: 'Vehicle Updated',
          message: `Vehicle ${vehicleId} has been updated`,
          actionUrl: `/vehicles/${vehicleId}`,
        });
      }),
      map(() => void 0),
      tap(() => this.loadingSubject.next(false)),
      catchError((error) => {
        console.error(`Error updating vehicle ${vehicleId}:`, error);
        this.loadingSubject.next(false);
        return throwError(() => error);
      })
    );
  }

  /**
   * Add a photo to a vehicle
   */
  addVehiclePhoto(vehicleId: string, photoData: Partial<VehiclePhoto>): Observable<string> {
    this.loadingSubject.next(true);

    // Get the current user ID
    const userId = this.currentUserId;
    if (!userId) {
      this.loadingSubject.next(false);
      return throwError(() => new Error('User not authenticated'));
    }

    // First get the vehicle document
    const vehicleRef = doc(this.firestore, `vehicles/${vehicleId}`);

    return from(getDoc(vehicleRef)).pipe(
      switchMap((docSnap) => {
        if (!docSnap.exists()) {
          throw new Error(`Vehicle ${vehicleId} not found`);
        }

        const vehicle = docSnap.data() as Vehicle;
        const photos = vehicle.photos || [];

        // Create a new photo object
        const photoId = this.generateId();
        const newPhoto: VehiclePhoto = {
          id: photoId,
          url: photoData.url || '',
          type: photoData.type || 'exterior',
          takenBy: userId,
          takenAt: new Date(),
          jobId: photoData.jobId || '',
          notes: photoData.notes || '',
        };

        // Add the new photo to the photos array
        photos.push(newPhoto);

        // Update the vehicle document
        return updateDoc(vehicleRef, {
          photos: photos,
          updatedAt: serverTimestamp(),
          updatedBy: userId,
          lastProcessedDate: serverTimestamp(),
        }).then(() => photoId);
      }),
      tap(() => this.loadingSubject.next(false)),
      catchError((error) => {
        console.error(`Error adding photo to vehicle ${vehicleId}:`, error);
        this.loadingSubject.next(false);
        return throwError(() => error);
      })
    );
  }

  /**
   * Add a condition report to a vehicle
   */
  addConditionReport(vehicleId: string, reportData: Partial<ConditionReport>): Observable<string> {
    this.loadingSubject.next(true);

    // Get the current user ID
    const userId = this.currentUserId;
    if (!userId) {
      this.loadingSubject.next(false);
      return throwError(() => new Error('User not authenticated'));
    }

    // First get the vehicle document
    const vehicleRef = doc(this.firestore, `vehicles/${vehicleId}`);

    return from(getDoc(vehicleRef)).pipe(
      switchMap((docSnap) => {
        if (!docSnap.exists()) {
          throw new Error(`Vehicle ${vehicleId} not found`);
        }

        const vehicle = docSnap.data() as Vehicle;
        const reports = vehicle.conditionReports || [];

        // Create a new report object
        const reportId = this.generateId();
        const newReport: ConditionReport = {
          id: reportId,
          jobId: reportData.jobId || '',
          createdBy: userId,
          createdAt: new Date(),
          damageNotes: reportData.damageNotes || '',
          mileage: reportData.mileage || 0,
          fuelLevel: reportData.fuelLevel || 'Unknown',
          cleanliness: reportData.cleanliness || 'Good',
          interiorCondition: reportData.interiorCondition || 'Good',
          exteriorCondition: reportData.exteriorCondition || 'Good',
          additionalNotes: reportData.additionalNotes || '',
        };

        // Add the new report to the reports array
        reports.push(newReport);

        // Update the vehicle document with the new report and mileage
        return updateDoc(vehicleRef, {
          conditionReports: reports,
          mileage: reportData.mileage || vehicle.mileage,
          updatedAt: serverTimestamp(),
          updatedBy: userId,
          lastProcessedDate: serverTimestamp(),
        }).then(() => reportId);
      }),
      tap(() => this.loadingSubject.next(false)),
      catchError((error) => {
        console.error(`Error adding condition report to vehicle ${vehicleId}:`, error);
        this.loadingSubject.next(false);
        return throwError(() => error);
      })
    );
  }

  /**
   * Add a job to vehicle history
   */
  addJobToVehicle(vehicleId: string, jobId: string): Observable<void> {
    this.loadingSubject.next(true);

    // Get the current user ID
    const userId = this.currentUserId;
    if (!userId) {
      this.loadingSubject.next(false);
      return throwError(() => new Error('User not authenticated'));
    }

    // First get the vehicle document
    const vehicleRef = doc(this.firestore, `vehicles/${vehicleId}`);

    return from(getDoc(vehicleRef)).pipe(
      switchMap((docSnap) => {
        if (!docSnap.exists()) {
          throw new Error(`Vehicle ${vehicleId} not found`);
        }

        const vehicle = docSnap.data() as Vehicle;
        const jobHistory = vehicle.jobHistory || [];

        // Check if job already exists in history
        if (!jobHistory.includes(jobId)) {
          // Add job to history and increment job count
          jobHistory.push(jobId);

          return updateDoc(vehicleRef, {
            jobHistory: jobHistory,
            jobCount: jobHistory.length,
            updatedAt: serverTimestamp(),
            updatedBy: userId,
            lastProcessedDate: serverTimestamp(),
          });
        }

        // Job already in history, no need to update
        return Promise.resolve();
      }),
      map(() => void 0),
      tap(() => this.loadingSubject.next(false)),
      catchError((error) => {
        console.error(`Error adding job to vehicle history for ${vehicleId}:`, error);
        this.loadingSubject.next(false);
        return throwError(() => error);
      })
    );
  }

  /**
   * Get vehicle makes
   */
  getVehicleMakes(): Observable<VehicleMake[]> {
    const makesRef = collection(this.firestore, 'vehicleMakes');
    const q = query(makesRef, orderBy('displayName'));

    return from(getDocs(q)).pipe(
      map((snapshot) => {
        return snapshot.docs.map((doc) => {
          return {
            id: doc.id,
            ...doc.data(),
          } as VehicleMake;
        });
      }),
      catchError((error) => {
        console.error('Error fetching vehicle makes:', error);
        return of([]);
      })
    );
  }

  /**
   * Create a new vehicle make
   */
  createVehicleMake(makeData: Partial<VehicleMake>): Observable<string> {
    // Get the current user ID
    const userId = this.currentUserId;
    if (!userId) {
      return throwError(() => new Error('User not authenticated'));
    }

    const makesRef = collection(this.firestore, 'vehicleMakes');

    // Use name as document ID (make it lowercase)
    const docId = makeData.name?.toLowerCase();
    if (!docId) {
      return throwError(() => new Error('Make name is required'));
    }

    const makeRef = doc(this.firestore, `vehicleMakes/${docId}`);

    // Prepare make data
    const newMakeData = {
      ...makeData,
      id: docId,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
      createdBy: userId,
      updatedBy: userId,
      vehicleTypes: makeData.vehicleTypes || [],
    };

    return from(setDoc(makeRef, newMakeData)).pipe(
      map(() => docId),
      catchError((error) => {
        console.error('Error creating vehicle make:', error);
        return throwError(() => error);
      })
    );
  }

  /**
   * Update a vehicle make
   */
  updateVehicleMake(makeId: string, data: Partial<VehicleMake>): Observable<void> {
    // Get the current user ID
    const userId = this.currentUserId;
    if (!userId) {
      return throwError(() => new Error('User not authenticated'));
    }

    const makeRef = doc(this.firestore, `vehicleMakes/${makeId}`);

    // Remove id from update data to avoid overwriting it
    const { id, ...updateData } = data;

    // Add updater and timestamp
    const makeUpdateData = {
      ...updateData,
      updatedAt: serverTimestamp(),
      updatedBy: userId,
    };

    return from(updateDoc(makeRef, makeUpdateData)).pipe(
      map(() => void 0),
      catchError((error) => {
        console.error(`Error updating vehicle make ${makeId}:`, error);
        return throwError(() => error);
      })
    );
  }

  /**
   * Get vehicle models
   */
  getVehicleModels(): Observable<VehicleModel[]> {
    const modelsRef = collection(this.firestore, 'vehicleModels');
    const q = query(modelsRef, orderBy('name'));

    return from(getDocs(q)).pipe(
      map((snapshot) => {
        return snapshot.docs.map((doc) => {
          return {
            id: doc.id,
            ...doc.data(),
          } as VehicleModel;
        });
      }),
      catchError((error) => {
        console.error('Error fetching vehicle models:', error);
        return of([]);
      })
    );
  }

  /**
   * Create a new vehicle model
   */
  createVehicleModel(modelData: Partial<VehicleModel>): Observable<string> {
    // Get the current user ID
    const userId = this.currentUserId;
    if (!userId) {
      return throwError(() => new Error('User not authenticated'));
    }

    const modelsRef = collection(this.firestore, 'vehicleModels');

    // Generate a unique model ID based on make and model
    const makeId = modelData.makeId;
    const modelName = modelData.name;

    if (!makeId || !modelName) {
      return throwError(() => new Error('Make ID and model name are required'));
    }

    // Create a document ID by combining make ID and model name
    const docId = `${makeId}_${modelName.toLowerCase().replace(/\s+/g, '_')}`;
    const modelRef = doc(this.firestore, `vehicleModels/${docId}`);

    // Prepare model data
    const newModelData = {
      ...modelData,
      id: docId,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
      createdBy: userId,
      updatedBy: userId,
    };

    return from(setDoc(modelRef, newModelData)).pipe(
      map(() => docId),
      catchError((error) => {
        console.error('Error creating vehicle model:', error);
        return throwError(() => error);
      })
    );
  }

  /**
   * Update a vehicle model
   */
  updateVehicleModel(modelId: string, data: Partial<VehicleModel>): Observable<void> {
    // Get the current user ID
    const userId = this.currentUserId;
    if (!userId) {
      return throwError(() => new Error('User not authenticated'));
    }

    const modelRef = doc(this.firestore, `vehicleModels/${modelId}`);

    // Remove id from update data to avoid overwriting it
    const { id, ...updateData } = data;

    // Add updater and timestamp
    const modelUpdateData = {
      ...updateData,
      updatedAt: serverTimestamp(),
      updatedBy: userId,
    };

    return from(updateDoc(modelRef, modelUpdateData)).pipe(
      map(() => void 0),
      catchError((error) => {
        console.error(`Error updating vehicle model ${modelId}:`, error);
        return throwError(() => error);
      })
    );
  }

  /**
   * Get vehicle models by make
   */
  getVehicleModelsByMake(makeId: string): Observable<VehicleModel[]> {
    if (!makeId) {
      return of([]);
    }

    const modelsRef = collection(this.firestore, 'vehicleModels');
    const q = query(modelsRef, where('makeId', '==', makeId), where('isActive', '==', true), orderBy('name'));

    return from(getDocs(q)).pipe(
      map((snapshot) => {
        return snapshot.docs.map((doc) => {
          return {
            id: doc.id,
            ...doc.data(),
          } as VehicleModel;
        });
      }),
      catchError((error) => {
        console.error(`Error fetching vehicle models for make ${makeId}:`, error);
        return of([]);
      })
    );
  }

  /**
   * Search vehicles by registration or chassis number
   */
  searchVehicles(searchTerm: string): Observable<Vehicle[]> {
    if (!searchTerm || searchTerm.length < 2) {
      return of([]);
    }

    const vehiclesRef = collection(this.firestore, 'vehicles');
    // Since Firebase doesn't support regex search, we'll do a client-side filter
    const q = query(vehiclesRef, limit(100)); // Limit to avoid large result sets

    return from(getDocs(q)).pipe(
      map((snapshot) => {
        const searchTermLower = searchTerm.toLowerCase();
        return snapshot.docs
          .map((doc) => this.convertFirebaseVehicleToModel(doc.id, doc.data()))
          .filter((vehicle) => {
            return (
              vehicle.registration.toLowerCase().includes(searchTermLower) ||
              (vehicle.chassisNumber && vehicle.chassisNumber.toLowerCase().includes(searchTermLower)) ||
              vehicle.makeName.toLowerCase().includes(searchTermLower) ||
              vehicle.modelName.toLowerCase().includes(searchTermLower)
            );
          });
      }),
      catchError((error) => {
        console.error('Error searching vehicles:', error);
        return of([]);
      })
    );
  }

  /**
   * Refresh the vehicles list
   */
  private refreshVehiclesList(): void {
    // Only refresh if we have vehicles loaded already
    if (this.vehiclesSubject.getValue().length > 0) {
      this.getVehicles().subscribe();
    }
  }

  /**
   * Generate a unique ID
   */
  private generateId(): string {
    return Date.now().toString(36) + Math.random().toString(36).substring(2);
  }

  /**
   * Convert Firestore data to Vehicle model
   */
  private convertFirebaseVehicleToModel(id: string, data: any): Vehicle {
    const vehicle: Vehicle = {
      id, // Now always required
      registration: data.registration || '',
      chassisNumber: data.chassisNumber || '',
      makeId: data.makeId || '',
      makeName: data.makeName || '',
      modelId: data.modelId || '',
      modelName: data.modelName || '',
      type: data.type || '',
      color: data.color || '',
      year: data.year || 0,
      firstProcessedDate: this.convertTimestamp(data.firstProcessedDate) || new Date(),
      lastProcessedDate: this.convertTimestamp(data.lastProcessedDate) || new Date(),
      mileage: data.mileage || 0,
      jobCount: data.jobCount || 0,
      jobHistory: data.jobHistory || [],
    };

    // Add optional fields if present
    if (data.fuelType) vehicle.fuelType = data.fuelType;
    if (data.transmission) vehicle.transmission = data.transmission;
    if (data.engineSize) vehicle.engineSize = data.engineSize;
    if (data.vin) vehicle.vin = data.vin;
    if (data.notes) vehicle.notes = data.notes;

    // Convert photos array
    if (data.photos && Array.isArray(data.photos)) {
      vehicle.photos = data.photos.map((photo: any) => ({
        ...photo,
        takenAt: this.convertTimestamp(photo.takenAt) || new Date(),
      }));
    }

    // Convert condition reports array
    if (data.conditionReports && Array.isArray(data.conditionReports)) {
      vehicle.conditionReports = data.conditionReports.map((report: any) => ({
        ...report,
        createdAt: this.convertTimestamp(report.createdAt) || new Date(),
      }));
    }

    return vehicle;
  }

  /**
   * Get unique vehicle types
   */
  getVehicleTypes(): Observable<string[]> {
    // First try to get types from the vehicle models
    return this.getVehicleModels().pipe(
      map((models) => {
        const typesSet = new Set<string>();
        models.forEach((model) => {
          if (model.type) {
            typesSet.add(model.type);
          }
        });
        return Array.from(typesSet).sort();
      }),
      catchError(() => {
        // If that fails, return default types
        return of(['Car', 'Van', 'Motorbike', 'Truck', 'Bus', 'Trailer']);
      })
    );
  }
}


--- ./src/app/services/notification.service.ts ---
import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';
import { MatSnackBar } from '@angular/material/snack-bar';

export interface Notification {
  id: string;
  type: 'info' | 'success' | 'warning' | 'error';
  title: string;
  message: string;
  timestamp: Date;
  read: boolean;
  actionUrl?: string;
}

@Injectable({
  providedIn: 'root',
})
export class NotificationService {
  private notifications = new BehaviorSubject<Notification[]>([]);
  private unreadCount = new BehaviorSubject<number>(0);

  constructor(private snackBar: MatSnackBar) {
    // Load saved notifications from localStorage on init
    this.loadNotifications();
  }

  get notifications$(): Observable<Notification[]> {
    return this.notifications.asObservable();
  }

  get unreadCount$(): Observable<number> {
    return this.unreadCount.asObservable();
  }

  addNotification(
    notification: Omit<Notification, 'id' | 'timestamp' | 'read'>
  ): void {
    const newNotification: Notification = {
      ...notification,
      id: this.generateId(),
      timestamp: new Date(),
      read: false,
    };

    const currentNotifications = this.notifications.getValue();
    const updatedNotifications = [newNotification, ...currentNotifications];

    this.notifications.next(updatedNotifications);
    this.unreadCount.next(this.unreadCount.getValue() + 1);

    // Save to localStorage
    this.saveNotifications(updatedNotifications);

    // Show snackbar for real-time notification
    this.showSnackbar(notification);
  }

  markAsRead(notificationId: string): void {
    const currentNotifications = this.notifications.getValue();
    const updatedNotifications = currentNotifications.map((notification) => {
      if (notification.id === notificationId && !notification.read) {
        return { ...notification, read: true };
      }
      return notification;
    });

    this.notifications.next(updatedNotifications);

    // Update unread count
    const unreadCount = updatedNotifications.filter((n) => !n.read).length;
    this.unreadCount.next(unreadCount);

    // Save to localStorage
    this.saveNotifications(updatedNotifications);
  }

  markAllAsRead(): void {
    const currentNotifications = this.notifications.getValue();
    const updatedNotifications = currentNotifications.map((notification) => ({
      ...notification,
      read: true,
    }));

    this.notifications.next(updatedNotifications);
    this.unreadCount.next(0);

    // Save to localStorage
    this.saveNotifications(updatedNotifications);
  }

  removeNotification(notificationId: string): void {
    const currentNotifications = this.notifications.getValue();
    const updatedNotifications = currentNotifications.filter(
      (notification) => notification.id !== notificationId
    );

    this.notifications.next(updatedNotifications);

    // Update unread count
    const unreadCount = updatedNotifications.filter((n) => !n.read).length;
    this.unreadCount.next(unreadCount);

    // Save to localStorage
    this.saveNotifications(updatedNotifications);
  }

  private generateId(): string {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }

  private loadNotifications(): void {
    try {
      const savedNotifications = localStorage.getItem('notifications');
      if (savedNotifications) {
        const parsedNotifications: Notification[] =
          JSON.parse(savedNotifications);

        // Convert stored date strings back to Date objects
        const processedNotifications = parsedNotifications.map((n) => ({
          ...n,
          timestamp: new Date(n.timestamp),
        }));

        this.notifications.next(processedNotifications);

        // Calculate unread count
        const unreadCount = processedNotifications.filter(
          (n) => !n.read
        ).length;
        this.unreadCount.next(unreadCount);
      }
    } catch (error) {
      console.error('Error loading notifications:', error);
      // If there's an error, initialize with empty notifications
      this.notifications.next([]);
      this.unreadCount.next(0);
    }
  }

  private saveNotifications(notifications: Notification[]): void {
    try {
      localStorage.setItem('notifications', JSON.stringify(notifications));
    } catch (error) {
      console.error('Error saving notifications:', error);
    }
  }

  private showSnackbar(
    notification: Omit<Notification, 'id' | 'timestamp' | 'read'>
  ): void {
    const config = {
      duration: 5000,
      horizontalPosition: 'end' as const,
      verticalPosition: 'top' as const,
      panelClass: [`${notification.type}-snackbar`],
    };

    const actionText = notification.actionUrl ? 'View' : 'Dismiss';

    const snackBarRef = this.snackBar.open(
      notification.title,
      actionText,
      config
    );

    if (notification.actionUrl) {
      snackBarRef.onAction().subscribe(() => {
        window.location.href = notification.actionUrl!;
      });
    }
  }
}


--- ./src/app/services/app-state.service.ts ---
import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';
import { Router, NavigationEnd } from '@angular/router';
import { filter } from 'rxjs/operators';
import { AuthService } from './auth.service';

@Injectable({
  providedIn: 'root',
})
export class AppStateService {
  private isAuthPageSubject = new BehaviorSubject<boolean>(false);
  public isAuthPage$ = this.isAuthPageSubject.asObservable();

  constructor(private router: Router, private authService: AuthService) {
    // Monitor route changes to detect auth pages
    this.router.events
      .pipe(filter((event) => event instanceof NavigationEnd))
      .subscribe((event: any) => {
        const isAuthPage = event.url.includes('/auth');
        this.isAuthPageSubject.next(isAuthPage);
      });
  }

  /**
   * Check if current page is an auth page
   */
  public isAuthPage(): Observable<boolean> {
    return this.isAuthPage$;
  }

  /**
   * Returns true if the app has a sidebar (logged in + not auth page)
   */
  public hasSidebar(): Observable<boolean> {
    return new Observable<boolean>((observer) => {
      // We need to combine auth state and page state
      const authSub = this.authService.isAuthenticated().subscribe((isAuth) => {
        const pageSub = this.isAuthPage$.subscribe((isAuthPage) => {
          observer.next(isAuth && !isAuthPage);

          // Clean up inner subscription
          return () => pageSub.unsubscribe();
        });
      });

      // Clean up outer subscription
      return () => authSub.unsubscribe();
    });
  }
}


--- ./src/app/services/base-firebase.service.ts ---
// src/app/services/base-firebase.service.ts
import { Injectable, inject } from '@angular/core';
import { Auth, User } from '@angular/fire/auth';
import { Firestore } from '@angular/fire/firestore';
import { BehaviorSubject, Observable } from 'rxjs';

@Injectable({
  providedIn: 'root',
})
export class BaseFirebaseService {
  // Use inject() function for proper injection context
  protected firestore = inject(Firestore);
  protected auth = inject(Auth);

  private currentUserSubject = new BehaviorSubject<User | null>(null);
  public currentUser$ = this.currentUserSubject.asObservable();

  constructor() {
    // Listen to auth state changes
    this.auth.onAuthStateChanged((user) => {
      this.currentUserSubject.next(user);
    });
  }

  /**
   * Get current user
   */
  get currentUserValue(): User | null {
    return this.currentUserSubject.value;
  }

  /**
   * Get current user ID
   */
  get currentUserId(): string | null {
    return this.currentUserValue?.uid || null;
  }

  /**
   * Convert Firebase timestamp to Date
   */
  protected convertTimestamp(timestamp: any): Date | undefined {
    if (!timestamp) return undefined;

    // Firebase timestamp object with toDate() method
    if (timestamp && typeof timestamp === 'object' && 'toDate' in timestamp) {
      return timestamp.toDate();
    }

    // String or number timestamp
    if (timestamp) {
      return new Date(timestamp);
    }

    return undefined;
  }

  /**
   * Format date for Firestore
   */
  protected formatDateForFirestore(date: Date): Date {
    return date;
  }

  /**
   * Handle errors consistently
   */
  protected handleError<T>(operation = 'operation', result?: T) {
    return (error: any): Observable<T> => {
      console.error(`${operation} failed:`, error);

      // Let the app keep running by returning an empty result
      return new Observable<T>((observer) => {
        if (result !== undefined) {
          observer.next(result as T);
        }
        observer.complete();
      });
    };
  }
}

// Alternative implementation using direct injection in constructor
@Injectable({
  providedIn: 'root',
})
export class AlternativeBaseFirebaseService {
  private currentUserSubject = new BehaviorSubject<User | null>(null);
  public currentUser$ = this.currentUserSubject.asObservable();

  constructor(protected firestore: Firestore, protected auth: Auth) {
    // Listen to auth state changes
    this.auth.onAuthStateChanged((user) => {
      this.currentUserSubject.next(user);
    });
  }

  get currentUserValue(): User | null {
    return this.currentUserSubject.value;
  }

  get currentUserId(): string | null {
    return this.currentUserValue?.uid || null;
  }

  protected convertTimestamp(timestamp: any): Date | undefined {
    if (!timestamp) return undefined;

    if (timestamp && typeof timestamp === 'object' && 'toDate' in timestamp) {
      return timestamp.toDate();
    }

    if (timestamp) {
      return new Date(timestamp);
    }

    return undefined;
  }

  protected formatDateForFirestore(date: Date): Date {
    return date;
  }

  protected handleError<T>(operation = 'operation', result?: T) {
    return (error: any): Observable<T> => {
      console.error(`${operation} failed:`, error);

      return new Observable<T>((observer) => {
        if (result !== undefined) {
          observer.next(result as T);
        }
        observer.complete();
      });
    };
  }
}


--- ./src/app/services/customer.service.ts ---
import { Injectable } from '@angular/core';
import { Auth } from '@angular/fire/auth';
import { Firestore, addDoc, collection, doc, getDoc, getDocs, orderBy, query, serverTimestamp, updateDoc, where } from '@angular/fire/firestore';
import { BehaviorSubject, Observable, from, of, throwError } from 'rxjs';
import { catchError, map, tap } from 'rxjs/operators';
import { Customer, CustomerContact, CustomerStatus } from '../interfaces/customer.interface';
import { BaseFirebaseService } from './base-firebase.service';
import { NotificationService } from './notification.service';

@Injectable({
  providedIn: 'root',
})
export class CustomerService extends BaseFirebaseService {
  private customersSubject = new BehaviorSubject<Customer[]>([]);
  private loadingSubject = new BehaviorSubject<boolean>(false);

  public customers$ = this.customersSubject.asObservable();
  public loading$ = this.loadingSubject.asObservable();

  constructor(protected override firestore: Firestore, protected override auth: Auth, private notificationService: NotificationService) {
    super();
  }

  /**
   * Get all customers
   */
  getCustomers(): Observable<Customer[]> {
    this.loadingSubject.next(true);

    const customersRef = collection(this.firestore, 'customers');
    const q = query(customersRef, where('isActive', '==', true), orderBy('name', 'asc'));

    return from(getDocs(q)).pipe(
      map((snapshot) => {
        const customers = snapshot.docs.map((doc) => {
          return this.convertFirebaseCustomerToModel(doc.id, doc.data());
        });
        this.customersSubject.next(customers);
        return customers;
      }),
      tap(() => this.loadingSubject.next(false)),
      catchError((error) => {
        console.error('Error fetching customers:', error);
        this.loadingSubject.next(false);
        this.customersSubject.next([]);
        return of([]);
      })
    );
  }

  /**
   * Get customers by status
   */
  getCustomersByStatus(status: CustomerStatus): Observable<Customer[]> {
    this.loadingSubject.next(true);

    const customersRef = collection(this.firestore, 'customers');
    const q = query(customersRef, where('status', '==', status), where('isActive', '==', true), orderBy('name', 'asc'));

    return from(getDocs(q)).pipe(
      map((snapshot) => {
        const customers = snapshot.docs.map((doc) => {
          return this.convertFirebaseCustomerToModel(doc.id, doc.data());
        });
        return customers;
      }),
      tap(() => this.loadingSubject.next(false)),
      catchError((error) => {
        console.error(`Error fetching customers with status ${status}:`, error);
        this.loadingSubject.next(false);
        return of([]);
      })
    );
  }

  /**
   * Get customers by category
   */
  getCustomersByCategory(category: string): Observable<Customer[]> {
    this.loadingSubject.next(true);

    const customersRef = collection(this.firestore, 'customers');
    const q = query(customersRef, where('category', '==', category), where('isActive', '==', true), orderBy('name', 'asc'));

    return from(getDocs(q)).pipe(
      map((snapshot) => {
        const customers = snapshot.docs.map((doc) => {
          return this.convertFirebaseCustomerToModel(doc.id, doc.data());
        });
        return customers;
      }),
      tap(() => this.loadingSubject.next(false)),
      catchError((error) => {
        console.error(`Error fetching customers with category ${category}:`, error);
        this.loadingSubject.next(false);
        return of([]);
      })
    );
  }

  /**
   * Get a customer by ID
   */
  getCustomerById(id: string): Observable<Customer | null> {
    this.loadingSubject.next(true);

    if (!id) {
      this.loadingSubject.next(false);
      return of(null);
    }

    const customerRef = doc(this.firestore, `customers/${id}`);

    return from(getDoc(customerRef)).pipe(
      map((docSnap) => {
        if (docSnap.exists()) {
          return this.convertFirebaseCustomerToModel(docSnap.id, docSnap.data());
        } else {
          return null;
        }
      }),
      tap(() => this.loadingSubject.next(false)),
      catchError((error) => {
        console.error(`Error fetching customer ${id}:`, error);
        this.loadingSubject.next(false);
        return of(null);
      })
    );
  }

  /**
   * Create a new customer
   */
  createCustomer(data: Partial<Customer>): Observable<string> {
    this.loadingSubject.next(true);

    // Get the current user ID
    const userId = this.currentUserId;
    if (!userId) {
      this.loadingSubject.next(false);
      return throwError(() => new Error('User not authenticated'));
    }

    // Ensure contacts have IDs
    const contacts =
      data.contacts?.map((contact) => {
        if (!contact.id) {
          return { ...contact, id: this.generateId() };
        }
        return contact;
      }) || [];

    // Prepare customer data
    const customerData = {
      ...data,
      contacts: contacts,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
      createdBy: userId,
      updatedBy: userId,
      status: data.status || CustomerStatus.ACTIVE,
      isActive: true,
    };

    const customersRef = collection(this.firestore, 'customers');

    return from(addDoc(customersRef, customerData)).pipe(
      map((docRef) => {
        // Refresh the customers list
        this.refreshCustomersList();

        // Add notification
        this.notificationService.addNotification({
          type: 'success',
          title: 'Customer Created',
          message: `Customer "${data.name}" has been created successfully`,
          actionUrl: `/customers/${docRef.id}`,
        });

        return docRef.id;
      }),
      tap(() => this.loadingSubject.next(false)),
      catchError((error) => {
        console.error('Error creating customer:', error);
        this.loadingSubject.next(false);
        return throwError(() => error);
      })
    );
  }

  /**
   * Update an existing customer
   */
  updateCustomer(id: string, data: Partial<Customer>): Observable<void> {
    this.loadingSubject.next(true);

    // Get the current user ID
    const userId = this.currentUserId;
    if (!userId) {
      this.loadingSubject.next(false);
      return throwError(() => new Error('User not authenticated'));
    }

    const customerRef = doc(this.firestore, `customers/${id}`);

    // Process contacts array
    let contacts = data.contacts || [];

    // Make sure all contacts have IDs
    contacts = contacts.map((contact) => {
      if (!contact.id) {
        return { ...contact, id: this.generateId() };
      }
      return contact;
    });

    // Remove id from update data to avoid overwriting it
    const { id: _, ...updateData } = data;

    // Add updater and timestamp
    const customerData = {
      ...updateData,
      contacts: contacts,
      updatedAt: serverTimestamp(),
      updatedBy: userId,
    };

    return from(updateDoc(customerRef, customerData)).pipe(
      tap(() => {
        // Refresh the customers list
        this.refreshCustomersList();

        // Add notification about customer update
        this.notificationService.addNotification({
          type: 'info',
          title: 'Customer Updated',
          message: `Customer "${data.name}" has been updated`,
          actionUrl: `/customers/${id}`,
        });
      }),
      map(() => void 0),
      tap(() => this.loadingSubject.next(false)),
      catchError((error) => {
        console.error(`Error updating customer ${id}:`, error);
        this.loadingSubject.next(false);
        return throwError(() => error);
      })
    );
  }

  /**
   * Soft delete a customer (mark as inactive)
   */
  deleteCustomer(id: string): Observable<void> {
    this.loadingSubject.next(true);

    const customerRef = doc(this.firestore, `customers/${id}`);

    // We'll do a soft delete by setting isActive to false
    const updateData = {
      isActive: false,
      updatedAt: serverTimestamp(),
      updatedBy: this.currentUserId,
    };

    return from(updateDoc(customerRef, updateData)).pipe(
      tap(() => {
        // Refresh the customers list
        this.refreshCustomersList();

        // Add notification
        this.notificationService.addNotification({
          type: 'warning',
          title: 'Customer Deleted',
          message: 'The customer has been deleted',
          actionUrl: '/customers',
        });
      }),
      map(() => void 0),
      tap(() => this.loadingSubject.next(false)),
      catchError((error) => {
        console.error(`Error deleting customer ${id}:`, error);
        this.loadingSubject.next(false);
        return throwError(() => error);
      })
    );
  }

  /**
   * Get unique list of categories from all customers
   */
  getCategories(): Observable<string[]> {
    const customersRef = collection(this.firestore, 'customers');
    const q = query(customersRef, where('isActive', '==', true));

    return from(getDocs(q)).pipe(
      map((snapshot) => {
        const categoriesSet = new Set<string>();

        snapshot.docs.forEach((doc) => {
          const category = doc.data()['category'];
          if (category) {
            categoriesSet.add(category);
          }
        });

        return Array.from(categoriesSet).sort();
      }),
      catchError((error) => {
        console.error('Error fetching categories:', error);
        return of([]);
      })
    );
  }

  /**
   * Search customers by name or contact name
   */
  searchCustomers(searchTerm: string): Observable<Customer[]> {
    if (!searchTerm || searchTerm.trim().length < 2) {
      return of([]);
    }

    // Firebase doesn't support native text search, so we'll fetch all customers
    // and filter them client-side
    return this.getCustomers().pipe(
      map((customers) => {
        const normalizedSearchTerm = searchTerm.toLowerCase().trim();

        return customers.filter(
          (customer) => customer.name.toLowerCase().includes(normalizedSearchTerm) || this.contactsIncludeSearchTerm(customer.contacts, normalizedSearchTerm)
        );
      })
    );
  }

  /**
   * Check if any contact information matches the search term
   */
  private contactsIncludeSearchTerm(contacts: CustomerContact[], searchTerm: string): boolean {
    if (!contacts || contacts.length === 0) return false;

    return contacts.some(
      (contact) =>
        (contact.name && contact.name.toLowerCase().includes(searchTerm)) ||
        (contact.email && contact.email.toLowerCase().includes(searchTerm)) ||
        (contact.phone && contact.phone.toLowerCase().includes(searchTerm)) ||
        (contact.position && contact.position.toLowerCase().includes(searchTerm))
    );
  }

  /**
   * Refresh the customers list
   */
  private refreshCustomersList(): void {
    // Only refresh if we have customers loaded already
    if (this.customersSubject.getValue().length > 0) {
      this.getCustomers().subscribe();
    }
  }

  /**
   * Generate a random ID for customer contacts
   */
  private generateId(): string {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }

  /**
   * Convert Firestore document to Customer model
   */
  private convertFirebaseCustomerToModel(id: string, data: any): Customer {
    // Process contacts array
    const contacts: CustomerContact[] = [];

    if (data.contacts && Array.isArray(data.contacts)) {
      data.contacts.forEach((contact: any) => {
        contacts.push({
          id: contact.id || this.generateId(),
          name: contact.name || '',
          position: contact.position,
          email: contact.email || '',
          phone: contact.phone,
          isPrimary: contact.isPrimary || false,
        });
      });
    }

    // Ensure at least one contact exists
    if (contacts.length === 0) {
      contacts.push({
        id: this.generateId(),
        name: '',
        email: '',
        isPrimary: true,
      });
    }

    return {
      id,
      name: data.name || '',
      phone: data.phone || '',
      industry: data.industry,
      category: data.category,
      size: data.size,
      status: data.status || CustomerStatus.ACTIVE,
      address: data.address,
      city: data.city,
      postcode: data.postcode,
      country: data.country,
      website: data.website,
      description: data.description,
      contacts: contacts,
      createdAt: this.convertTimestamp(data.createdAt) || new Date(),
      updatedAt: this.convertTimestamp(data.updatedAt) || new Date(),
      createdBy: data.createdBy,
      updatedBy: data.updatedBy,
      lastContact: this.convertTimestamp(data.lastContact),
      notes: data.notes,
      isActive: data.isActive !== false,
    };
  }
}


--- ./src/app/services/job.service.ts ---
import { Injectable, OnDestroy, inject } from '@angular/core';
import { Auth } from '@angular/fire/auth';
import {
  DocumentData,
  Firestore,
  QueryDocumentSnapshot,
  Unsubscribe,
  addDoc,
  collection,
  deleteDoc,
  doc,
  getDoc,
  getDocs,
  limit,
  onSnapshot,
  orderBy,
  query,
  serverTimestamp,
  startAfter,
  updateDoc,
  where,
  writeBatch,
} from '@angular/fire/firestore';
import { BehaviorSubject, Observable, combineLatest, forkJoin, from, of, throwError } from 'rxjs';
import { catchError, map, switchMap, tap } from 'rxjs/operators';

import { Job } from '../interfaces/job.interface';
import { UserPermissionKey } from '../interfaces/user-profile.interface';
import { AuthService } from './auth.service';
import { NotificationService } from './notification.service';

@Injectable({
  providedIn: 'root',
})
export class JobService implements OnDestroy {
  // Use inject() for proper injection context
  private firestore = inject(Firestore);
  private auth = inject(Auth);
  private authService = inject(AuthService);
  private notificationService = inject(NotificationService);

  private jobsSubject = new BehaviorSubject<Job[]>([]);
  public jobs$ = this.jobsSubject.asObservable();

  private loadingSubject = new BehaviorSubject<boolean>(false);
  public loading$ = this.loadingSubject.asObservable();

  private activeListeners: Unsubscribe[] = [];
  private lastVisibleDoc: QueryDocumentSnapshot<DocumentData> | null = null;

  // Current user observable
  private currentUserSubject = new BehaviorSubject<any>(null);
  public currentUser$ = this.currentUserSubject.asObservable();

  constructor() {
    // Listen to auth state changes
    this.auth.onAuthStateChanged((user) => {
      this.currentUserSubject.next(user);
    });

    this.initJobListener();
  }

  /**
   * Get current user ID
   */
  get currentUserId(): string | null {
    return this.auth.currentUser?.uid || null;
  }

  ngOnDestroy(): void {
    this.cleanupListeners();
  }

  public cleanupListeners(): void {
    this.activeListeners.forEach((unsub) => unsub());
    this.activeListeners = [];
  }

  private initJobListener(): void {
    this.cleanupListeners();

    const authSubscription = this.currentUser$.subscribe((user) => {
      if (!user) {
        this.jobsSubject.next([]);
        return;
      }

      this.loadingSubject.next(true);

      this.authService.getUserProfile().subscribe({
        next: (profile) => {
          const canViewAll = profile?.permissions?.isAdmin || false;
          const canViewUnallocated = profile?.permissions?.canViewUnallocated || false;

          this.cleanupListeners();

          if (canViewAll) {
            this.listenToAllJobs();
          } else if (canViewUnallocated) {
            this.listenToDriverAndUnallocatedJobs(user.uid);
          } else {
            this.listenToDriverJobs(user.uid);
          }
        },
        error: (error) => {
          console.error('Error fetching user profile for job listener:', error);
          this.loadingSubject.next(false);
        },
      });
    });

    this.activeListeners.push(() => authSubscription.unsubscribe());
  }

  private listenToAllJobs(): void {
    const jobsRef = collection(this.firestore, 'jobs');
    const q = query(jobsRef, orderBy('updatedAt', 'desc'), limit(100));

    const unsubscribe = onSnapshot(
      q,
      (snapshot) => {
        const jobs = snapshot.docs.map((doc) => this.convertFirebaseJobToModel(doc.id, doc.data()));

        this.lastVisibleDoc = snapshot.docs[snapshot.docs.length - 1] || null;
        this.jobsSubject.next(jobs);
        this.loadingSubject.next(false);
      },
      (error) => {
        console.error('Error listening to all jobs:', error);
        this.loadingSubject.next(false);
      }
    );

    this.activeListeners.push(unsubscribe);
  }

  private listenToDriverJobs(driverId: string): void {
    const jobsRef = collection(this.firestore, 'jobs');
    const q = query(jobsRef, where('driverId', '==', driverId), orderBy('updatedAt', 'desc'), limit(50));

    const unsubscribe = onSnapshot(
      q,
      (snapshot) => {
        const jobs = snapshot.docs.map((doc) => this.convertFirebaseJobToModel(doc.id, doc.data()));

        this.jobsSubject.next(jobs);
        this.loadingSubject.next(false);
      },
      (error) => {
        console.error('Error listening to driver jobs:', error);
        this.loadingSubject.next(false);
      }
    );

    this.activeListeners.push(unsubscribe);
  }

  private listenToDriverAndUnallocatedJobs(driverId: string): void {
    const jobsRef = collection(this.firestore, 'jobs');

    // Query for driver's jobs
    const driverJobsQuery = query(jobsRef, where('driverId', '==', driverId), orderBy('updatedAt', 'desc'), limit(25));

    // Query for unallocated jobs
    const unallocatedJobsQuery = query(jobsRef, where('status', '==', 'unallocated'), orderBy('updatedAt', 'desc'), limit(25));

    const driverJobsUnsubscribe = onSnapshot(driverJobsQuery, (snapshot) => {
      const driverJobs = snapshot.docs.map((doc) => this.convertFirebaseJobToModel(doc.id, doc.data()));
      this.updateCombinedJobs(driverJobs, 'driver');
    });

    const unallocatedJobsUnsubscribe = onSnapshot(unallocatedJobsQuery, (snapshot) => {
      const unallocatedJobs = snapshot.docs.map((doc) => this.convertFirebaseJobToModel(doc.id, doc.data()));
      this.updateCombinedJobs(unallocatedJobs, 'unallocated');
    });

    this.activeListeners.push(driverJobsUnsubscribe, unallocatedJobsUnsubscribe);
  }

  private combinedJobs: { driver: Job[]; unallocated: Job[] } = { driver: [], unallocated: [] };

  private updateCombinedJobs(jobs: Job[], type: 'driver' | 'unallocated'): void {
    this.combinedJobs[type] = jobs;

    // Combine and deduplicate jobs
    const allJobs = [...this.combinedJobs.driver, ...this.combinedJobs.unallocated];
    const uniqueJobs = allJobs.filter((job, index, self) => index === self.findIndex((j) => j.id === job.id));

    // Sort by updated date
    uniqueJobs.sort((a, b) => {
      const dateA = new Date(a.updatedAt || a.createdAt).getTime();
      const dateB = new Date(b.updatedAt || b.createdAt).getTime();
      return dateB - dateA;
    });

    this.jobsSubject.next(uniqueJobs);
    this.loadingSubject.next(false);
  }

  /**
   * Get recent jobs with pagination
   */
  getRecentJobs(limitCount: number = 25): Observable<Job[]> {
    this.loadingSubject.next(true);

    const jobsRef = collection(this.firestore, 'jobs');
    const q = query(jobsRef, orderBy('updatedAt', 'desc'), limit(limitCount));

    return from(getDocs(q)).pipe(
      map((snapshot) => {
        this.lastVisibleDoc = snapshot.docs[snapshot.docs.length - 1] || null;
        console.log(this.lastVisibleDoc);
        return snapshot.docs.map((doc) => this.convertFirebaseJobToModel(doc.id, doc.data()));
      }),
      tap(() => this.loadingSubject.next(false)),
      catchError((error) => {
        console.error('Error fetching recent jobs:', error);
        this.loadingSubject.next(false);
        return of([]);
      })
    );
  }

  /**
   * Get jobs by status
   */
  getJobsByStatus(status: string): Observable<Job[]> {
    const jobsRef = collection(this.firestore, 'jobs');
    const q = query(jobsRef, where('status', '==', status), orderBy('updatedAt', 'desc'), limit(100));

    return from(getDocs(q)).pipe(
      map((snapshot) => snapshot.docs.map((doc) => this.convertFirebaseJobToModel(doc.id, doc.data()))),
      catchError((error) => {
        console.error(`Error fetching jobs with status ${status}:`, error);
        return of([]);
      })
    );
  }

  /**
   * Get jobs by driver ID
   */
  getJobsByDriver(driverId: string): Observable<Job[]> {
    const jobsRef = collection(this.firestore, 'jobs');
    const q = query(jobsRef, where('driverId', '==', driverId), orderBy('updatedAt', 'desc'), limit(50));

    return from(getDocs(q)).pipe(
      map((snapshot) => snapshot.docs.map((doc) => this.convertFirebaseJobToModel(doc.id, doc.data()))),
      catchError((error) => {
        console.error(`Error fetching jobs for driver ${driverId}:`, error);
        return of([]);
      })
    );
  }

  /**
   * Get jobs by vehicle ID
   */
  getJobsByVehicle(vehicleId: string): Observable<Job[]> {
    const jobsRef = collection(this.firestore, 'jobs');
    const q = query(jobsRef, where('vehicleId', '==', vehicleId), orderBy('updatedAt', 'desc'), limit(50));

    return from(getDocs(q)).pipe(
      map((snapshot) => snapshot.docs.map((doc) => this.convertFirebaseJobToModel(doc.id, doc.data()))),
      catchError((error) => {
        console.error(`Error fetching jobs for vehicle ${vehicleId}:`, error);
        return of([]);
      })
    );
  }

  /**
   * Get jobs by customer ID or customer name
   */
  getJobsByCustomer(customerId?: string, customerName?: string): Observable<Job[]> {
    const jobsRef = collection(this.firestore, 'jobs');

    let q;
    if (customerId) {
      q = query(jobsRef, where('customerId', '==', customerId), orderBy('updatedAt', 'desc'), limit(50));
    } else if (customerName) {
      q = query(jobsRef, where('customerName', '==', customerName), orderBy('updatedAt', 'desc'), limit(50));
    } else {
      return of([]);
    }

    return from(getDocs(q)).pipe(
      map((snapshot) => snapshot.docs.map((doc) => this.convertFirebaseJobToModel(doc.id, doc.data()))),
      catchError((error) => {
        console.error(`Error fetching jobs for customer:`, error);
        return of([]);
      })
    );
  }

  /**
   * Get customer jobs (alias for getJobsByCustomer)
   */
  getCustomerJobs(customerId: string): Observable<Job[]> {
    return this.getJobsByCustomer(customerId);
  }

  /**
   * Get driver jobs (current user's jobs or all driver jobs for admin)
   */
  getDriverJobs(driverId?: string): Observable<Job[]> {
    const targetDriverId = driverId || this.currentUserId;

    if (!targetDriverId) {
      return of([]);
    }

    return this.getJobsByDriver(targetDriverId);
  }

  /**
   * Get jobs by date range
   */
  getJobsByDateRange(startDate: Date, endDate: Date, status?: string): Observable<Job[]> {
    const jobsRef = collection(this.firestore, 'jobs');

    let q;
    if (status) {
      q = query(
        jobsRef,
        where('status', '==', status),
        where('collectionDate', '>=', startDate),
        where('collectionDate', '<=', endDate),
        orderBy('collectionDate', 'asc'),
        limit(100)
      );
    } else {
      q = query(jobsRef, where('collectionDate', '>=', startDate), where('collectionDate', '<=', endDate), orderBy('collectionDate', 'asc'), limit(100));
    }

    return from(getDocs(q)).pipe(
      map((snapshot) => snapshot.docs.map((doc) => this.convertFirebaseJobToModel(doc.id, doc.data()))),
      catchError((error) => {
        console.error(`Error fetching jobs by date range:`, error);
        return of([]);
      })
    );
  }

  /**
   * Get jobs by multiple statuses
   */
  getJobsByStatuses(statuses: string[]): Observable<Job[]> {
    if (statuses.length === 0) {
      return of([]);
    }

    const jobsRef = collection(this.firestore, 'jobs');
    const q = query(jobsRef, where('status', 'in', statuses), orderBy('updatedAt', 'desc'), limit(100));

    return from(getDocs(q)).pipe(
      map((snapshot) => snapshot.docs.map((doc) => this.convertFirebaseJobToModel(doc.id, doc.data()))),
      catchError((error) => {
        console.error(`Error fetching jobs by statuses:`, error);
        return of([]);
      })
    );
  }

  /**
   * Search jobs by text (registration, customer name, etc.)
   */
  searchJobs(searchTerm: string, limit: number = 25): Observable<Job[]> {
    if (!searchTerm.trim()) {
      return this.getRecentJobs(limit);
    }

    const jobsRef = collection(this.firestore, 'jobs');

    // Since Firestore doesn't support full-text search, we'll get recent jobs
    // and filter them client-side. For production, consider using Algolia or similar.
    return this.getRecentJobs(100).pipe(
      map((jobs) => {
        const searchLower = searchTerm.toLowerCase();
        return jobs
          .filter(
            (job) =>
              job.id.toLowerCase().includes(searchLower) ||
              job['regNumber']?.toLowerCase().includes(searchLower) ||
              job.customerName?.toLowerCase().includes(searchLower) ||
              job.make?.toLowerCase().includes(searchLower) ||
              job.model?.toLowerCase().includes(searchLower) ||
              job['collectionTown']?.toLowerCase().includes(searchLower) ||
              job['deliveryTown']?.toLowerCase().includes(searchLower)
          )
          .slice(0, limit);
      })
    );
  }

  /**
   * Get active jobs (non-completed statuses)
   */
  getActiveJobs(): Observable<Job[]> {
    const activeStatuses = ['unallocated', 'allocated', 'collected', 'in-transit'];
    return this.getJobsByStatuses(activeStatuses);
  }

  /**
   * Get completed jobs
   */
  getCompletedJobs(): Observable<Job[]> {
    const completedStatuses = ['delivered', 'completed'];
    return this.getJobsByStatuses(completedStatuses);
  }

  /**
   * Get jobs requiring attention (overdue, high priority, etc.)
   */
  getJobsRequiringAttention(): Observable<Job[]> {
    const jobsRef = collection(this.firestore, 'jobs');
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Get jobs that are overdue or high priority
    const overdueQuery = query(
      jobsRef,
      where('collectionDate', '<', today),
      where('status', 'in', ['unallocated', 'allocated']),
      orderBy('collectionDate', 'asc'),
      limit(50)
    );

    const highPriorityQuery = query(
      jobsRef,
      where('priority', '==', 'urgent'),
      where('status', 'in', ['unallocated', 'allocated', 'collected']),
      orderBy('updatedAt', 'desc'),
      limit(25)
    );

    return combineLatest([
      from(getDocs(overdueQuery)).pipe(
        map((snapshot) => snapshot.docs.map((doc) => this.convertFirebaseJobToModel(doc.id, doc.data()))),
        catchError(() => of([]))
      ),
      from(getDocs(highPriorityQuery)).pipe(
        map((snapshot) => snapshot.docs.map((doc) => this.convertFirebaseJobToModel(doc.id, doc.data()))),
        catchError(() => of([]))
      ),
    ]).pipe(
      map(([overdueJobs, highPriorityJobs]) => {
        // Combine and deduplicate
        const allJobs = [...overdueJobs, ...highPriorityJobs];
        const uniqueJobs = allJobs.filter((job, index, self) => index === self.findIndex((j) => j.id === job.id));

        // Sort by priority and date
        return uniqueJobs.sort((a, b) => {
          if (a['priority'] === 'urgent' && b['priority'] !== 'urgent') return -1;
          if (b['priority'] === 'urgent' && a['priority'] !== 'urgent') return 1;

          const dateA = new Date(a['collectionDate'] || a.createdAt).getTime();
          const dateB = new Date(b['collectionDate'] || b.createdAt).getTime();
          return dateA - dateB;
        });
      })
    );
  }

  /**
   * Get job statistics for a specific period
   */
  getJobStatisticsForPeriod(startDate: Date, endDate: Date): Observable<any> {
    const jobsRef = collection(this.firestore, 'jobs');
    const q = query(jobsRef, where('createdAt', '>=', startDate), where('createdAt', '<=', endDate), orderBy('createdAt', 'desc'));

    return from(getDocs(q)).pipe(
      map((snapshot) => {
        const jobs = snapshot.docs.map((doc) => this.convertFirebaseJobToModel(doc.id, doc.data()));

        // Calculate statistics
        const stats = {
          total: jobs.length,
          byStatus: {} as Record<string, number>,
          byPriority: {} as Record<string, number>,
          averageDuration: 0,
          completionRate: 0,
          onTimeDeliveries: 0,
        };

        jobs.forEach((job) => {
          // Count by status
          stats.byStatus[job.status] = (stats.byStatus[job.status] || 0) + 1;

          // Count by priority
          const priority = job['priority'] || 'normal';
          stats.byPriority[priority] = (stats.byPriority[priority] || 0) + 1;
        });

        // Calculate completion rate
        const completedJobs = jobs.filter((job) => ['delivered', 'completed'].includes(job.status));
        stats.completionRate = jobs.length > 0 ? (completedJobs.length / jobs.length) * 100 : 0;

        // Calculate on-time deliveries
        const onTimeJobs = completedJobs.filter((job) => {
          if (!job['deliveryDate'] || !job.deliveryCompleteTime) return false;

          const scheduledDate = new Date(job['deliveryDate']);
          const actualDate = new Date(job.deliveryCompleteTime);

          // Consider on-time if delivered on or before scheduled date
          return actualDate <= scheduledDate;
        });
        stats.onTimeDeliveries = completedJobs.length > 0 ? (onTimeJobs.length / completedJobs.length) * 100 : 0;

        // Calculate average duration for completed jobs
        const durationsInHours = completedJobs.filter((job) => job['actualDuration']).map((job) => job['actualDuration']!);

        stats.averageDuration = durationsInHours.length > 0 ? durationsInHours.reduce((sum, duration) => sum + duration, 0) / durationsInHours.length : 0;

        return stats;
      }),
      catchError((error) => {
        console.error('Error fetching job statistics:', error);
        return of({
          total: 0,
          byStatus: {},
          byPriority: {},
          averageDuration: 0,
          completionRate: 0,
          onTimeDeliveries: 0,
        });
      })
    );
  }
  getDashboardStats(): Observable<any> {
    this.loadingSubject.next(true);

    const jobsRef = collection(this.firestore, 'jobs');

    // Create queries for each status
    const unallocatedQuery = query(jobsRef, where('status', '==', 'unallocated'));
    const allocatedQuery = query(jobsRef, where('status', '==', 'allocated'));
    const collectedQuery = query(jobsRef, where('status', '==', 'collected'));
    const deliveredQuery = query(jobsRef, where('status', '==', 'delivered'));
    const completedQuery = query(jobsRef, where('status', '==', 'completed'));

    return combineLatest([
      from(getDocs(unallocatedQuery)).pipe(map((snap) => snap.size)),
      from(getDocs(allocatedQuery)).pipe(map((snap) => snap.size)),
      from(getDocs(collectedQuery)).pipe(map((snap) => snap.size)),
      from(getDocs(deliveredQuery)).pipe(map((snap) => snap.size)),
      from(getDocs(completedQuery)).pipe(map((snap) => snap.size)),
    ]).pipe(
      map(([unallocated, allocated, collected, delivered, completed]) => {
        const total = unallocated + allocated + collected + delivered + completed;
        const active = unallocated + allocated + collected;

        return {
          unallocated,
          allocated,
          collected,
          delivered,
          completed,
          total,
          active,
        };
      }),
      tap(() => this.loadingSubject.next(false)),
      catchError((error) => {
        console.error('Error fetching dashboard stats:', error);
        this.loadingSubject.next(false);
        return of({
          unallocated: 0,
          allocated: 0,
          collected: 0,
          delivered: 0,
          completed: 0,
          total: 0,
          active: 0,
        });
      })
    );
  }

  /**
   * Get job by ID
   */
  getJobById(jobId: string): Observable<Job | null> {
    const jobRef = doc(this.firestore, `jobs/${jobId}`);

    return from(getDoc(jobRef)).pipe(
      map((docSnap) => {
        if (docSnap.exists()) {
          return this.convertFirebaseJobToModel(docSnap.id, docSnap.data());
        }
        return null;
      }),
      catchError((error) => {
        console.error(`Error fetching job ${jobId}:`, error);
        return of(null);
      })
    );
  }

  /**
   * Create a new job
   */
  createJob(jobData: Partial<Job>): Observable<string> {
    if (!this.currentUserId) {
      return throwError(() => new Error('User not authenticated'));
    }

    const jobsRef = collection(this.firestore, 'jobs');

    const newJobData = {
      ...jobData,
      status: jobData.status || 'unallocated',
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
      createdBy: this.currentUserId,
      updatedBy: this.currentUserId,
    };

    return from(addDoc(jobsRef, newJobData)).pipe(
      map((docRef) => docRef.id),
      tap((jobId) => {
        this.notificationService.addNotification({
          type: 'success',
          title: 'Job Created',
          message: `Job ${jobId} has been created successfully.`,
          actionUrl: `/jobs/${jobId}`,
        });
      }),
      catchError((error) => {
        console.error('Error creating job:', error);
        return throwError(() => new Error(`Failed to create job: ${error.message}`));
      })
    );
  }

  /**
   * Update job
   */
  updateJob(jobId: string, updateData: Partial<Job>): Observable<void> {
    if (!this.currentUserId) {
      return throwError(() => new Error('User not authenticated'));
    }

    const jobRef = doc(this.firestore, `jobs/${jobId}`);

    const updatedData = {
      ...updateData,
      updatedAt: serverTimestamp(),
      updatedBy: this.currentUserId,
    };

    return from(updateDoc(jobRef, updatedData)).pipe(
      tap(() => {
        this.notificationService.addNotification({
          type: 'success',
          title: 'Job Updated',
          message: `Job ${jobId} has been updated successfully.`,
        });
      }),
      catchError((error) => {
        console.error(`Error updating job ${jobId}:`, error);
        return throwError(() => new Error(`Failed to update job: ${error.message}`));
      })
    );
  }

  /**
   * Delete job
   */
  deleteJob(jobId: string): Observable<void> {
    if (!this.currentUserId) {
      return throwError(() => new Error('User not authenticated'));
    }

    return this.authService.hasPermission('canDeleteJobs' as UserPermissionKey).pipe(
      switchMap((hasPermission) => {
        if (!hasPermission) {
          return throwError(() => new Error('You do not have permission to delete jobs'));
        }

        const jobRef = doc(this.firestore, `jobs/${jobId}`);
        return from(deleteDoc(jobRef));
      }),
      tap(() => {
        this.notificationService.addNotification({
          type: 'success',
          title: 'Job Deleted',
          message: `Job ${jobId} has been deleted successfully.`,
        });
      }),
      catchError((error) => {
        console.error(`Error deleting job ${jobId}:`, error);
        return throwError(() => new Error(`Failed to delete job: ${error.message}`));
      })
    );
  }

  /**
   * Allocate job to driver
   */
  allocateJobToDriver(jobId: string, driverId: string): Observable<void> {
    if (!this.currentUserId) {
      return throwError(() => new Error('User not authenticated'));
    }

    return this.authService.hasPermission('canAllocateJobs' as UserPermissionKey).pipe(
      switchMap((hasPermission) => {
        if (!hasPermission) {
          return throwError(() => new Error('You do not have permission to allocate jobs'));
        }

        const jobRef = doc(this.firestore, `jobs/${jobId}`);
        const updateData = {
          driverId,
          status: 'allocated',
          allocatedAt: serverTimestamp(),
          updatedAt: serverTimestamp(),
          updatedBy: this.currentUserId,
          statusUpdatedAt: serverTimestamp(),
        };

        return from(updateDoc(jobRef, updateData));
      }),
      tap(() => {
        this.notificationService.addNotification({
          type: 'success',
          title: 'Job Allocated',
          message: `Job ${jobId} has been allocated to driver successfully.`,
        });
      }),
      catchError((error) => {
        console.error(`Error allocating job ${jobId}:`, error);
        return throwError(() => new Error(`Failed to allocate job: ${error.message}`));
      })
    );
  }

  /**
   * Allocate job (simplified version - auto-detects driver or uses dialog)
   */
  allocateJob(jobId: string, driverId?: string): Observable<void> {
    if (driverId) {
      return this.allocateJobToDriver(jobId, driverId);
    }

    // If no driverId provided, allocate to current user (if they're a driver)
    if (this.currentUserId) {
      return this.authService.getUserProfile().pipe(
        switchMap((profile) => {
          if (profile?.role === 'driver') {
            return this.allocateJobToDriver(jobId, this.currentUserId!);
          } else {
            return throwError(() => new Error('Please specify a driver ID for job allocation'));
          }
        })
      );
    }

    return throwError(() => new Error('User not authenticated'));
  }

  /**
   * Unallocate job (remove driver assignment)
   */
  unallocateJob(jobId: string): Observable<void> {
    if (!this.currentUserId) {
      return throwError(() => new Error('User not authenticated'));
    }

    return this.authService.hasPermission('canAllocateJobs' as UserPermissionKey).pipe(
      switchMap((hasPermission) => {
        if (!hasPermission) {
          return throwError(() => new Error('You do not have permission to unallocate jobs'));
        }

        const jobRef = doc(this.firestore, `jobs/${jobId}`);
        const updateData = {
          driverId: null,
          status: 'unallocated',
          allocatedAt: null,
          updatedAt: serverTimestamp(),
          updatedBy: this.currentUserId,
          statusUpdatedAt: serverTimestamp(),
        };

        return from(updateDoc(jobRef, updateData));
      }),
      tap(() => {
        this.notificationService.addNotification({
          type: 'success',
          title: 'Job Unallocated',
          message: `Job ${jobId} has been unallocated successfully.`,
        });
      }),
      catchError((error) => {
        console.error(`Error unallocating job ${jobId}:`, error);
        return throwError(() => new Error(`Failed to unallocate job: ${error.message}`));
      })
    );
  }

  /**
   * Start collection for job
   */
  startCollection(jobId: string, collectionData: any = {}): Observable<void> {
    if (!this.currentUserId) {
      return throwError(() => new Error('User not authenticated'));
    }

    return this.getJobById(jobId).pipe(
      switchMap((job) => {
        if (!job) {
          return throwError(() => new Error('Job not found'));
        }

        return forkJoin([of(job.driverId === this.currentUserId), this.authService.hasPermission('isAdmin' as UserPermissionKey)]).pipe(
          switchMap(([isAssignedToUser, isAdmin]) => {
            if (!isAssignedToUser && !isAdmin) {
              return throwError(() => new Error('You are not authorized to start collection for this job'));
            }

            const jobRef = doc(this.firestore, `jobs/${jobId}`);
            const updateData = {
              ...collectionData,
              status: 'collected',
              stage: 'awaiting-delivery',
              collectionStartTime: serverTimestamp(),
              updatedAt: serverTimestamp(),
              updatedBy: this.currentUserId,
              statusUpdatedAt: serverTimestamp(),
            };

            return from(updateDoc(jobRef, updateData));
          })
        );
      }),
      tap(() => {
        this.notificationService.addNotification({
          type: 'success',
          title: 'Collection Started',
          message: `Collection has been started for job ${jobId}`,
        });
      }),
      catchError((error) => {
        console.error(`Error starting collection for job ${jobId}:`, error);
        return throwError(() => new Error(`Failed to start collection: ${error.message}`));
      })
    );
  }

  /**
   * Start delivery for job
   */
  startDelivery(jobId: string, deliveryData: any = {}): Observable<void> {
    if (!this.currentUserId) {
      return throwError(() => new Error('User not authenticated'));
    }

    return this.getJobById(jobId).pipe(
      switchMap((job) => {
        if (!job) {
          return throwError(() => new Error('Job not found'));
        }

        return forkJoin([of(job.driverId === this.currentUserId), this.authService.hasPermission('isAdmin' as UserPermissionKey)]).pipe(
          switchMap(([isAssignedToUser, isAdmin]) => {
            if (!isAssignedToUser && !isAdmin) {
              return throwError(() => new Error('You are not authorized to start delivery for this job'));
            }

            const jobRef = doc(this.firestore, `jobs/${jobId}`);
            const updateData = {
              ...deliveryData,
              status: 'in-transit',
              stage: 'delivering',
              deliveryStartTime: serverTimestamp(),
              updatedAt: serverTimestamp(),
              updatedBy: this.currentUserId,
              statusUpdatedAt: serverTimestamp(),
            };

            return from(updateDoc(jobRef, updateData));
          })
        );
      }),
      tap(() => {
        this.notificationService.addNotification({
          type: 'success',
          title: 'Delivery Started',
          message: `Delivery has been started for job ${jobId}`,
        });
      }),
      catchError((error) => {
        console.error(`Error starting delivery for job ${jobId}:`, error);
        return throwError(() => new Error(`Failed to start delivery: ${error.message}`));
      })
    );
  }

  /**
   * Complete delivery for job
   */
  completeDelivery(jobId: string, deliveryData: any): Observable<void> {
    if (!this.currentUserId) {
      return throwError(() => new Error('User not authenticated'));
    }

    return this.getJobById(jobId).pipe(
      switchMap((job) => {
        if (!job) {
          return throwError(() => new Error('Job not found'));
        }

        return forkJoin([of(job.driverId === this.currentUserId), this.authService.hasPermission('isAdmin' as UserPermissionKey)]).pipe(
          switchMap(([isAssignedToUser, isAdmin]) => {
            if (!isAssignedToUser && !isAdmin) {
              return throwError(() => new Error('You are not authorized to complete delivery for this job'));
            }

            const jobRef = doc(this.firestore, `jobs/${jobId}`);
            const updateData = {
              ...deliveryData,
              status: 'delivered',
              stage: 'completed',
              deliveryCompleteTime: serverTimestamp(),
              updatedAt: serverTimestamp(),
              updatedBy: this.currentUserId,
              statusUpdatedAt: serverTimestamp(),
            };

            return from(updateDoc(jobRef, updateData));
          })
        );
      }),
      tap(() => {
        this.notificationService.addNotification({
          type: 'success',
          title: 'Delivery Completed',
          message: `Delivery has been completed for job ${jobId}`,
        });
      }),
      catchError((error) => {
        console.error(`Error completing delivery for job ${jobId}:`, error);
        return throwError(() => new Error(`Failed to complete delivery: ${error.message}`));
      })
    );
  }

  /**
   * Bulk update jobs
   */
  bulkUpdateJobs(jobIds: string[], updateData: Partial<Job>): Observable<void> {
    if (!this.currentUserId) {
      return throwError(() => new Error('User not authenticated'));
    }

    if (jobIds.length === 0) {
      return of(undefined);
    }

    return this.authService.hasPermission('canEditJobs' as UserPermissionKey).pipe(
      switchMap((hasPermission) => {
        if (!hasPermission) {
          return throwError(() => new Error('You do not have permission to edit jobs'));
        }

        const batch = writeBatch(this.firestore);

        jobIds.forEach((jobId) => {
          const jobRef = doc(this.firestore, `jobs/${jobId}`);
          const batchUpdateData = {
            ...updateData,
            updatedAt: serverTimestamp(),
            updatedBy: this.currentUserId,
          };
          batch.update(jobRef, batchUpdateData);
        });

        return from(batch.commit());
      }),
      tap(() => {
        this.notificationService.addNotification({
          type: 'success',
          title: 'Jobs Updated',
          message: `${jobIds.length} jobs have been updated successfully.`,
        });
      }),
      catchError((error) => {
        console.error('Error bulk updating jobs:', error);
        return throwError(() => new Error(`Failed to update jobs: ${error.message}`));
      })
    );
  }

  /**
   * Duplicate job
   */
  duplicateJob(jobId: string): Observable<string> {
    if (!this.currentUserId) {
      return throwError(() => new Error('User not authenticated'));
    }

    return this.authService.hasPermission('canCreateJobs' as UserPermissionKey).pipe(
      switchMap((hasPermission) => {
        if (!hasPermission) {
          return throwError(() => new Error('You do not have permission to create jobs'));
        }

        return this.getJobById(jobId);
      }),
      switchMap((originalJob) => {
        if (!originalJob) {
          return throwError(() => new Error('Original job not found'));
        }

        // Create new job data based on original, but reset certain fields
        const newJobData = {
          ...originalJob,
          // Remove fields that shouldn't be duplicated
          id: undefined,
          driverId: null,
          status: 'unallocated',
          stage: '',

          // Reset timestamps
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp(),
          createdBy: this.currentUserId,
          updatedBy: this.currentUserId,

          // Clear progress-related fields
          allocatedAt: undefined,
          collectionStartTime: undefined,
          collectionCompleteTime: undefined,
          deliveryStartTime: undefined,
          deliveryCompleteTime: undefined,
          statusUpdatedAt: serverTimestamp(),

          // Reset optional process fields
          actualDuration: undefined,
        };

        // Remove undefined values to avoid Firestore issues
        Object.keys(newJobData).forEach((key) => {
          if (newJobData[key as keyof typeof newJobData] === undefined) {
            delete newJobData[key as keyof typeof newJobData];
          }
        });

        const jobsRef = collection(this.firestore, 'jobs');
        return from(addDoc(jobsRef, newJobData)).pipe(map((docRef) => docRef.id));
      }),
      tap((newJobId) => {
        this.notificationService.addNotification({
          type: 'success',
          title: 'Job Duplicated',
          message: `Job has been duplicated successfully. New job ID: ${newJobId}`,
          actionUrl: `/jobs/${newJobId}`,
        });
      }),
      catchError((error) => {
        console.error(`Error duplicating job ${jobId}:`, error);
        return throwError(() => new Error(`Failed to duplicate job: ${error.message}`));
      })
    );
  }

  /**
   * Get jobs with pagination
   */
  getJobsWithPagination(
    limitCount: number = 25,
    startAfterDoc?: QueryDocumentSnapshot<DocumentData>
  ): Observable<{ jobs: Job[]; lastDoc: QueryDocumentSnapshot<DocumentData> | null }> {
    const jobsRef = collection(this.firestore, 'jobs');

    let q = query(jobsRef, orderBy('updatedAt', 'desc'), limit(limitCount));

    if (startAfterDoc) {
      q = query(jobsRef, orderBy('updatedAt', 'desc'), startAfter(startAfterDoc), limit(limitCount));
    }

    return from(getDocs(q)).pipe(
      map((snapshot) => {
        const jobs = snapshot.docs.map((doc) => this.convertFirebaseJobToModel(doc.id, doc.data()));
        const lastDoc = snapshot.docs[snapshot.docs.length - 1] || null;

        return { jobs, lastDoc };
      }),
      catchError((error) => {
        console.error('Error fetching jobs with pagination:', error);
        return of({ jobs: [], lastDoc: null });
      })
    );
  }

  /**
   * Convert Firebase document to Job model
   */
  private convertFirebaseJobToModel(id: string, data: any): Job {
    const convertTimestamp = (timestamp: any): Date | undefined => {
      if (!timestamp) return undefined;

      if (timestamp && typeof timestamp === 'object' && 'toDate' in timestamp) {
        return timestamp.toDate();
      }

      if (timestamp) {
        return new Date(timestamp);
      }

      return undefined;
    };

    return {
      id,
      vehicleId: data.vehicleId || '',
      driverId: data.driverId || null,
      status: data.status || 'unallocated',
      stage: data.stage || '',

      // Customer and vehicle information
      customerName: data.customerName || '',
      customerEmail: data.customerEmail || '',
      customerPhone: data.customerPhone || '',
      regNumber: data.regNumber || '',
      make: data.make || '',
      model: data.model || '',
      year: data.year || null,
      color: data.color || '',

      // Location information
      collectionAddress: data.collectionAddress || '',
      collectionTown: data.collectionTown || '',
      collectionPostcode: data.collectionPostcode || '',
      deliveryAddress: data.deliveryAddress || '',
      deliveryTown: data.deliveryTown || '',
      deliveryPostcode: data.deliveryPostcode || '',

      // Dates
      collectionDate: convertTimestamp(data.collectionDate),
      deliveryDate: convertTimestamp(data.deliveryDate),
      createdAt: convertTimestamp(data.createdAt) || new Date(),
      updatedAt: convertTimestamp(data.updatedAt) || new Date(),

      // Timestamps for various stages
      allocatedAt: convertTimestamp(data.allocatedAt),
      collectionStartTime: convertTimestamp(data.collectionStartTime),
      collectionCompleteTime: convertTimestamp(data.collectionCompleteTime),
      deliveryStartTime: convertTimestamp(data.deliveryStartTime),
      deliveryCompleteTime: convertTimestamp(data.deliveryCompleteTime),
      statusUpdatedAt: convertTimestamp(data.statusUpdatedAt),

      // Additional fields
      notes: data.notes || '',
      specialInstructions: data.specialInstructions || '',
      priority: data.priority || 'normal',
      estimatedDuration: data.estimatedDuration || null,
      actualDuration: data.actualDuration || null,

      // Tracking fields
      createdBy: data.createdBy || '',
      updatedBy: data.updatedBy || '',

      // Optional fields that might be present
      ...Object.keys(data).reduce((acc: any, key) => {
        if (
          ![
            'id',
            'vehicleId',
            'driverId',
            'status',
            'stage',
            'customerName',
            'customerEmail',
            'customerPhone',
            'regNumber',
            'make',
            'model',
            'year',
            'color',
            'collectionAddress',
            'collectionTown',
            'collectionPostcode',
            'deliveryAddress',
            'deliveryTown',
            'deliveryPostcode',
            'collectionDate',
            'deliveryDate',
            'createdAt',
            'updatedAt',
            'allocatedAt',
            'collectionStartTime',
            'collectionCompleteTime',
            'deliveryStartTime',
            'deliveryCompleteTime',
            'statusUpdatedAt',
            'notes',
            'specialInstructions',
            'priority',
            'estimatedDuration',
            'actualDuration',
            'createdBy',
            'updatedBy',
          ].includes(key)
        ) {
          acc[key] = data[key];
        }
        return acc;
      }, {}),
    };
  }
}


--- ./src/app/services/expense.service.ts ---
import { Injectable } from '@angular/core';
import { Observable, of } from 'rxjs';
import { delay, tap } from 'rxjs/operators';
import { Expense, ExpenseStatus } from '../shared/models/expense.model';
import { NotificationService } from './notification.service';

@Injectable({
  providedIn: 'root',
})
export class ExpenseService {
  private expenses: Expense[] = [];

  constructor(private notificationService: NotificationService) {
    // Initialize with some mock data
    this.generateMockExpenses();
  }

  getExpenses(): Observable<Expense[]> {
    // Simulate API delay
    return of([...this.expenses]).pipe(delay(500));
  }

  getPendingExpenses(): Observable<Expense[]> {
    const pendingExpenses = this.expenses.filter((expense) => expense.status === ExpenseStatus.PENDING);
    return of(pendingExpenses).pipe(delay(500));
  }

  getExpensesByDriver(driverId: string): Observable<Expense[]> {
    const driverExpenses = this.expenses.filter((expense) => expense.driverId === driverId);
    return of(driverExpenses).pipe(delay(500));
  }

  getExpensesByJob(jobId: string): Observable<Expense[]> {
    const jobExpenses = this.expenses.filter((expense) => expense.jobId === jobId);
    return of(jobExpenses).pipe(delay(500));
  }

  // Fixed using type assertion to avoid TypeScript error
  createExpense(expense: Omit<Expense, 'id' | 'status'>): Observable<Expense> {
    // Create a base expense without the payment properties first
    const baseExpense = {
      ...expense,
      id: `EXP${String(this.expenses.length + 1).padStart(4, '0')}`,
      status: ExpenseStatus.PENDING,
    };

    // Then add the payment properties using type assertion
    const newExpense = {
      ...baseExpense,
      isPaid: false,
    } as Expense;

    this.expenses.push(newExpense);

    // Create notification for managers about new expense
    this.notificationService.addNotification({
      type: 'info',
      title: 'New Invoice Submitted',
      message: `A new invoice for ${expense.amount.toFixed(2)} has been submitted by ${expense.driverName}`,
      actionUrl: '/expenses',
    });

    return of(newExpense).pipe(delay(500));
  }

  updateExpenseStatus(id: string, status: ExpenseStatus, approverInfo?: { approvedBy: string }): Observable<Expense> {
    const index = this.expenses.findIndex((expense) => expense.id === id);
    if (index !== -1) {
      const originalExpense = this.expenses[index];
      const updatedExpense = {
        ...originalExpense,
        status,
        approvedBy: approverInfo?.approvedBy,
        approvedDate: status === ExpenseStatus.APPROVED ? new Date() : undefined,
      };

      this.expenses[index] = updatedExpense;

      // Send notification to the driver
      let notificationType: 'success' | 'warning';
      let notificationTitle: string;
      let notificationMessage: string;

      if (status === ExpenseStatus.APPROVED) {
        notificationType = 'success';
        notificationTitle = 'Invoice Approved';
        notificationMessage = `Your invoice ${updatedExpense.description} for ${updatedExpense.amount.toFixed(2)} has been approved`;
      } else {
        notificationType = 'warning';
        notificationTitle = 'Invoice Rejected';
        notificationMessage = `Your invoice ${updatedExpense.description} for ${updatedExpense.amount.toFixed(2)} has been rejected`;
      }

      this.notificationService.addNotification({
        type: notificationType,
        title: notificationTitle,
        message: notificationMessage,
        actionUrl: updatedExpense.jobId ? `/jobs/${updatedExpense.jobId}` : '/expenses',
      });

      return of(updatedExpense).pipe(delay(500));
    }

    throw new Error(`Expense with id ${id} not found`);
  }

  updateExpenseChargeableStatus(id: string, isChargeable: boolean): Observable<Expense> {
    const index = this.expenses.findIndex((expense) => expense.id === id);
    if (index !== -1) {
      const originalExpense = this.expenses[index];
      const updatedExpense = {
        ...originalExpense,
        isChargeable,
      };

      this.expenses[index] = updatedExpense;

      // No notification for chargeable status updates as this is an internal management function

      return of(updatedExpense).pipe(delay(500));
    }

    throw new Error(`Expense with id ${id} not found`);
  }

  // Method to update paid status using type assertion
  updateExpensePaidStatus(id: string, isPaid: boolean): Observable<Expense> {
    const index = this.expenses.findIndex((expense) => expense.id === id);
    if (index !== -1) {
      const originalExpense = this.expenses[index];

      // Use type assertion to add payment properties
      const updatedExpense = {
        ...originalExpense,
        isPaid,
        paidDate: isPaid ? new Date() : undefined,
      } as Expense;

      this.expenses[index] = updatedExpense;

      // Add notification about payment status update
      const notificationType = isPaid ? 'success' : 'info';
      const notificationTitle = isPaid ? 'Invoice Paid' : 'Invoice Marked as Unpaid';
      const notificationMessage = isPaid ? `Invoice ${updatedExpense.id} has been marked as paid` : `Invoice ${updatedExpense.id} has been marked as unpaid`;

      this.notificationService.addNotification({
        type: notificationType,
        title: notificationTitle,
        message: notificationMessage,
        actionUrl: '/expenses',
      });

      return of(updatedExpense).pipe(delay(500));
    }

    throw new Error(`Expense with id ${id} not found`);
  }

  private generateMockExpenses(): void {
    this.expenses = Array(15)
      .fill(null)
      .map((_, index) => {
        // Create base expense
        const baseExpense = {
          id: `EXP${String(index + 1).padStart(4, '0')}`,
          driverId: `DRV${String(Math.floor(Math.random() * 5) + 1).padStart(2, '0')}`,
          driverName: `Driver ${Math.floor(Math.random() * 5) + 1}`,
          description: `Invoice ${index + 1}`,
          amount: Math.floor(Math.random() * 200) + 20,
          date: new Date(2024, 0, Math.floor(Math.random() * 30) + 1),
          status: this.getRandomStatus(),
          isChargeable: Math.random() > 0.5,
          jobId: Math.random() > 0.3 ? `JOB${String(Math.floor(Math.random() * 10) + 1).padStart(4, '0')}` : undefined,
          notes: Math.random() > 0.7 ? 'Additional notes about this invoice' : undefined,
        };

        // Add payment properties with type assertion
        return {
          ...baseExpense,
          isPaid: Math.random() > 0.7,
          paidDate: Math.random() > 0.7 ? new Date(2024, 0, Math.floor(Math.random() * 30) + 1) : undefined,
        } as Expense;
      });
  }

  private getRandomStatus(): ExpenseStatus {
    const statuses = [ExpenseStatus.PENDING, ExpenseStatus.APPROVED, ExpenseStatus.REJECTED];
    return statuses[Math.floor(Math.random() * statuses.length)];
  }
}


--- ./src/app/guards/guest.guard.ts ---
import { Injectable } from '@angular/core';
import {
  CanActivate,
  ActivatedRouteSnapshot,
  RouterStateSnapshot,
  Router,
  UrlTree,
} from '@angular/router';
import { Observable, map, take } from 'rxjs';
import { AuthService } from '../services/auth.service';

@Injectable({
  providedIn: 'root',
})
export class GuestGuard implements CanActivate {
  constructor(private authService: AuthService, private router: Router) {}

  canActivate(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ):
    | Observable<boolean | UrlTree>
    | Promise<boolean | UrlTree>
    | boolean
    | UrlTree {
    return this.authService.isAuthenticated().pipe(
      take(1),
      map((isLoggedIn) => {
        if (!isLoggedIn) {
          return true;
        }

        // If user is logged in, redirect to dashboard or returnUrl if available
        const returnUrl = route.queryParams['returnUrl'] || '/dashboard';
        return this.router.createUrlTree([returnUrl]);
      })
    );
  }
}


--- ./src/app/guards/auth.guard.ts ---
import { Injectable } from '@angular/core';
import {
  CanActivate,
  ActivatedRouteSnapshot,
  RouterStateSnapshot,
  Router,
  UrlTree,
} from '@angular/router';
import { Observable, map, take } from 'rxjs';
import { AuthService } from '../services/auth.service';

@Injectable({
  providedIn: 'root',
})
export class AuthGuard implements CanActivate {
  constructor(private authService: AuthService, private router: Router) {}

  canActivate(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ):
    | Observable<boolean | UrlTree>
    | Promise<boolean | UrlTree>
    | boolean
    | UrlTree {
    return this.authService.isAuthenticated().pipe(
      take(1),
      map((isLoggedIn) => {
        if (isLoggedIn) {
          return true;
        }

        // Store the attempted URL for redirecting after login
        const returnUrl = state.url;
        return this.router.createUrlTree(['/auth/sign-in'], {
          queryParams: { returnUrl },
        });
      })
    );
  }
}


--- ./src/app/guards/role.guard.ts ---
import { Injectable } from '@angular/core';
import {
  CanActivate,
  ActivatedRouteSnapshot,
  RouterStateSnapshot,
  Router,
  UrlTree,
} from '@angular/router';
import { Observable, of, switchMap, take, map, catchError } from 'rxjs';
import { AuthService } from '../services/auth.service';
import { MatSnackBar } from '@angular/material/snack-bar';
import { UserPermissionKey } from '../interfaces/user-profile.interface';

@Injectable({
  providedIn: 'root',
})
export class RoleGuard implements CanActivate {
  constructor(
    private authService: AuthService,
    private router: Router,
    private snackBar: MatSnackBar
  ) {}

  canActivate(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ):
    | Observable<boolean | UrlTree>
    | Promise<boolean | UrlTree>
    | boolean
    | UrlTree {
    const requiredPermissions = route.data['permissions'] as string[];

    if (!requiredPermissions || requiredPermissions.length === 0) {
      console.warn('RoleGuard: No permissions specified in route data');
      return true;
    }

    return this.authService.isAuthenticated().pipe(
      take(1),
      switchMap((isLoggedIn) => {
        if (!isLoggedIn) {
          return of(
            this.router.createUrlTree(['/auth/sign-in'], {
              queryParams: { returnUrl: state.url },
            })
          );
        }

        // Check if admin (admins have all permissions)
        if (requiredPermissions.includes('isAdmin')) {
          return this.authService.isAdmin().pipe(
            map((isAdmin) => {
              if (isAdmin) {
                return true;
              } else {
                this.showAccessDenied();
                return this.router.createUrlTree(['/dashboard']);
              }
            })
          );
        }

        // Check for any required permission
        return this.authService.hasAnyPermission(requiredPermissions).pipe(
          map((hasPermission) => {
            if (hasPermission) {
              return true;
            } else {
              this.showAccessDenied();
              return this.router.createUrlTree(['/dashboard']);
            }
          }),
          catchError(() => {
            this.showAccessDenied();
            return of(this.router.createUrlTree(['/dashboard']));
          })
        );
      })
    );
  }

  private showAccessDenied(): void {
    this.snackBar.open(
      'You do not have permission to access this resource',
      'Dismiss',
      {
        duration: 5000,
        panelClass: ['error-snackbar'],
      }
    );
  }
}


--- ./src/app/interfaces/company.interface.ts ---
export enum CompanySize {
  SMALL = 'Small (1-50)',
  MEDIUM = 'Medium (51-250)',
  LARGE = 'Large (251-1000)',
  ENTERPRISE = 'Enterprise (1000+)',
}

export enum CompanyStatus {
  ACTIVE = 'Active',
  INACTIVE = 'Inactive',
  PENDING = 'Pending',
}

export interface CompanyContact {
  id: string;
  name: string;
  position?: string;
  email: string;
  phone?: string;
  isPrimary: boolean;
}

export interface Company {
  id: string;
  name: string;
  industry: string;
  size: CompanySize;
  status: CompanyStatus;
  address: string;
  city?: string;
  postcode?: string;
  country?: string;
  website?: string;
  description?: string;
  contacts: CompanyContact[];
  createdAt: Date;
  updatedAt: Date;
  createdBy?: string;
  updatedBy?: string;
  lastContact?: Date;
  notes?: string;
  logoUrl?: string;
}


--- ./src/app/interfaces/user-profile.interface.ts ---
// src/app/interfaces/user-profile.interface.ts
export interface UserProfile {
  id: string;
  email: string;
  name: string;
  firstName?: string;
  lastName?: string;
  phoneNumber?: string;
  phone?: string;
  role?: string;
  status?: 'active' | 'inactive' | 'pending' | 'on_leave';
  isActive?: boolean;
  company?: string;
  type?: 'customer' | 'supplier' | 'partner';
  lastActivity?: Date;
  licenseNumber?: string;
  licenseExpiry?: Date;
  vehicleType?: string;
  areaCoverage?: string;
  availability?: string;
  createdAt?: Date;
  updatedAt?: Date;
  permissions?: {
    canAllocateJobs?: boolean;
    canApproveExpenses?: boolean;
    canCreateJobs?: boolean;
    canEditJobs?: boolean;
    canManageUsers?: boolean;
    canViewReports?: boolean;
    canViewUnallocated?: boolean;
    isAdmin?: boolean;
    [key: string]: boolean | undefined;
  };
  notes?: string;
}

// src/app/interfaces/user-profile.interface.ts
export enum UserRole {
  ADMIN = 'Admin',
  DRIVER = 'Driver',
  CONTRACTOR = 'Contractor',
  SYSTEM_USER = 'System User',
}

export type UserPermissionKey =
  | 'canAllocateJobs'
  | 'canApproveExpenses'
  | 'canCreateJobs'
  | 'canEditJobs'
  | 'canManageUsers'
  | 'canViewReports'
  | 'canViewUnallocated'
  | 'isAdmin'
  | 'canViewSystemSettings'
  | 'canManageCompanies'
  | 'canViewAllJobs'
  | 'canViewAssignedJobs'
  | 'canCreateExpenses';

// Define preset permissions for each role
export const ROLE_PERMISSION_PRESETS: Record<UserRole, Record<UserPermissionKey, boolean>> = {
  [UserRole.ADMIN]: {
    canAllocateJobs: true,
    canApproveExpenses: true,
    canCreateJobs: true,
    canEditJobs: true,
    canManageUsers: true,
    canViewReports: true,
    canViewUnallocated: true,
    isAdmin: true,
    canViewSystemSettings: true,
    canManageCompanies: true,
    canViewAllJobs: true,
    canViewAssignedJobs: true,
    canCreateExpenses: true,
  },
  [UserRole.DRIVER]: {
    canAllocateJobs: false,
    canApproveExpenses: false,
    canCreateJobs: false,
    canEditJobs: false,
    canManageUsers: false,
    canViewReports: false,
    canViewUnallocated: false,
    isAdmin: false,
    canViewSystemSettings: false,
    canManageCompanies: false,
    canViewAllJobs: false,
    canViewAssignedJobs: true,
    canCreateExpenses: true,
  },
  [UserRole.CONTRACTOR]: {
    canAllocateJobs: false,
    canApproveExpenses: false,
    canCreateJobs: false,
    canEditJobs: false,
    canManageUsers: false,
    canViewReports: false,
    canViewUnallocated: false,
    isAdmin: false,
    canViewSystemSettings: false,
    canManageCompanies: false,
    canViewAllJobs: false,
    canViewAssignedJobs: true,
    canCreateExpenses: true,
  },
  [UserRole.SYSTEM_USER]: {
    canAllocateJobs: true,
    canApproveExpenses: true,
    canCreateJobs: true,
    canEditJobs: true,
    canManageUsers: true,
    canViewReports: true,
    canViewUnallocated: true,
    isAdmin: false,
    canViewSystemSettings: false,
    canManageCompanies: true,
    canViewAllJobs: true,
    canViewAssignedJobs: true,
    canCreateExpenses: true,
  },
};


--- ./src/app/interfaces/job.interface.ts ---
// src/app/interfaces/job.interface.ts
// Updated interface to handle notes properly

export interface NoteData {
  author: string;
  content: string;
  date: Date | string;
  id?: string;
}

export interface Job {
  id: string;
  vehicleId: string;
  driverId: string | null;
  status: 'unallocated' | 'allocated' | 'collected' | 'delivered' | 'completed' | 'loaded';
  stage?: 'collection-complete' | 'in-transit' | 'ready-for-delivery' | 'awaiting-confirmation';
  collectionStartTime?: Date;
  collectionCompleteTime?: Date;
  deliveryStartTime?: Date;
  deliveryCompleteTime?: Date;
  allocatedAt?: Date;
  unallocatedAt?: Date;
  createdAt: Date;
  updatedAt: Date;
  createdBy?: string;
  updatedBy?: string | null;
  make?: string;
  model?: string;
  registration?: string;

  // Fixed notes type to handle both string and array formats
  notes?: string | NoteData[] | Record<string, any>;

  customerId?: string;
  customerName?: string;
  customerContact?: string;
  customerContactPhone?: string;

  collectionAddress?: string;
  collectionCity?: string;
  collectionPostcode?: string;
  collectionContactName?: string;
  collectionContactPhone?: string;
  collectionNotes?: string;

  deliveryAddress?: string;
  deliveryCity?: string;
  deliveryPostcode?: string;
  deliveryContactName?: string;
  deliveryContactPhone?: string;
  deliveryNotes?: string;

  color?: string;
  year?: number;
  fuelType?: string;
  mileage?: number;
  fuelLevel?: string;
  chassisNumber?: string;
  vehicleType?: string;

  isSplitJourney?: boolean;

  secondaryCollectionAddress?: string;
  secondaryCollectionCity?: string;
  secondaryCollectionPostcode?: string;
  secondaryCollectionContactName?: string;
  secondaryCollectionContactPhone?: string;
  secondaryCollectionNotes?: string;

  firstDeliveryAddress?: string;
  firstDeliveryCity?: string;
  firstDeliveryPostcode?: string;
  firstDeliveryContactName?: string;
  firstDeliveryContactPhone?: string;
  firstDeliveryNotes?: string;

  collectionActualDateTime?: Date;
  deliveryActualDateTime?: Date;

  collectionPhotos?: string[];
  deliveryPhotos?: string[];
  collectionSignature?: string;
  deliverySignature?: string;

  [key: string]: any;
}

export interface UserProfile {
  id: string;
  email: string;
  name: string;
  firstName?: string;
  lastName?: string;
  phoneNumber?: string;
  role: string; // Made required to fix type compatibility
  isActive?: boolean;
  permissions?: {
    canAllocateJobs?: boolean;
    canApproveExpenses?: boolean;
    canCreateJobs?: boolean;
    canEditJobs?: boolean;
    canManageUsers?: boolean;
    canViewReports?: boolean;
    canViewUnallocated?: boolean;
    isAdmin?: boolean;
    [key: string]: boolean | undefined;
  };
}

export interface JobEntry {
  vehicleId: string;
  status: string;
  driverId: null | undefined;

  make?: string | null;
  model?: string | null;
  registration?: string | null;
  chassisNumber?: string | null;
  type?: string | null;
  color?: string | null;
  year?: number | null;

  collectionAddress?: string | null;
  collectionCity?: string | null;
  collectionContactName?: string | null;
  collectionContactPhone?: string | null;
  collectionEmail?: string | null;
  collectionDate?: string | null;
  collectionNotes?: string | null;

  deliveryAddress?: string | null;
  deliveryCity?: string | null;
  deliveryContactName?: string | null;
  deliveryContactPhone?: string | null;
  deliveryEmail?: string | null;
  deliveryDate?: string | null;
  deliveryNotes?: string | null;

  isSplitJourney?: boolean;
  secondaryCollectionAddress?: string | null;
  secondaryCollectionCity?: string | null;
  secondaryCollectionContactName?: string | null;
  secondaryCollectionContactPhone?: string | null;
  secondaryCollectionEmail?: string | null;
  secondaryCollectionDate?: string | null;
  secondaryCollectionNotes?: string | null;
  firstDeliveryAddress?: string | null;
  firstDeliveryCity?: string | null;
  firstDeliveryContactName?: string | null;
  firstDeliveryContactPhone?: string | null;
  firstDeliveryEmail?: string | null;
  firstDeliveryDate?: string | null;
  firstDeliveryNotes?: string | null;

  createdAt: Date;
  updatedAt: Date;
  createdBy: string | null;
  updatedBy: string | null;

  customerId?: string | null;
  customerName?: string | null;
  customerJobNumber?: string | null;
  shippingReference?: string | null;
}


--- ./src/app/interfaces/expense.interface.ts ---
export enum ExpenseStatus {
  PENDING = 'Pending',
  APPROVED = 'Approved',
  REJECTED = 'Rejected',
}

export interface Expense {
  id: string;
  jobId?: string;
  driverId: string;
  driverName: string;
  description: string;
  amount: number;
  date: Date;
  receiptUrl?: string;
  status: ExpenseStatus;
  approvedBy?: string;
  approvedDate?: Date;
  isChargeable: boolean;
  notes?: string;

  // Payment tracking fields
  isPaid?: boolean;
  paidDate?: Date;
  paidBy?: string;
  paymentReference?: string;
}


--- ./src/app/interfaces/customer.interface.ts ---
// src/app/shared/models/customer.model.ts

export enum CustomerSize {
  SMALL = 'Small (1-50)',
  MEDIUM = 'Medium (51-250)',
  LARGE = 'Large (251-1000)',
  ENTERPRISE = 'Enterprise (1000+)',
}

export enum CustomerStatus {
  ACTIVE = 'Active',
  INACTIVE = 'Inactive',
  PENDING = 'Pending',
}

export interface CustomerContact {
  id: string;
  name: string;
  position?: string;
  email: string;
  phone?: string;
  isPrimary: boolean;
}

export interface Customer {
  id: string;
  name: string;
  phone: string;
  industry?: string;
  category?: string;
  size?: CustomerSize;
  status: CustomerStatus;
  address?: string;
  city?: string;
  postcode?: string;
  country?: string;
  website?: string;
  description?: string;
  contacts: CustomerContact[];
  createdAt: Date;
  updatedAt: Date;
  createdBy?: string;
  updatedBy?: string;
  lastContact?: Date;
  notes?: string;
  isActive: boolean;
}


--- ./src/app/interfaces/job-new.interface.ts ---
import { Timestamp } from '@angular/fire/firestore';

export interface SavedChecklistItem {
  control: string;
  name: string;
  isChecked: boolean;
  category: string;
  notes?: string | null;
}

export interface JobProcessStepData {
  contactName?: string | null;
  contactEmail?: string | null;
  contactPosition?: string | null;
  contactNumber?: string | null;
  signatureUrl?: string | null;
  photoUrls?: string[] | null;
  notes?: string | null;
  mileage?: number | null;
  fuelLevel?: number | null;
  energyType?: 'fuel' | 'electric' | string | null;
  damageReportedThisStep?: boolean;
  completedAt?: Timestamp | null;
  checklistItems?: SavedChecklistItem[] | null;
  damageDiagramImageUrl?: string | null;
}

export interface JobNote {
  id: string;
  authorId: string;
  authorName: string;
  content: string;
  createdAt: Timestamp;
}

export interface Job {
  id: string;

  vehicleRegistration: string;
  vehicleMake?: string | null;
  vehicleModel?: string | null;
  chassisNumber?: string | null;
  vehicleType?: string | null;
  vehicleColor?: string | null;
  vehicleYear?: number | null;
  vehicleFuelType?: string | null;

  status:
    | 'unallocated'
    | 'allocated'
    | 'collection-in-progress'
    | 'collected'
    | 'loaded'
    | 'secondary-collection-in-progress'
    | 'secondary-collection-complete'
    | 'in-transit'
    | 'first-delivery-in-progress'
    | 'first-delivery-complete'
    | 'delivery-in-progress'
    | 'delivered'
    | 'completed'
    | 'cancelled'
    | 'aborted';
  stage?: string | null;

  createdAt: Timestamp;
  updatedAt: Timestamp;
  statusUpdatedAt: Timestamp;

  allocatedAt?: Timestamp | null;
  unallocatedAt?: Timestamp | null;
  collectionScheduledTime?: Timestamp | null;
  collectionActualStartTime?: Timestamp | null;
  collectionActualCompleteTime?: Timestamp | null;
  deliveryScheduledTime?: Timestamp | null;
  deliveryActualStartTime?: Timestamp | null;
  deliveryActualCompleteTime?: Timestamp | null;
  abortedAt?: Timestamp | null;
  cancelledAt?: Timestamp | null;

  driverId?: string | null;

  customerId?: string | null;
  customerName?: string | null;
  customerJobNumber?: string | null;
  shippingReference?: string | null;

  createdBy: string;
  updatedBy?: string | null;
  abortedBy?: string | null;
  cancelledBy?: string | null;

  collectionAddress?: string | null;
  collectionCity?: string | null;
  collectionPostcode?: string | null;
  collectionContactName?: string | null;
  collectionContactPhone?: string | null;
  collectionContactEmail?: string | null;
  collectionNotes?: string | null;
  collectionData?: JobProcessStepData | null;

  deliveryAddress?: string | null;
  deliveryCity?: string | null;
  deliveryPostcode?: string | null;
  deliveryContactName?: string | null;
  deliveryContactPhone?: string | null;
  deliveryContactEmail?: string | null;
  deliveryNotes?: string | null;
  deliveryData?: JobProcessStepData | null;

  isSplitJourney: boolean;
  secondaryCollectionAddress?: string | null;
  secondaryCollectionCity?: string | null;
  secondaryCollectionPostcode?: string | null;
  secondaryCollectionContactName?: string | null;
  secondaryCollectionContactPhone?: string | null;
  secondaryCollectionContactEmail?: string | null;
  secondaryCollectionNotes?: string | null;
  secondaryCollectionData?: JobProcessStepData | null;
  secondaryCollectionScheduledTime?: Timestamp | null;
  secondaryCollectionActualStartTime?: Timestamp | null;
  secondaryCollectionActualCompleteTime?: Timestamp | null;

  firstDeliveryAddress?: string | null;
  firstDeliveryCity?: string | null;
  firstDeliveryPostcode?: string | null;
  firstDeliveryContactName?: string | null;
  firstDeliveryContactPhone?: string | null;
  firstDeliveryContactEmail?: string | null;
  firstDeliveryNotes?: string | null;
  firstDeliveryData?: JobProcessStepData | null;
  firstDeliveryScheduledTime?: Timestamp | null;
  firstDeliveryActualStartTime?: Timestamp | null;
  firstDeliveryActualCompleteTime?: Timestamp | null;

  jobType?: string | null;
  generalNotes?: JobNote[] | null;
  hasDamageCommitted: boolean;
  abortReason?: string | null;

  collectionReportSentTo?: string[] | null;
  collectionReportDateSent?: Timestamp | null;
  deliveryReportSentTo?: string[] | null;
  deliveryReportDateSent?: Timestamp | null;

  multiJobBatchId?: string | null;

  [key: string]: any;
}

export interface UserProfile {
  id: string;
  email: string;
  name: string;
  firstName?: string;
  lastName?: string;
  phoneNumber?: string;
  role: string;
  isActive?: boolean;
  permissions?: {
    canAllocateJobs?: boolean;
    canApproveExpenses?: boolean;
    canCreateJobs?: boolean;
    canEditJobs?: boolean;
    canManageUsers?: boolean;
    canViewReports?: boolean;
    canViewUnallocated?: boolean;
    isAdmin?: boolean;
    [key: string]: boolean | undefined;
  };
}

export interface JobEntry {
  createdAt: Timestamp;
  updatedAt: Timestamp;
  statusUpdatedAt: Timestamp;

  vehicleRegistration: string;
  vehicleMake?: string | null;
  vehicleModel?: string | null;
  chassisNumber?: string | null;
  vehicleType?: string | null;
  vehicleColor?: string | null;
  vehicleYear?: number | null;
  vehicleFuelType?: string | null;

  status:
    | 'unallocated'
    | 'allocated'
    | 'collection-in-progress'
    | 'collected'
    | 'loaded'
    | 'secondary-collection-in-progress'
    | 'secondary-collection-complete'
    | 'in-transit'
    | 'first-delivery-in-progress'
    | 'first-delivery-complete'
    | 'delivery-in-progress'
    | 'delivered'
    | 'completed'
    | 'cancelled'
    | 'aborted';
  stage?: string | null;

  allocatedAt?: Timestamp | null;
  unallocatedAt?: Timestamp | null;
  collectionScheduledTime?: Timestamp | null;
  collectionActualStartTime?: Timestamp | null;
  collectionActualCompleteTime?: Timestamp | null;
  deliveryScheduledTime?: Timestamp | null;
  deliveryActualStartTime?: Timestamp | null;
  deliveryActualCompleteTime?: Timestamp | null;
  abortedAt?: Timestamp | null;
  cancelledAt?: Timestamp | null;

  driverId?: string | null;

  customerId?: string | null;
  customerName?: string | null;
  customerJobNumber?: string | null;
  shippingReference?: string | null;

  createdBy: string;
  updatedBy?: string | null;
  abortedBy?: string | null;
  cancelledBy?: string | null;

  collectionAddress?: string | null;
  collectionCity?: string | null;
  collectionPostcode?: string | null;
  collectionContactName?: string | null;
  collectionContactPhone?: string | null;
  collectionContactEmail?: string | null;
  collectionNotes?: string | null;
  collectionData?: JobProcessStepData | null;

  deliveryAddress?: string | null;
  deliveryCity?: string | null;
  deliveryPostcode?: string | null;
  deliveryContactName?: string | null;
  deliveryContactPhone?: string | null;
  deliveryContactEmail?: string | null;
  deliveryNotes?: string | null;
  deliveryData?: JobProcessStepData | null;

  isSplitJourney: boolean;
  secondaryCollectionAddress?: string | null;
  secondaryCollectionCity?: string | null;
  secondaryCollectionPostcode?: string | null;
  secondaryCollectionContactName?: string | null;
  secondaryCollectionContactPhone?: string | null;
  secondaryCollectionContactEmail?: string | null;
  secondaryCollectionNotes?: string | null;
  secondaryCollectionData?: JobProcessStepData | null;
  secondaryCollectionScheduledTime?: Timestamp | null;
  secondaryCollectionActualStartTime?: Timestamp | null;
  secondaryCollectionActualCompleteTime?: Timestamp | null;

  firstDeliveryAddress?: string | null;
  firstDeliveryCity?: string | null;
  firstDeliveryPostcode?: string | null;
  firstDeliveryContactName?: string | null;
  firstDeliveryContactPhone?: string | null;
  firstDeliveryContactEmail?: string | null;
  firstDeliveryNotes?: string | null;
  firstDeliveryData?: JobProcessStepData | null;
  firstDeliveryScheduledTime?: Timestamp | null;
  firstDeliveryActualStartTime?: Timestamp | null;
  firstDeliveryActualCompleteTime?: Timestamp | null;

  jobType?: string | null;
  generalNotes?: JobNote[] | null;
  hasDamageCommitted: boolean;
  abortReason?: string | null;

  collectionReportSentTo?: string[] | null;
  collectionReportDateSent?: Timestamp | null;
  deliveryReportSentTo?: string[] | null;
  deliveryReportDateSent?: Timestamp | null;

  multiJobBatchId?: string | null;
}


--- ./src/app/interfaces/vehicle.interface.ts ---
// src/app/interfaces/vehicle.interface.ts - Standardized Vehicle Interface
export interface Vehicle {
  id: string;
  registration: string;
  make: string;
  model: string;
  year: number;
  color: string;
  vin?: string;
  status: VehicleStatus;

  // Current assignment
  currentJobId?: string;
  assignedDriverId?: string;

  // Location tracking
  lastKnownLocation?: {
    latitude: number;
    longitude: number;
    timestamp: Date;
    address?: string;
  };

  // Vehicle details
  fuelType?: FuelType;
  transmission?: TransmissionType;
  engineSize?: string;
  doors?: number;
  seats?: number;

  // Maintenance
  lastServiceDate?: Date;
  nextServiceDate?: Date;
  motExpiryDate?: Date;
  insuranceExpiryDate?: Date;
  taxExpiryDate?: Date;

  // Tracking - Required fields
  createdAt: Date;
  updatedAt: Date;
  createdBy?: string;
  updatedBy?: string;

  // Additional optional fields
  [key: string]: any;
}

export type VehicleStatus = 'available' | 'allocated' | 'in-transit' | 'maintenance' | 'out-of-service';

export type FuelType = 'petrol' | 'diesel' | 'electric' | 'hybrid' | 'other';
export type TransmissionType = 'manual' | 'automatic' | 'semi-automatic';

// Alternative simplified Vehicle interface if you're having issues
export interface SimpleVehicle {
  id: string;
  registration?: string;
  make?: string;
  model?: string;
  year?: number;
  color?: string;
  status?: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  [key: string]: any;
}

// Type guard to check if object is a Vehicle
export function isVehicle(obj: any): obj is Vehicle {
  return obj && typeof obj === 'object' && typeof obj.id === 'string' && typeof obj.make === 'string' && typeof obj.model === 'string' && typeof obj.status === 'string';
}

// Utility function to convert any object to Vehicle
export function toVehicle(obj: any): Vehicle {
  return {
    id: obj.id || '',
    registration: obj.registration || '',
    make: obj.make || '',
    model: obj.model || '',
    year: obj.year || new Date().getFullYear(),
    color: obj.color || '',
    vin: obj.vin,
    status: obj.status || 'available',
    currentJobId: obj.currentJobId,
    assignedDriverId: obj.assignedDriverId,
    lastKnownLocation: obj.lastKnownLocation,
    fuelType: obj.fuelType,
    transmission: obj.transmission,
    engineSize: obj.engineSize,
    doors: obj.doors,
    seats: obj.seats,
    lastServiceDate: obj.lastServiceDate ? new Date(obj.lastServiceDate) : undefined,
    nextServiceDate: obj.nextServiceDate ? new Date(obj.nextServiceDate) : undefined,
    motExpiryDate: obj.motExpiryDate ? new Date(obj.motExpiryDate) : undefined,
    insuranceExpiryDate: obj.insuranceExpiryDate ? new Date(obj.insuranceExpiryDate) : undefined,
    taxExpiryDate: obj.taxExpiryDate ? new Date(obj.taxExpiryDate) : undefined,
    createdAt: obj.createdAt ? new Date(obj.createdAt) : new Date(),
    updatedAt: obj.updatedAt ? new Date(obj.updatedAt) : new Date(),
    createdBy: obj.createdBy,
    updatedBy: obj.updatedBy,
    ...obj, // spread any additional properties
  };
}


--- ./src/environments/environment.prod.ts ---
export const environment = {
  production: true,
  firebase: {
    apiKey: 'AIzaSyBUqjn2Zuiv8mGSse4YAmSH1uZDXUzOzKA',
    authDomain: 'ni-vehicle-logistics-ef2bf.firebaseapp.com',
    projectId: 'ni-vehicle-logistics-ef2bf',
    storageBucket: 'ni-vehicle-logistics-ef2bf.firebasestorage.app',
    messagingSenderId: '1043357428512',
    appId: '1:1043357428512:web:7c4659dc471ee20ba40545',
    measurementId: 'G-M3SC9Z72FM',
  },
  appVersion: '1.0.0',
};


--- ./src/environments/environment.ts ---
export const environment = {
  production: false,
  firebase: {
    apiKey: 'AIzaSyBUqjn2Zuiv8mGSse4YAmSH1uZDXUzOzKA',
    authDomain: 'ni-vehicle-logistics-ef2bf.firebaseapp.com',
    projectId: 'ni-vehicle-logistics-ef2bf',
    storageBucket: 'ni-vehicle-logistics-ef2bf.firebasestorage.app',
    messagingSenderId: '1043357428512',
    appId: '1:1043357428512:web:7c4659dc471ee20ba40545',
    measurementId: 'G-M3SC9Z72FM',
  },
  appVersion: '1.0.0',
};

/*
 * For easier debugging in development mode, you can import the following file
 * to ignore zone related error stack frames such as `zone.run`, `zoneDelegate.invokeTask`.
 *
 * This import should be commented out in production mode because it will have a negative impact
 * on performance if an error is thrown.
 */
